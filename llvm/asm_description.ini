[settings]
name = "Symphony"

[fields]

register
zr 0000
r1 0001
r2 0010
r3 0011
r4 0100
r5 0101
r6 0110
r7 0111
r8 1000
r9 1001
r10 1010
r11 1011
r12 1100
r13 1101
sp 1110
flags 1111

[instructions]

nop
00000000 00000000 00000000 00000000
Does nothing

in %a(register)
00000001 aaaa0000 00000000 00000000
Loads an input and stores it in %a

out %a(register)
00000010 00000000 0000aaaa 00000000
Sends %a to output

out %a(immediate)
00010010 00000000 aaaaaaaa aaaaaaaa
Sends %a to output

console %a(register)
00000011 00000000 0000aaaa 00000000
Stores the value of %a in the console offset register

console %a(immediate)
00010011 00000000 aaaaaaaa aaaaaaaa
Stores the value of %a in the console offset register

time_0 %a(register)
00000100 aaaa0000 00000000 00000000
Loads the two least significant bytes of the time value and stores it to %a

time_1 %a(register)
00000101 aaaa0000 00000000 00000000
Loads the second two bytes of the time value and stores it to %a

time_2 %a(register)
00000110 aaaa0000 00000000 00000000
Loads the third two bytes of the time value and stores it to %a

time_3 %a(register)
00000111 aaaa0000 00000000 00000000
Loads the two most significant bytes of the time value and stores it to %a

counter %a(register)
00001000 aaaa0000 00000000 00000000
Loads the counter value and stores it to %a

keyboard %a(register)
00001001 aaaa0000 00000000 00000000
Loads keyboard input and stores it to %a



nand %a(register), %b(register), %c(register)
00100000 aaaabbbb 0000cccc 00000000
NAND %b and %c and store the result in %a.

or %a(register), %b(register), %c(register)
00100001 aaaabbbb 0000cccc 00000000
OR %b and %c and store the result in %a.

and %a(register), %b(register), %c(register)
00100010 aaaabbbb 0000cccc 00000000
AND %b and %c and store the result in %a.

nor %a(register), %b(register), %c(register)
00100011 aaaabbbb 0000cccc 00000000
NOR %b and %c and store the result in %a.

add %a(register), %b(register), %c(register)
00100100 aaaabbbb 0000cccc 00000000
ADD %b and %c and store the result in %a.

sub %a(register), %b(register), %c(register)
00100101 aaaabbbb 0000cccc 00000000
SUB %b and %c and store the result in %a.

xor %a(register), %b(register), %c(register)
00100110 aaaabbbb 0000cccc 00000000
XOR %b and %c and store the result in %a.

lsl %a(register), %b(register), %c(register)
00100111 aaaabbbb 0000cccc 00000000
Logical shift left %b by %c and store the result in %a.

lsr %a(register), %b(register), %c(register)
00101000 aaaabbbb 0000cccc 00000000
Logical shift right %b by %c and store the result in %a.

cmp %a(register), %b(register)
00101001 1111aaaa 0000bbbb 00000000
Compares %a and %b and store the resulting flags in 'flags'.

mul %a(register), %b(register), %c(register)
00101010 aaaabbbb 0000cccc 00000000
MUL %b and %c and store the result in %a.


nand %a(register), %b(register), %c(immediate)
00110000 aaaabbbb cccccccc cccccccc
NAND %b and %c and store the result in %a.

or %a(register), %b(register), %c(immediate)
00110001 aaaabbbb cccccccc cccccccc
OR %b and %c and store the result in %a.

or %a(register), %b(register), %c(immediate)
00110001 aaaabbbb cccccccc cccccccc
OR %b and %c and store the result in %a.

nor %a(register), %b(register), %c(immediate)
00110011 aaaabbbb cccccccc cccccccc
NOR %b and %c and store the result in %a.

and %a(register), %b(register), %c(immediate)
00110010 aaaabbbb cccccccc cccccccc
AND %b and %c and store the result in %a.

add %a(register), %b(register), %c(immediate)
00110100 aaaabbbb cccccccc cccccccc
ADD %b and %c and store the result in %a.

sub %a(register), %b(register), %c(immediate)
00110101 aaaabbbb cccccccc cccccccc
SUB %b and %c and store the result in %a.

xor %a(register), %b(register), %c(immediate)
00110110 aaaabbbb cccccccc cccccccc
XOR %b and %c and store the result in %a.

lsl %a(register), %b(register), %c(immediate)
00110111 aaaabbbb cccccccc cccccccc
Logical shift left %b by %c and store the result in %a.

lsr %a(register), %b(register), %c(immediate)
00111000 aaaabbbb cccccccc cccccccc
Logical shift right %b by %c and store the result in %a.

cmp %a(register), %b(immediate)
00111001 1111aaaa bbbbbbbb bbbbbbbb
Compares %a and %b and store the resulting flags in 'flags'.

mul %a(register), %b(register), %c(immediate)
00111010 aaaabbbb cccccccc cccccccc
MUL %b and %c and store the result in %a.



jmp %a(register)
01001000 00001111 0000aaaa 00000000
Jump to %a

jmp %a(immediate | label)
01011000 00001111 aaaaaaaa aaaaaaaa
Jump to %a


je %a(immediate | label)
01010001 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the values were equal (reading results from 'flags').

jne %a(immediate | label)
01011001 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the values were not equal (reading results from 'flags').


jl %a(immediate | label)
01010100 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was less (signed) than the second (reading results from 'flags').

jge %a(immediate | label)
01011100 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was greater (signed) or equal to the second (reading results from 'flags').

jle %a(immediate | label)
01010101 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was less (signed) or equal to the second (reading results from 'flags').

jg %a(immediate | label)
01011101 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was greater (signed) than the second (reading results from 'flags').


jb %a(immediate | label)
01010010 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was below (unsigned) the second (reading results from 'flags').

jae %a(immediate | label)
01011010 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was above (unsigned) or equal to the second (reading results from 'flags').

jbe %a(immediate | label)
01010011 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the First value was below (unsigned) or equal to the second (reading results from 'flags').

ja %a(immediate | label)
01011011 00001111 aaaaaaaa aaaaaaaa
Jump to %a if the first value was above (unsigned) the second (reading results from 'flags').



load_8 %dest(register), [%address(register)]
01100000 dddd0000 0000aaaa 00000000
Loads %address from RAM and stores it to %dest

load_8 %dest(register), [%address(immediate)]
01110000 dddd0000 aaaaaaaa aaaaaaaa
Loads %address from RAM and stores it to %dest

store_8 [%address(register)], %value(register)
01100001 0000vvvv 0000aaaa 00000000
Store %value to %address in RAM

store_8 [%address(immediate)], %value(register)
01110001 0000vvvv aaaaaaaa aaaaaaaa
Store %value to %address in RAM

load_16 %dest(register), [%address(register)]
01100010 dddd0000 0000aaaa 00000000
Loads %address from RAM and stores it to %dest

load_16 %dest(register), [%address(immediate)]
01110010 dddd0000 aaaaaaaa aaaaaaaa
Loads %address from RAM and stores it to %dest

store_16 [%address(register)], %value(register)
01100011 0000vvvv 0000aaaa 00000000
Store %value to %address in RAM

store_16 [%address(immediate)], %value(register)
01110011 0000vvvv aaaaaaaa aaaaaaaa
Store %value to %address in RAM

pload_8 %dest(register), [%address(register)]
01100100 dddd0000 0000aaaa 00000000
Loads %address from SSD and stores it to %dest

pload_8 %dest(register), [%address(immediate)]
01110100 dddd0000 aaaaaaaa aaaaaaaa
Loads %address from SSD and stores it to %dest

pstore_8 [%address(register)], %value(register)
01100101 0000vvvv 0000aaaa 00000000
Store %value to %address in SSD

pstore_8 [%address(immediate)], %value(register)
01110101 0000vvvv aaaaaaaa aaaaaaaa
Store %value to %address in SSD

pload_16 %dest(register), [%address(register)]
01100110 dddd0000 0000aaaa 00000000
Loads %address from SSD and stores it to %dest

pload_16 %dest(register), [%address(immediate)]
01110110 dddd0000 aaaaaaaa aaaaaaaa
Loads %address from SSD and stores it to %dest

pstore_16 [%address(register)], %value(register)
01100111 0000vvvv 0000aaaa 00000000
Store %value to %address in SSD

pstore_16 [%address(immediate)], %value(register)
01110111 0000vvvv aaaaaaaa aaaaaaaa
Store %value to %address in SSD



;mov %a(register), %b(register)
;00100001 aaaabbbb 00000000 00000000
;Move from %b to %a

neg %a(register), %b(register)
00100101 aaaa0000 0000bbbb 00000000
Neg %b and store the result in %a.

not %a(register), %b(register)
00100011 aaaa0000 0000bbbb 00000000
Not %b and store the result in %a.


;mov %a(register), %b(immediate)
;00110001 aaaa0000 bbbbbbbb bbbbbbbb
;Move from %b to %a

neg %a(register), %b(immediate)
00110101 aaaa0000 bbbbbbbb bbbbbbbb
Neg %b and store the result in %a.

not %a(register), %b(immediate)
00110011 aaaa0000 bbbbbbbb bbbbbbbb
Not %b and store the result in %a.


push %a(register)
00110101 11101110 00000000 00000010   01100011 0000aaaa 00001110 00000000
Pushes %a on to the stack. This instruction is a synonym for:   sub sp, sp, 2   store_16 [sp], %a

pop %a(register)
01100010 aaaa0000 00001110 00000000   00110100 11101110 00000000 00000010
Pops %a off the stack. This instruction is a synonym for:   load_16 %a, [sp]   add sp, sp, 2

call %a(label)
00001000 11110000 00000000 00000000   00110100 11111111 00000000 00010100   00110101 11101110 00000000 00000010   01100011 00001111 00001110 00000000   01011000 00001111 aaaaaaaa aaaaaaaa
Calls %a. Overwrites the flag register. This instruction is a synonym for:   counter flags   add flags, flags, 20   sub sp, sp, 2   store_16 [sp], flags   jmp %a

ret
01100010 11110000 00001110 00000000   00110100 11101110 00000000 00000010   01001000 00001111 00001111 00000000
Returns from the last function call. Overwrites the flag register. This instruction is a synonym for:   load_16 flags, [sp]   add sp, sp, 2   jmp flags


;添加的指令，需修改ALU

udiv %a(register), %b(register), %c(register)
00101011 aaaabbbb 0000cccc 00000000

udiv %a(register), %b(register), %c(immediate)
00111011 aaaabbbb cccccccc cccccccc

asr %a(register), %b(register), %c(register)
00101100 aaaabbbb 0000cccc 00000000
shift right arithmetic

asr %a(register), %b(register), %c(immediate)
00111100 aaaabbbb cccccccc cccccccc
shift right arithmetic

urem %a(register), %b(register), %c(register)
00101101 aaaabbbb 0000cccc 00000000
unsigned rem

urem %a(register), %b(register), %c(immediate)
00111101 aaaabbbb cccccccc cccccccc
unsigned rem

mov %a(register), %b(immediate)
10011000 aaaa1111 bbbbbbbb bbbbbbbb


cmove %a(register), %b(immediate)
10010001 aaaa1111 bbbbbbbb bbbbbbbb
if flag is equal then a=b

cmovne %a(register), %b(immediate)
10011001 aaaa1111 bbbbbbbb bbbbbbbb
if flag is nequal then a=b

cmovl %a(register), %b(immediate)
10010100 aaaa1111 bbbbbbbb bbbbbbbb
if flag is lower then a=b

cmovge %a(register), %b(immediate)
10011100 aaaa1111 bbbbbbbb bbbbbbbb
if flag is greater qual then a=b

cmovle %a(register), %b(immediate)
10010101 aaaa1111 bbbbbbbb bbbbbbbb
if flag is lower qual then a=b

cmovg %a(register), %b(immediate)
10011101 aaaa1111 bbbbbbbb bbbbbbbb
if flag is greater then a=b

cmovb %a(register), %b(immediate)
10010010 aaaa1111 bbbbbbbb bbbbbbbb
if flag is below qual then a=b

cmovae %a(register), %b(immediate)
10011010 aaaa1111 bbbbbbbb bbbbbbbb
if flag is above equal qual then a=b

cmovbe %a(register), %b(immediate)
10010010 aaaa1111 bbbbbbbb bbbbbbbb
if flag is below equal qual then a=b

cmova %a(register), %b(immediate)
10011011 aaaa1111 bbbbbbbb bbbbbbbb
if flag is above qual then a=b


mov %a(register), %b(register)
10001000 aaaa1111 0000bbbb 00000000

cmove %a(register), %b(register)
10000001 aaaa1111 0000bbbb 00000000

cmovne %a(register), %b(register)
10001001 aaaa1111 0000bbbb 00000000

cmovl %a(register), %b(register)
10000100 aaaa1111 0000bbbb 00000000

cmovge %a(register), %b(register)
10001100 aaaa1111 0000bbbb 00000000

cmovle %a(register), %b(register)
10000101 aaaa1111 0000bbbb 00000000

cmovg %a(register), %b(register)
10001101 aaaa1111 0000bbbb 00000000

cmovb %a(register), %b(register)
10000010 aaaa1111 0000bbbb 00000000

cmovae %a(register), %b(register)
10001010 aaaa1111 0000bbbb 00000000

cmovbe %a(register), %b(register)
10000010 aaaa1111 0000bbbb 00000000

cmova %a(register), %b(register)
10001011 aaaa1111 0000bbbb 00000000
;伪指令

;slt %a(register), %b(register), %c(register)
;00101001 1111bbbb 0000cccc 00000000 00101011 aaaa1111 00000000 00000100
;signed if b<c than a=1 else 0. cmp %b, %c    cond %a, flags, 0100

;sltu %a(register), %b(register), %c(register)
;00101001 1111bbbb 0000cccc 00000000 00101011 aaaa1111 00000000 00000010
;unsigned if b<c than a=1 else 0. cmp %b, %c    cond %a, flags, 0010


;beq %a(register), %b(register), %c(immediate | label)
;00101001 1111aaaa 0000bbbb 00000000 01010001 00001111 cccccccc cccccccc