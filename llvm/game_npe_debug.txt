Args: E:\C++lib\llvm-21.1.0\llvm\cmake-build-debug\bin\llc.exe -O0 --march=symphony -filetype=asm .\game_npe.ll -o .\game_npe.s --debug 
[SafeStack] Function: input
[SafeStack]     safestack is not requested for this function
Skipping pass 'Symphony DAG->DAG Pattern Instruction Selection' on function input
	FastISel is enabled



=== input
Enabling fast-isel
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
Creating new node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Creating new node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Initial selection DAG: %bb.0 'input:'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Combining: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Combining: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

Combining: t5: i16 = Register $r1

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 'input:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Legalizing node: t5: i16 = Register $r1
Ignoring node results
Legally typed node: t5: i16 = Register $r1

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16

Legalizing node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

Legalizing node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal operand
Legally typed node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.0 'input:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Legalizing: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal node: nothing to do

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
Legalizing non-extending load operation

Legalizing: t5: i16 = Register $r1

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 'input:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Legalizing: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Legal node: nothing to do

Combining: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16

Legalizing: t5: i16 = Register $r1

Combining: t5: i16 = Register $r1

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 'input:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Selecting: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

ISEL: Starting pattern match
  Morphed node: t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Selecting: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.1)> t0, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.1)> FrameIndex:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i16 = Register $r1
Selecting: t5: i16 = Register $r1


ISEL: Starting selection on root node: t1: i16 = FrameIndex<0>
Selecting: t1: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t9: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.0 'input:'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
      t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
    t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.1)> t1, t0
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1


********** List Scheduling %bb.0 '' **********
SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.1)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


*** Scheduling [0]: SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


Examining Available:
Height 1: SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.1)> t1, t0


*** Scheduling [1]: SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.1)> t1, t0


Examining Available:
Height 2: SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


*** Scheduling [2]: SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

*** Final schedule ***
SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.1)> t1, t0

SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function input: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2, align=2, at location [SP]

bb.0 (%ir-block.0):
  %0:gpr = ADDI %stack.0, 0
  %1:gpr = LOAD16R killed %0:gpr :: (dereferenceable load (s16) from %ir.1)
  $r1 = COPY %1:gpr
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1

# End machine code for function input.

Skipping pass 'Two-Address instruction pass' on function input
********** REWRITING TWO-ADDR INSTRS **********
********** Function: input
********** FAST REGISTER ALLOCATION **********
********** Function: input

Allocating bb.0 (%ir-block.0):
  %0:gpr = ADDI %stack.0, 0
  %1:gpr = LOAD16R killed %0:gpr :: (dereferenceable load (s16) from %ir.1)
  $r1 = COPY %1:gpr
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1

>> SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1
Regs:
<< SymphonyRet implicit-def dead $sp, implicit $flags, implicit killed $r1

>> $r1 = COPY %1:gpr
Regs: R1[P]
Freeing $r1:
Search register for %1 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %1 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %1:gpr = LOAD16R killed %0:gpr :: (dereferenceable load (s16) from %ir.1)
Regs: R1=%1
In def of %1 use existing assignment to $r1
Freeing $r1: %1
Search register for %0 in class GPR with hint $noreg
AllocationOrder(GPR) = [ $r1 $r2 $r3 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $r12 ]
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %0 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.1)

>> %0:gpr = ADDI %stack.0, 0
Regs: R1=%0
In def of %0 use existing assignment to $r1
Freeing $r1: %0
<< $r1 = ADDI %stack.0, 0
Begin Regs:
Loading live registers at begin of block.
bb.0 (%ir-block.0):
  $r1 = ADDI %stack.0, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.1)
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit killed $r1
Skipping pass 'Fixup Statepoint Caller Saved' on function input
alloc FI(0) at SP[-2]
$r1 = ADDI %stack.0, 0
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: input
Skipping pass 'Remove Loads Into Fake Uses' on function input

Debug Range Extension: input
[SafeStack] Function: output
[SafeStack]     safestack is not requested for this function
Skipping pass 'Symphony DAG->DAG Pattern Instruction Selection' on function output
	FastISel is enabled



=== output
Enabling fast-isel
Found argument copy elision candidate:   %2 = alloca i16, align 2
Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Creating constant: t4: i16 = Constant<0>
Creating new node: t5: i16 = undef
Creating new node: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
Creating new node: t7: ch = SymphonyISD::RET_GLUE t6

Initial selection DAG: %bb.0 'output:'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
  t4: i16 = Constant<0>
      t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
  t7: ch = SymphonyISD::RET_GLUE t6



Combining: t7: ch = SymphonyISD::RET_GLUE t6

Combining: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16

Combining: t5: i16 = undef

Combining: t3: i16 = FrameIndex<0>

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Combining: t1: i16 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 'output:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
      t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
  t7: ch = SymphonyISD::RET_GLUE t6



Legalizing node: t5: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = undef

Legalizing node: t3: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = FrameIndex<0>

Legalizing node: t1: i16 = Register %0
Ignoring node results
Legally typed node: t1: i16 = Register %0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Legalizing node: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal operand
Analyzing operand: t3: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t5: i16 = undef
Legal operand
Legally typed node: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16

Legalizing node: t7: ch = SymphonyISD::RET_GLUE t6
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
Legal operand
Legally typed node: t7: ch = SymphonyISD::RET_GLUE t6

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = SymphonyISD::RET_GLUE t6
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.0 'output:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
      t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
  t7: ch = SymphonyISD::RET_GLUE t6



Legalizing: t7: ch = SymphonyISD::RET_GLUE t6
Legal node: nothing to do

Legalizing: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal node: nothing to do

Legalizing: t5: i16 = undef
Legal node: nothing to do

Legalizing: t3: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t1: i16 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 'output:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
      t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
  t7: ch = SymphonyISD::RET_GLUE t6



Legalizing: t7: ch = SymphonyISD::RET_GLUE t6
Legal node: nothing to do

Combining: t7: ch = SymphonyISD::RET_GLUE t6

Legalizing: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Legalizing: t5: i16 = undef
Legal node: nothing to do

Combining: t5: i16 = undef

Legalizing: t3: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t3: i16 = FrameIndex<0>

Legalizing: t1: i16 = Register %0

Combining: t1: i16 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 'output:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
      t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
  t7: ch = SymphonyISD::RET_GLUE t6


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t7: ch = SymphonyISD::RET_GLUE t6
Selecting: t7: ch = SymphonyISD::RET_GLUE t6

ISEL: Starting pattern match
  Initial Opcode index to 902
  Morphed node: t7: i16,ch = SymphonyRet t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16
Selecting: t6: ch = store<(store (s16) into %ir.2)> t0, t2, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t6: ch = STORE16R<Mem:(store (s16) into %ir.2)> FrameIndex:i16<0>, t2, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %0


ISEL: Starting selection on root node: t3: i16 = FrameIndex<0>
Selecting: t3: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t9: i16 = TargetConstant<0>
  Morphed node: t3: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = Register %0
Selecting: t1: i16 = Register %0


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.0 'output:'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
      t3: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t6: ch = STORE16R<Mem:(store (s16) into %ir.2)> t3, t2, t0
  t7: i16,ch = SymphonyRet t6


********** List Scheduling %bb.0 '' **********
SU(0): t7: i16,ch = SymphonyRet t6

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t6: ch = STORE16R<Mem:(store (s16) into %ir.2)> t3, t2, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t2: i16,ch = CopyFromReg t0, Register:i16 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t3: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: i16,ch = SymphonyRet t6


*** Scheduling [0]: SU(0): t7: i16,ch = SymphonyRet t6


Examining Available:
Height 1: SU(1): t6: ch = STORE16R<Mem:(store (s16) into %ir.2)> t3, t2, t0


*** Scheduling [1]: SU(1): t6: ch = STORE16R<Mem:(store (s16) into %ir.2)> t3, t2, t0


Examining Available:
Height 2: SU(3): t3: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(2): t2: i16,ch = CopyFromReg t0, Register:i16 %0


*** Scheduling [2]: SU(3): t3: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t2: i16,ch = CopyFromReg t0, Register:i16 %0


*** Scheduling [3]: SU(2): t2: i16,ch = CopyFromReg t0, Register:i16 %0

*** Final schedule ***
SU(2): t2: i16,ch = CopyFromReg t0, Register:i16 %0

SU(3): t3: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(1): t6: ch = STORE16R<Mem:(store (s16) into %ir.2)> t3, t2, t0

SU(0): t7: i16,ch = SymphonyRet t6


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function output: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2, align=2, at location [SP]
Function Live Ins: $r1 in %0

bb.0 (%ir-block.1):
  liveins: $r1
  %0:gpr = COPY $r1
  %1:gpr = ADDI %stack.0, 0
  STORE16R killed %1:gpr, %0:gpr :: (store (s16) into %ir.2)
  SymphonyRet implicit-def dead $sp, implicit $flags

# End machine code for function output.

Skipping pass 'Two-Address instruction pass' on function output
********** REWRITING TWO-ADDR INSTRS **********
********** Function: output
********** FAST REGISTER ALLOCATION **********
********** Function: output

Allocating bb.0 (%ir-block.1):
  liveins: $r1
  %0:gpr = COPY $r1
  %1:gpr = ADDI %stack.0, 0
  STORE16R killed %1:gpr, %0:gpr :: (store (s16) into %ir.2)
  SymphonyRet implicit-def dead $sp, implicit $flags

>> SymphonyRet implicit-def dead $sp, implicit $flags
Regs:
<< SymphonyRet implicit-def dead $sp, implicit $flags

>> STORE16R killed %1:gpr, %0:gpr :: (store (s16) into %ir.2)
Regs:
Search register for %1 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %1 to $r1
Search register for %0 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %0 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)

>> %1:gpr = ADDI %stack.0, 0
Regs: R1=%1 R2=%0
In def of %1 use existing assignment to $r1
Freeing $r1: %1
<< $r1 = ADDI %stack.0, 0

>> %0:gpr = COPY $r1
Regs: R2=%0
In def of %0 use existing assignment to $r2
Freeing $r2: %0
<< $r2 = COPY killed $r1
Begin Regs: R1[P]
Loading live registers at begin of block.
bb.0 (%ir-block.1):
  liveins: $r1
  $r2 = COPY killed $r1
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)
  SymphonyRet implicit-def dead $sp, implicit $flags
Skipping pass 'Fixup Statepoint Caller Saved' on function output
alloc FI(0) at SP[-2]
$r1 = ADDI %stack.0, 0
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: output
Skipping pass 'Remove Loads Into Fake Uses' on function output

Debug Range Extension: output
[SafeStack] Function: is_op
[SafeStack]     safestack is not requested for this function
Skipping pass 'Symphony DAG->DAG Pattern Instruction Selection' on function is_op
	FastISel is enabled



=== is_op
Enabling fast-isel
Found argument copy elision candidate:   %3 = alloca i16, align 2
Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Creating constant: t4: i16 = Constant<0>
Creating new node: t5: i16 = undef
Creating new node: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Case clusters: 38 43 45 60 62 94 124 
Creating constant: t9: i16 = Constant<1>
Creating new node: t10: i16 = extract_element t8, Constant:i16<1>
Creating new node: t11: i16 = extract_element t8, Constant:i16<0>
Creating new node: t13: ch = CopyToReg t0, Register:i16 %1, t10
Creating new node: t15: ch = CopyToReg t0, Register:i16 %2, t11
Creating new node: t16: ch = TokenFactor t13, t15
Creating constant: t17: i32 = Constant<38>
Creating new node: t19: i1 = setcc t8, Constant:i32<38>, seteq:ch
Creating new node: t21: ch = TokenFactor t16, t6
Creating new node: t22: ch = brcond t21, t19, BasicBlock:ch< 0x16b38288020>
Creating new node: t24: ch = br t22, BasicBlock:ch< 0x16b38288498>

Initial selection DAG: %bb.0 'is_op:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
    t7: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
  t8: i32 = zero_extend t7
            t10: i16 = extract_element t8, Constant:i16<1>
          t13: ch = CopyToReg t0, Register:i16 %1, t10
            t11: i16 = extract_element t8, Constant:i16<0>
          t15: ch = CopyToReg t0, Register:i16 %2, t11
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
      t19: i1 = setcc t8, Constant:i32<38>, seteq:ch
    t22: ch = brcond t21, t19, BasicBlock:ch< 0x16b38288020>
  t24: ch = br t22, BasicBlock:ch< 0x16b38288498>



Combining: t24: ch = br t22, BasicBlock:ch< 0x16b38288498>

Combining: t23: ch = BasicBlock< 0x16b38288498>

Combining: t22: ch = brcond t21, t19, BasicBlock:ch< 0x16b38288020>

Combining: t21: ch = TokenFactor t16, t6

Combining: t20: ch = BasicBlock< 0x16b38288020>

Combining: t19: i1 = setcc t8, Constant:i32<38>, seteq:ch
Creating constant: t25: i16 = Constant<38>
Creating new node: t26: i16 = setcc t7, Constant:i16<38>, seteq:ch
Creating new node: t27: i1 = truncate t26
 ... into: t27: i1 = truncate t26

Combining: t27: i1 = truncate t26

Combining: t26: i16 = setcc t7, Constant:i16<38>, seteq:ch

Combining: t25: i16 = Constant<38>

Combining: t22: ch = brcond t21, t27, BasicBlock:ch< 0x16b38288020>

Combining: t18: ch = seteq

Combining: t16: ch = TokenFactor t13, t15

Combining: t15: ch = CopyToReg t0, Register:i16 %2, t11

Combining: t14: i16 = Register %2

Combining: t13: ch = CopyToReg t0, Register:i16 %1, t10

Combining: t12: i16 = Register %1

Combining: t11: i16 = extract_element t8, Constant:i16<0>

Combining: t10: i16 = extract_element t8, Constant:i16<1>

Combining: t9: i16 = Constant<1>

Combining: t8: i32 = zero_extend t7
Creating new node: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
Creating constant: t29: i32 = Constant<38>
Creating new node: t30: i16 = setcc t28, Constant:i32<38>, seteq:ch

Replacing.1 t26: i16 = setcc t7, Constant:i16<38>, seteq:ch

With: t30: i16 = setcc t28, Constant:i32<38>, seteq:ch
 and 0 other values

Replacing.1 t8: i32 = zero_extend t7

With: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
 and 0 other values

Combining: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16

Combining: t11: i16 = extract_element t28, Constant:i16<0>

Combining: t10: i16 = extract_element t28, Constant:i16<1>

Combining: t30: i16 = setcc t28, Constant:i32<38>, seteq:ch

Combining: t29: i32 = Constant<38>

Combining: t27: i1 = truncate t30

Combining: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = undef

Combining: t4: i16 = Constant<0>

Combining: t3: i16 = FrameIndex<1>

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Combining: t1: i16 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 'is_op:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
  t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
            t10: i16 = extract_element t28, Constant:i16<1>
          t13: ch = CopyToReg t0, Register:i16 %1, t10
            t11: i16 = extract_element t28, Constant:i16<0>
          t15: ch = CopyToReg t0, Register:i16 %2, t11
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
        t30: i16 = setcc t28, Constant:i32<38>, seteq:ch
      t27: i1 = truncate t30
    t22: ch = brcond t21, t27, BasicBlock:ch< 0x16b38288020>
  t24: ch = br t22, BasicBlock:ch< 0x16b38288498>



Legalizing node: t29: i32 = Constant<38>
Analyzing result type: i32
Expand integer result: t29: i32 = Constant<38>
Creating constant: t31: i16 = Constant<38>

Legalizing node: t31: i16 = Constant<38>
Analyzing result type: i16
Legal result type
Legally typed node: t31: i16 = Constant<38>

Legalizing node: t23: ch = BasicBlock< 0x16b38288498>
Analyzing result type: ch
Legal result type
Legally typed node: t23: ch = BasicBlock< 0x16b38288498>

Legalizing node: t20: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t20: ch = BasicBlock< 0x16b38288020>

Legalizing node: t18: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t18: ch = seteq

Legalizing node: t14: i16 = Register %2
Ignoring node results
Legally typed node: t14: i16 = Register %2

Legalizing node: t12: i16 = Register %1
Ignoring node results
Legally typed node: t12: i16 = Register %1

Legalizing node: t9: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t9: i16 = Constant<1>

Legalizing node: t5: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = undef

Legalizing node: t4: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = Constant<0>

Legalizing node: t3: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = FrameIndex<1>

Legalizing node: t1: i16 = Register %0
Ignoring node results
Legally typed node: t1: i16 = Register %0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Legalizing node: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal operand
Analyzing operand: t3: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t5: i16 = undef
Legal operand
Legally typed node: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16

Legalizing node: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
Analyzing result type: i32
Expand integer result: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
Creating new node: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

Legalizing node: t30: i16 = setcc t28, Constant:i32<38>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
Expand integer operand: t30: i16 = setcc t28, Constant:i32<38>, seteq:ch
Creating new node: t33: i16 = xor t32, Constant:i16<38>

Legalizing node: t11: i16 = extract_element t28, Constant:i16<0>
Analyzing result type: i16
Legal result type
Analyzing operand: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
Expand integer operand: t11: i16 = extract_element t28, Constant:i16<0>

Legalizing node: t10: i16 = extract_element t28, Constant:i16<1>
Analyzing result type: i16
Legal result type
Analyzing operand: t28: i32,ch = load<(dereferenceable load (s16) from %ir.3), zext from i16> t6, FrameIndex:i16<1>, undef:i16
Expand integer operand: t10: i16 = extract_element t28, Constant:i16<1>

Legalizing node: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i16 = Constant<0>
Legal operand
Legally typed node: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>

Legalizing node: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t3: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t5: i16 = undef
Legal operand
Legally typed node: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

Legalizing node: t33: i16 = xor t32, Constant:i16<38>
Analyzing result type: i16
Legal result type
Analyzing operand: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t31: i16 = Constant<38>
Legal operand
Legally typed node: t33: i16 = xor t32, Constant:i16<38>

Legalizing node: t30: i16 = setcc t33, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t33: i16 = xor t32, Constant:i16<38>
Legal operand
Analyzing operand: t4: i16 = Constant<0>
Legal operand
Analyzing operand: t18: ch = seteq
Legal operand
Legally typed node: t30: i16 = setcc t33, Constant:i16<0>, seteq:ch

Legalizing node: t27: i1 = truncate t30
Analyzing result type: i1
Promote integer result: t27: i1 = truncate t30

Legalizing node: t15: ch = CopyToReg t0, Register:i16 %2, t32
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t15: ch = CopyToReg t0, Register:i16 %2, t32

Legalizing node: t16: ch = TokenFactor t13, t15
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
Legal operand
Analyzing operand: t15: ch = CopyToReg t0, Register:i16 %2, t32
Legal operand
Legally typed node: t16: ch = TokenFactor t13, t15

Legalizing node: t21: ch = TokenFactor t16, t6
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = TokenFactor t13, t15
Legal operand
Analyzing operand: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t21: ch = TokenFactor t16, t6

Legalizing node: t22: ch = brcond t21, t27, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = TokenFactor t16, t6
Legal operand
Analyzing operand: t27: i1 = truncate t30
Promote integer operand: t22: ch = brcond t21, t27, BasicBlock:ch< 0x16b38288020>

Legalizing node: t22: ch = brcond t21, t30, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = TokenFactor t16, t6
Legal operand
Analyzing operand: t30: i16 = setcc t33, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t20: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t22: ch = brcond t21, t30, BasicBlock:ch< 0x16b38288020>

Legalizing node: t24: ch = br t22, BasicBlock:ch< 0x16b38288498>
Analyzing result type: ch
Legal result type
Analyzing operand: t22: ch = brcond t21, t30, BasicBlock:ch< 0x16b38288020>
Legal operand
Analyzing operand: t23: ch = BasicBlock< 0x16b38288498>
Legal operand
Legally typed node: t24: ch = br t22, BasicBlock:ch< 0x16b38288498>

Legalizing node: t65535: ch = handlenode t24
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = br t22, BasicBlock:ch< 0x16b38288498>
Legal operand
Legally typed node: t65535: ch = handlenode t24

Type-legalized selection DAG: %bb.0 'is_op:'
SelectionDAG has 22 nodes:
  t0: ch,glue = EntryToken
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
  t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
          t15: ch = CopyToReg t0, Register:i16 %2, t32
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
        t33: i16 = xor t32, Constant:i16<38>
      t30: i16 = setcc t33, Constant:i16<0>, seteq:ch
    t22: ch = brcond t21, t30, BasicBlock:ch< 0x16b38288020>
  t24: ch = br t22, BasicBlock:ch< 0x16b38288498>



Combining: t33: i16 = xor t32, Constant:i16<38>

Combining: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

Combining: t31: i16 = Constant<38>

Combining: t30: i16 = setcc t33, Constant:i16<0>, seteq:ch
Creating new node: t34: i16 = setcc t32, Constant:i16<38>, seteq:ch
 ... into: t34: i16 = setcc t32, Constant:i16<38>, seteq:ch

Combining: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

Combining: t31: i16 = Constant<38>

Combining: t34: i16 = setcc t32, Constant:i16<38>, seteq:ch

Combining: t24: ch = br t22, BasicBlock:ch< 0x16b38288498>

Combining: t23: ch = BasicBlock< 0x16b38288498>

Combining: t22: ch = brcond t21, t34, BasicBlock:ch< 0x16b38288020>
Creating new node: t35: ch = br_cc t21, seteq:ch, t32, Constant:i16<38>, BasicBlock:ch< 0x16b38288020>
 ... into: t35: ch = br_cc t21, seteq:ch, t32, Constant:i16<38>, BasicBlock:ch< 0x16b38288020>

Combining: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

Combining: t31: i16 = Constant<38>

Combining: t35: ch = br_cc t21, seteq:ch, t32, Constant:i16<38>, BasicBlock:ch< 0x16b38288020>

Combining: t24: ch = br t35, BasicBlock:ch< 0x16b38288498>

Combining: t21: ch = TokenFactor t16, t6

Combining: t20: ch = BasicBlock< 0x16b38288020>

Combining: t18: ch = seteq

Combining: t16: ch = TokenFactor t13, t15

Combining: t15: ch = CopyToReg t0, Register:i16 %2, t32

Combining: t14: i16 = Register %2

Combining: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>

Combining: t12: i16 = Register %1

Combining: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = undef

Combining: t4: i16 = Constant<0>

Combining: t3: i16 = FrameIndex<1>

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Combining: t1: i16 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.0 'is_op:'
SelectionDAG has 20 nodes:
  t0: ch,glue = EntryToken
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
  t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
          t15: ch = CopyToReg t0, Register:i16 %2, t32
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
    t35: ch = br_cc t21, seteq:ch, t32, Constant:i16<38>, BasicBlock:ch< 0x16b38288020>
  t24: ch = br t35, BasicBlock:ch< 0x16b38288498>



Legalizing: t24: ch = br t35, BasicBlock:ch< 0x16b38288498>
Legal node: nothing to do

Legalizing: t35: ch = br_cc t21, seteq:ch, t32, Constant:i16<38>, BasicBlock:ch< 0x16b38288020>
Trying custom legalization
Creating new node: t36: glue = SymphonyISD::CMP t32, Constant:i16<38>
Creating constant: t37: i16 = Constant<1>
Creating new node: t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36
Successfully custom legalized node
 ... replacing: t35: ch = br_cc t21, seteq:ch, t32, Constant:i16<38>, BasicBlock:ch< 0x16b38288020>
     with:      t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36

Legalizing: t21: ch = TokenFactor t16, t6
Legal node: nothing to do

Legalizing: t16: ch = TokenFactor t13, t15
Legal node: nothing to do

Legalizing: t15: ch = CopyToReg t0, Register:i16 %2, t32
Legal node: nothing to do

Legalizing: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal node: nothing to do

Legalizing: t31: i16 = Constant<38>
Legal node: nothing to do

Legalizing: t23: ch = BasicBlock< 0x16b38288498>
Legal node: nothing to do

Legalizing: t20: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t14: i16 = Register %2

Legalizing: t12: i16 = Register %1

Legalizing: t5: i16 = undef
Legal node: nothing to do

Legalizing: t4: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t3: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t1: i16 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36
Legal node: nothing to do

Legalizing: t37: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t36: glue = SymphonyISD::CMP t32, Constant:i16<38>
Legal node: nothing to do

Legalized selection DAG: %bb.0 'is_op:'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
  t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
          t15: ch = CopyToReg t0, Register:i16 %2, t32
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
      t36: glue = SymphonyISD::CMP t32, Constant:i16<38>
    t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36
  t24: ch = br t38, BasicBlock:ch< 0x16b38288498>



Legalizing: t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36
Legal node: nothing to do

Combining: t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36

Legalizing: t37: i16 = Constant<1>
Legal node: nothing to do

Combining: t37: i16 = Constant<1>

Legalizing: t36: glue = SymphonyISD::CMP t32, Constant:i16<38>
Legal node: nothing to do

Combining: t36: glue = SymphonyISD::CMP t32, Constant:i16<38>

Legalizing: t24: ch = br t38, BasicBlock:ch< 0x16b38288498>
Legal node: nothing to do

Combining: t24: ch = br t38, BasicBlock:ch< 0x16b38288498>

Legalizing: t21: ch = TokenFactor t16, t6
Legal node: nothing to do

Combining: t21: ch = TokenFactor t16, t6

Legalizing: t16: ch = TokenFactor t13, t15
Legal node: nothing to do

Combining: t16: ch = TokenFactor t13, t15

Legalizing: t15: ch = CopyToReg t0, Register:i16 %2, t32
Legal node: nothing to do

Combining: t15: ch = CopyToReg t0, Register:i16 %2, t32

Legalizing: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

Legalizing: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16

Legalizing: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
Legal node: nothing to do

Combining: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Legalizing: t31: i16 = Constant<38>
Legal node: nothing to do

Combining: t31: i16 = Constant<38>

Legalizing: t23: ch = BasicBlock< 0x16b38288498>
Legal node: nothing to do

Combining: t23: ch = BasicBlock< 0x16b38288498>

Legalizing: t20: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t20: ch = BasicBlock< 0x16b38288020>

Legalizing: t14: i16 = Register %2

Combining: t14: i16 = Register %2

Legalizing: t12: i16 = Register %1

Combining: t12: i16 = Register %1

Legalizing: t5: i16 = undef
Legal node: nothing to do

Combining: t5: i16 = undef

Legalizing: t4: i16 = Constant<0>
Legal node: nothing to do

Combining: t4: i16 = Constant<0>

Legalizing: t3: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t3: i16 = FrameIndex<1>

Legalizing: t1: i16 = Register %0

Combining: t1: i16 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 'is_op:'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
  t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
          t15: ch = CopyToReg t0, Register:i16 %2, t32
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
      t36: glue = SymphonyISD::CMP t32, Constant:i16<38>
    t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36
  t24: ch = br t38, BasicBlock:ch< 0x16b38288498>


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t24: ch = br t38, BasicBlock:ch< 0x16b38288498>
Selecting: t24: ch = br t38, BasicBlock:ch< 0x16b38288498>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t24: ch = JMPI BasicBlock:ch< 0x16b38288498>, t38
ISEL: Match complete!

ISEL: Starting selection on root node: t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36
Selecting: t38: ch = SymphonyISD::BR_CC t21, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t36

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t38: ch = JEI BasicBlock:ch< 0x16b38288020>, t21, t36
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = TokenFactor t16, t6
Selecting: t21: ch = TokenFactor t16, t6


ISEL: Starting selection on root node: t16: ch = TokenFactor t13, t15
Selecting: t16: ch = TokenFactor t13, t15


ISEL: Starting selection on root node: t15: ch = CopyToReg t0, Register:i16 %2, t32
Selecting: t15: ch = CopyToReg t0, Register:i16 %2, t32


ISEL: Starting selection on root node: t36: glue = SymphonyISD::CMP t32, Constant:i16<38>
Selecting: t36: glue = SymphonyISD::CMP t32, Constant:i16<38>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t39: i16 = TargetConstant<38>
  Morphed node: t36: i16,glue = CMPI t32, TargetConstant:i16<38>
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16
Selecting: t32: i16,ch = load<(dereferenceable load (s16) from %ir.3)> t6, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> FrameIndex:i16<1>, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16
Selecting: t6: ch = store<(store (s16) into %ir.3)> t0, t2, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t6: ch = STORE16R<Mem:(store (s16) into %ir.3)> FrameIndex:i16<1>, t2, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>
Selecting: t13: ch = CopyToReg t0, Register:i16 %1, Constant:i16<0>


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %0


ISEL: Starting selection on root node: t23: ch = BasicBlock< 0x16b38288498>
Selecting: t23: ch = BasicBlock< 0x16b38288498>


ISEL: Starting selection on root node: t20: ch = BasicBlock< 0x16b38288020>
Selecting: t20: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t14: i16 = Register %2
Selecting: t14: i16 = Register %2


ISEL: Starting selection on root node: t12: i16 = Register %1
Selecting: t12: i16 = Register %1


ISEL: Starting selection on root node: t4: i16 = Constant<0>
Selecting: t4: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t40: i16 = TargetConstant<0>
  Morphed node: t4: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t3: i16 = FrameIndex<1>
Selecting: t3: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t3: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = Register %0
Selecting: t1: i16 = Register %0


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.0 'is_op:'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
  t3: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
    t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t6: ch = STORE16R<Mem:(store (s16) into %ir.3)> t3, t2, t0
  t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6
            t4: i16 = MOVI TargetConstant:i16<0>
          t13: ch = CopyToReg t0, Register:i16 %1, t4
          t15: ch = CopyToReg t0, Register:i16 %2, t32
        t16: ch = TokenFactor t13, t15
      t21: ch = TokenFactor t16, t6
      t36: i16,glue = CMPI t32, TargetConstant:i16<38>
    t38: ch = JEI BasicBlock:ch< 0x16b38288020>, t21, t36:1
  t24: ch = JMPI BasicBlock:ch< 0x16b38288498>, t38


********** List Scheduling %bb.0 '' **********
SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38288498>, t38

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t38: ch = JEI BasicBlock:ch< 0x16b38288020>, t21, t36:1

    t36: i16,glue = CMPI t32, TargetConstant:i16<38>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(6): Ord  Latency=0 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
    SU(8): Data Latency=1
SU(3): t6: ch = STORE16R<Mem:(store (s16) into %ir.3)> t3, t2, t0

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(6): Ord  Latency=1 Barrier
SU(4): t2: i16,ch = CopyFromReg t0, Register:i16 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(3): Data Latency=1
SU(5): t3: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(3): Data Latency=1
SU(6): t21: ch = TokenFactor t16, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(7): Ord  Latency=0 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(7): t16: ch = TokenFactor t13, t15

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(9): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=0 Barrier
SU(8): t15: ch = CopyToReg t0, Register:i16 %2, t32

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t13: ch = CopyToReg t0, Register:i16 %1, t4

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(10): t4: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(9): Data Latency=1

Examining Available:
Height 0: SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38288498>, t38


*** Scheduling [0]: SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38288498>, t38


Examining Available:
Height 1: SU(1): t38: ch = JEI BasicBlock:ch< 0x16b38288020>, t21, t36:1

    t36: i16,glue = CMPI t32, TargetConstant:i16<38>


*** Scheduling [1]: SU(1): t38: ch = JEI BasicBlock:ch< 0x16b38288020>, t21, t36:1

    t36: i16,glue = CMPI t32, TargetConstant:i16<38>


Examining Available:
Height 1: SU(6): t21: ch = TokenFactor t16, t6


*** Scheduling [2]: SU(6): t21: ch = TokenFactor t16, t6


Examining Available:
Height 2: SU(7): t16: ch = TokenFactor t13, t15


*** Scheduling [3]: SU(7): t16: ch = TokenFactor t13, t15


Examining Available:
  Comparing latency of SU (9) depth 1 vs SU (8) depth 3
Height 4: SU(8): t15: ch = CopyToReg t0, Register:i16 %2, t32

Height 4: SU(9): t13: ch = CopyToReg t0, Register:i16 %1, t4

  Comparing latency of SU (9) depth 1 vs SU (8) depth 3

*** Scheduling [4]: SU(8): t15: ch = CopyToReg t0, Register:i16 %2, t32


Examining Available:
Height 4: SU(9): t13: ch = CopyToReg t0, Register:i16 %1, t4

Height 5: SU(2): t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6


*** Scheduling [5]: SU(9): t13: ch = CopyToReg t0, Register:i16 %1, t4


Examining Available:
Height 6: SU(10): t4: i16 = MOVI TargetConstant:i16<0>

Height 5: SU(2): t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6


*** Scheduling [6]: SU(10): t4: i16 = MOVI TargetConstant:i16<0>


Examining Available:
Height 5: SU(2): t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6


*** Scheduling [7]: SU(2): t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6


Examining Available:
Height 8: SU(3): t6: ch = STORE16R<Mem:(store (s16) into %ir.3)> t3, t2, t0


*** Scheduling [8]: SU(3): t6: ch = STORE16R<Mem:(store (s16) into %ir.3)> t3, t2, t0


Examining Available:
Height 9: SU(5): t3: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 9: SU(4): t2: i16,ch = CopyFromReg t0, Register:i16 %0


*** Scheduling [9]: SU(5): t3: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 9: SU(4): t2: i16,ch = CopyFromReg t0, Register:i16 %0


*** Scheduling [10]: SU(4): t2: i16,ch = CopyFromReg t0, Register:i16 %0

*** Final schedule ***
SU(4): t2: i16,ch = CopyFromReg t0, Register:i16 %0

SU(5): t3: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(3): t6: ch = STORE16R<Mem:(store (s16) into %ir.3)> t3, t2, t0

SU(2): t32: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.3)> t3, t6

SU(10): t4: i16 = MOVI TargetConstant:i16<0>

SU(9): t13: ch = CopyToReg t0, Register:i16 %1, t4

SU(8): t15: ch = CopyToReg t0, Register:i16 %2, t32

SU(7): t16: ch = TokenFactor t13, t15

SU(6): t21: ch = TokenFactor t16, t6

SU(1): t38: ch = JEI BasicBlock:ch< 0x16b38288020>, t21, t36:1

    t36: i16,glue = CMPI t32, TargetConstant:i16<38>

SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38288498>, t38


Total amount of phi nodes to update: 0
Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<43>
Creating new node: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>

Initial selection DAG: %bb.4 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>

Combining: t11: ch = BasicBlock< 0x16b382885e0>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<43>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.4 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>



Legalizing node: t11: ch = BasicBlock< 0x16b382885e0>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b382885e0>

Legalizing node: t9: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38288020>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<43>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<43>
Creating constant: t13: i16 = Constant<43>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<43>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<43>

Legalizing node: t3: i16 = Register %2
Ignoring node results
Legally typed node: t3: i16 = Register %2

Legalizing node: t1: i16 = Register %1
Ignoring node results
Legally typed node: t1: i16 = Register %1

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<43>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<43>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<43>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<43>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<43>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<43>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal operand
Analyzing operand: t13: i16 = Constant<43>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<43>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<43>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b382885e0>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.4 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<43>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<43>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<43>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b382885e0>

Combining: t11: ch = BasicBlock< 0x16b382885e0>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b382885e0>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.4 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t17: i16 = xor t4, Constant:i16<43>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t19, BasicBlock:ch< 0x16b382885e0>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b382885e0>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<43>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<43>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b382885e0>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.4 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<43>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b382885e0>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b382885e0>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b382885e0>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<43>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<43>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<43>
Legal node: nothing to do

Combining: t13: i16 = Constant<43>

Legalizing: t11: ch = BasicBlock< 0x16b382885e0>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b382885e0>

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38288020>

Legalizing: t3: i16 = Register %2

Combining: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Combining: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.4 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<43>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b382885e0>


===== Instruction selection begins: %bb.4 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b382885e0>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b382885e0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b382885e0>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<43>
Selecting: t17: i16 = xor t4, Constant:i16<43>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<43>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<43>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b382885e0>
Selecting: t11: ch = BasicBlock< 0x16b382885e0>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38288020>
Selecting: t9: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t3: i16 = Register %2
Selecting: t3: i16 = Register %2


ISEL: Starting selection on root node: t1: i16 = Register %1
Selecting: t1: i16 = Register %1


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.4 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = XORI t4, TargetConstant:i16<43>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b382885e0>, t22


********** List Scheduling %bb.4 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382885e0>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<43>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382885e0>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382885e0>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<43>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<43>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

SU(4): t17: i16 = XORI t4, TargetConstant:i16<43>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382885e0>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<45>
Creating new node: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38288728>

Initial selection DAG: %bb.5 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288728>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288728>

Combining: t11: ch = BasicBlock< 0x16b38288728>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<45>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.5 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288728>



Legalizing node: t11: ch = BasicBlock< 0x16b38288728>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38288728>

Legalizing node: t9: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38288020>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<45>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<45>
Creating constant: t13: i16 = Constant<45>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<45>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<45>

Legalizing node: t3: i16 = Register %2
Ignoring node results
Legally typed node: t3: i16 = Register %2

Legalizing node: t1: i16 = Register %1
Ignoring node results
Legally typed node: t1: i16 = Register %1

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<45>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<45>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<45>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<45>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<45>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<45>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal operand
Analyzing operand: t13: i16 = Constant<45>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<45>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<45>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38288728>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38288728>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38288728>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38288728>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.5 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<45>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288728>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<45>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<45>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288728>

Combining: t11: ch = BasicBlock< 0x16b38288728>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38288728>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.5 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t17: i16 = xor t4, Constant:i16<45>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t19, BasicBlock:ch< 0x16b38288728>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38288728>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<45>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<45>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38288728>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.5 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<45>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288728>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38288728>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38288728>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<45>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<45>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<45>
Legal node: nothing to do

Combining: t13: i16 = Constant<45>

Legalizing: t11: ch = BasicBlock< 0x16b38288728>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38288728>

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38288020>

Legalizing: t3: i16 = Register %2

Combining: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Combining: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.5 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<45>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288728>


===== Instruction selection begins: %bb.5 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38288728>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38288728>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38288728>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<45>
Selecting: t17: i16 = xor t4, Constant:i16<45>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<45>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<45>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38288728>
Selecting: t11: ch = BasicBlock< 0x16b38288728>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38288020>
Selecting: t9: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t3: i16 = Register %2
Selecting: t3: i16 = Register %2


ISEL: Starting selection on root node: t1: i16 = Register %1
Selecting: t1: i16 = Register %1


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.5 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = XORI t4, TargetConstant:i16<45>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38288728>, t22


********** List Scheduling %bb.5 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288728>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<45>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288728>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288728>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<45>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<45>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

SU(4): t17: i16 = XORI t4, TargetConstant:i16<45>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288728>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<60>
Creating new node: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>

Initial selection DAG: %bb.6 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>

Combining: t11: ch = BasicBlock< 0x16b38288ac0>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<60>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.6 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>



Legalizing node: t11: ch = BasicBlock< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38288ac0>

Legalizing node: t9: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38288020>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<60>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<60>
Creating constant: t13: i16 = Constant<60>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<60>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<60>

Legalizing node: t3: i16 = Register %2
Ignoring node results
Legally typed node: t3: i16 = Register %2

Legalizing node: t1: i16 = Register %1
Ignoring node results
Legally typed node: t1: i16 = Register %1

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<60>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<60>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<60>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<60>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<60>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<60>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal operand
Analyzing operand: t13: i16 = Constant<60>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<60>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<60>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38288ac0>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.6 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<60>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<60>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<60>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288ac0>

Combining: t11: ch = BasicBlock< 0x16b38288ac0>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38288ac0>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.6 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t17: i16 = xor t4, Constant:i16<60>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t19, BasicBlock:ch< 0x16b38288ac0>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38288ac0>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<60>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<60>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38288ac0>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.6 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<60>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288ac0>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38288ac0>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38288ac0>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<60>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<60>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<60>
Legal node: nothing to do

Combining: t13: i16 = Constant<60>

Legalizing: t11: ch = BasicBlock< 0x16b38288ac0>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38288ac0>

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38288020>

Legalizing: t3: i16 = Register %2

Combining: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Combining: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.6 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<60>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288ac0>


===== Instruction selection begins: %bb.6 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38288ac0>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38288ac0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<60>
Selecting: t17: i16 = xor t4, Constant:i16<60>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<60>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<60>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38288ac0>
Selecting: t11: ch = BasicBlock< 0x16b38288ac0>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38288020>
Selecting: t9: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t3: i16 = Register %2
Selecting: t3: i16 = Register %2


ISEL: Starting selection on root node: t1: i16 = Register %1
Selecting: t1: i16 = Register %1


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.6 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = XORI t4, TargetConstant:i16<60>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t22


********** List Scheduling %bb.6 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<60>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<60>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<60>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

SU(4): t17: i16 = XORI t4, TargetConstant:i16<60>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<62>
Creating new node: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>

Initial selection DAG: %bb.7 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>

Combining: t11: ch = BasicBlock< 0x16b38288c08>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<62>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.7 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>



Legalizing node: t11: ch = BasicBlock< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38288c08>

Legalizing node: t9: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38288020>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<62>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<62>
Creating constant: t13: i16 = Constant<62>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<62>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<62>

Legalizing node: t3: i16 = Register %2
Ignoring node results
Legally typed node: t3: i16 = Register %2

Legalizing node: t1: i16 = Register %1
Ignoring node results
Legally typed node: t1: i16 = Register %1

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<62>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<62>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<62>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<62>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<62>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<62>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal operand
Analyzing operand: t13: i16 = Constant<62>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<62>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<62>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38288c08>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.7 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<62>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<62>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<62>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288c08>

Combining: t11: ch = BasicBlock< 0x16b38288c08>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38288c08>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.7 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t17: i16 = xor t4, Constant:i16<62>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t19, BasicBlock:ch< 0x16b38288c08>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38288c08>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<62>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<62>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38288c08>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.7 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<62>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288c08>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38288c08>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38288c08>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<62>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<62>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<62>
Legal node: nothing to do

Combining: t13: i16 = Constant<62>

Legalizing: t11: ch = BasicBlock< 0x16b38288c08>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38288c08>

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38288020>

Legalizing: t3: i16 = Register %2

Combining: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Combining: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.7 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<62>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288c08>


===== Instruction selection begins: %bb.7 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38288c08>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38288c08>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<62>
Selecting: t17: i16 = xor t4, Constant:i16<62>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<62>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<62>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38288c08>
Selecting: t11: ch = BasicBlock< 0x16b38288c08>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38288020>
Selecting: t9: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t3: i16 = Register %2
Selecting: t3: i16 = Register %2


ISEL: Starting selection on root node: t1: i16 = Register %1
Selecting: t1: i16 = Register %1


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.7 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = XORI t4, TargetConstant:i16<62>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t22


********** List Scheduling %bb.7 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<62>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<62>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<62>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

SU(4): t17: i16 = XORI t4, TargetConstant:i16<62>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<94>
Creating new node: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>

Initial selection DAG: %bb.8 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>

Combining: t11: ch = BasicBlock< 0x16b38288d50>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<94>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.8 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>



Legalizing node: t11: ch = BasicBlock< 0x16b38288d50>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38288d50>

Legalizing node: t9: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38288020>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<94>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<94>
Creating constant: t13: i16 = Constant<94>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<94>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<94>

Legalizing node: t3: i16 = Register %2
Ignoring node results
Legally typed node: t3: i16 = Register %2

Legalizing node: t1: i16 = Register %1
Ignoring node results
Legally typed node: t1: i16 = Register %1

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<94>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38288020>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<94>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<94>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<94>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<94>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<94>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal operand
Analyzing operand: t13: i16 = Constant<94>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<94>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<94>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38288d50>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.8 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<94>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<94>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<94>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38288d50>

Combining: t11: ch = BasicBlock< 0x16b38288d50>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288020>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38288d50>

Combining: t9: ch = BasicBlock< 0x16b38288020>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.8 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t17: i16 = xor t4, Constant:i16<94>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
  t12: ch = br t19, BasicBlock:ch< 0x16b38288d50>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38288d50>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38288020>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<94>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<94>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38288d50>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.8 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<94>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288d50>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38288d50>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38288d50>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<94>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<94>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<94>
Legal node: nothing to do

Combining: t13: i16 = Constant<94>

Legalizing: t11: ch = BasicBlock< 0x16b38288d50>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38288d50>

Legalizing: t9: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38288020>

Legalizing: t3: i16 = Register %2

Combining: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Combining: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.8 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = xor t4, Constant:i16<94>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38288d50>


===== Instruction selection begins: %bb.8 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38288d50>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38288d50>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288020>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<94>
Selecting: t17: i16 = xor t4, Constant:i16<94>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<94>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<94>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38288d50>
Selecting: t11: ch = BasicBlock< 0x16b38288d50>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38288020>
Selecting: t9: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t3: i16 = Register %2
Selecting: t3: i16 = Register %2


ISEL: Starting selection on root node: t1: i16 = Register %1
Selecting: t1: i16 = Register %1


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.8 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t17: i16 = XORI t4, TargetConstant:i16<94>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t22


********** List Scheduling %bb.8 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<94>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<94>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<94>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

SU(4): t17: i16 = XORI t4, TargetConstant:i16<94>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38288020>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<124>
Creating new node: t8: i1 = setcc t5, Constant:i32<124>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38288168>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38288020>

Initial selection DAG: %bb.9 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t5: i32 = build_pair t4, t2
        t8: i1 = setcc t5, Constant:i32<124>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38288168>
  t14: ch = br t12, BasicBlock:ch< 0x16b38288020>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38288020>

Combining: t13: ch = BasicBlock< 0x16b38288020>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38288168>
Creating new node: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38288168>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38288168>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38288168>

Combining: t16: i1 = setcc t5, Constant:i32<124>, setne:ch

Combining: t15: ch = setne

Combining: t14: ch = br t17, BasicBlock:ch< 0x16b38288020>

Combining: t11: ch = BasicBlock< 0x16b38288168>

Combining: t6: i32 = Constant<124>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.9 'is_op:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t5: i32 = build_pair t4, t2
      t16: i1 = setcc t5, Constant:i32<124>, setne:ch
    t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38288168>
  t14: ch = br t17, BasicBlock:ch< 0x16b38288020>



Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b38288020>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38288020>

Legalizing node: t11: ch = BasicBlock< 0x16b38288168>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38288168>

Legalizing node: t6: i32 = Constant<124>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<124>
Creating constant: t18: i16 = Constant<124>
Creating constant: t19: i16 = Constant<0>

Legalizing node: t19: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t19: i16 = Constant<0>

Legalizing node: t18: i16 = Constant<124>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<124>

Legalizing node: t3: i16 = Register %2
Ignoring node results
Legally typed node: t3: i16 = Register %2

Legalizing node: t1: i16 = Register %1
Ignoring node results
Legally typed node: t1: i16 = Register %1

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Analyzing result type: i1
Promote integer result: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Creating new node: t20: i16 = setcc t5, Constant:i32<124>, setne:ch

Legalizing node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38288168>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Promote integer operand: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38288168>
Creating new node: t21: i16 = any_extend t16

Legalizing node: t21: i16 = any_extend t16
Analyzing result type: i16
Legal result type
Analyzing operand: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Promote integer operand: t21: i16 = any_extend t16
Replacing: t21: i16 = any_extend t16
     with: t20: i16 = setcc t5, Constant:i32<124>, setne:ch

Legalizing node: t20: i16 = setcc t5, Constant:i32<124>, setne:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t20: i16 = setcc t5, Constant:i32<124>, setne:ch
Creating new node: t22: i16 = xor t4, Constant:i16<124>
Creating new node: t23: i16 = or t22, t2

Legalizing node: t22: i16 = xor t4, Constant:i16<124>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal operand
Analyzing operand: t18: i16 = Constant<124>
Legal operand
Legally typed node: t22: i16 = xor t4, Constant:i16<124>

Legalizing node: t23: i16 = or t22, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t22: i16 = xor t4, Constant:i16<124>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t23: i16 = or t22, t2

Legalizing node: t20: i16 = setcc t23, Constant:i16<0>, setne:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t23: i16 = or t22, t2
Legal operand
Analyzing operand: t19: i16 = Constant<0>
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Legally typed node: t20: i16 = setcc t23, Constant:i16<0>, setne:ch

Legalizing node: t17: ch = brcond t0, t20, BasicBlock:ch< 0x16b38288168>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t20: i16 = setcc t23, Constant:i16<0>, setne:ch
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38288168>
Legal operand
Legally typed node: t17: ch = brcond t0, t20, BasicBlock:ch< 0x16b38288168>

Legalizing node: t14: ch = br t17, BasicBlock:ch< 0x16b38288020>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = brcond t0, t20, BasicBlock:ch< 0x16b38288168>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38288020>
Legal operand
Legally typed node: t14: ch = br t17, BasicBlock:ch< 0x16b38288020>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t17, BasicBlock:ch< 0x16b38288020>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.9 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t22: i16 = xor t4, Constant:i16<124>
        t23: i16 = or t22, t2
      t20: i16 = setcc t23, Constant:i16<0>, setne:ch
    t17: ch = brcond t0, t20, BasicBlock:ch< 0x16b38288168>
  t14: ch = br t17, BasicBlock:ch< 0x16b38288020>



Combining: t23: i16 = or t22, t2

Combining: t22: i16 = xor t4, Constant:i16<124>

Combining: t20: i16 = setcc t23, Constant:i16<0>, setne:ch

Combining: t19: i16 = Constant<0>

Combining: t18: i16 = Constant<124>

Combining: t17: ch = brcond t0, t20, BasicBlock:ch< 0x16b38288168>
Creating new node: t24: ch = br_cc t0, setne:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288168>
 ... into: t24: ch = br_cc t0, setne:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288168>

Combining: t23: i16 = or t22, t2

Combining: t19: i16 = Constant<0>

Combining: t24: ch = br_cc t0, setne:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288168>

Combining: t15: ch = setne

Combining: t14: ch = br t24, BasicBlock:ch< 0x16b38288020>

Combining: t13: ch = BasicBlock< 0x16b38288020>

Combining: t11: ch = BasicBlock< 0x16b38288168>

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Combining: t3: i16 = Register %2

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t1: i16 = Register %1

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.9 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
        t22: i16 = xor t4, Constant:i16<124>
      t23: i16 = or t22, t2
    t24: ch = br_cc t0, setne:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288168>
  t14: ch = br t24, BasicBlock:ch< 0x16b38288020>



Legalizing: t14: ch = br t24, BasicBlock:ch< 0x16b38288020>
Legal node: nothing to do

Legalizing: t24: ch = br_cc t0, setne:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288168>
Trying custom legalization
Creating new node: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Creating constant: t26: i16 = Constant<9>
Creating new node: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25
Successfully custom legalized node
 ... replacing: t24: ch = br_cc t0, setne:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288168>
     with:      t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25

Legalizing: t23: i16 = or t22, t2
Legal node: nothing to do

Legalizing: t22: i16 = xor t4, Constant:i16<124>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t19: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t18: i16 = Constant<124>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38288168>
Legal node: nothing to do

Legalizing: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25
Legal node: nothing to do

Legalizing: t26: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.9 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t22: i16 = xor t4, Constant:i16<124>
        t23: i16 = or t22, t2
      t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
    t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25
  t14: ch = br t27, BasicBlock:ch< 0x16b38288020>



Legalizing: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25
Legal node: nothing to do

Combining: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25

Legalizing: t26: i16 = Constant<9>
Legal node: nothing to do

Combining: t26: i16 = Constant<9>

Legalizing: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Legal node: nothing to do

Combining: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>

Legalizing: t14: ch = br t27, BasicBlock:ch< 0x16b38288020>
Legal node: nothing to do

Combining: t14: ch = br t27, BasicBlock:ch< 0x16b38288020>

Legalizing: t23: i16 = or t22, t2
Legal node: nothing to do

Combining: t23: i16 = or t22, t2

Legalizing: t22: i16 = xor t4, Constant:i16<124>
Legal node: nothing to do

Combining: t22: i16 = xor t4, Constant:i16<124>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t19: i16 = Constant<0>
Legal node: nothing to do

Combining: t19: i16 = Constant<0>

Legalizing: t18: i16 = Constant<124>
Legal node: nothing to do

Combining: t18: i16 = Constant<124>

Legalizing: t13: ch = BasicBlock< 0x16b38288020>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38288020>

Legalizing: t11: ch = BasicBlock< 0x16b38288168>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38288168>

Legalizing: t3: i16 = Register %2

Combining: t3: i16 = Register %2

Legalizing: t1: i16 = Register %1

Combining: t1: i16 = Register %1

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.9 'is_op:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t22: i16 = xor t4, Constant:i16<124>
        t23: i16 = or t22, t2
      t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
    t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25
  t14: ch = br t27, BasicBlock:ch< 0x16b38288020>


===== Instruction selection begins: %bb.9 ''

ISEL: Starting selection on root node: t14: ch = br t27, BasicBlock:ch< 0x16b38288020>
Selecting: t14: ch = br t27, BasicBlock:ch< 0x16b38288020>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38288020>, t27
ISEL: Match complete!

ISEL: Starting selection on root node: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25
Selecting: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288168>, Constant:i16<9>, t25

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t27: ch = JNEI BasicBlock:ch< 0x16b38288168>, t0, t25
ISEL: Match complete!

ISEL: Starting selection on root node: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Selecting: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t28: i16 = TargetConstant<0>
  Morphed node: t25: i16,glue = CMPI t23, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i16 = or t22, t2
Selecting: t23: i16 = or t22, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t23: i16 = ORR t22, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i16 = xor t4, Constant:i16<124>
Selecting: t22: i16 = xor t4, Constant:i16<124>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t29: i16 = TargetConstant<124>
  Morphed node: t22: i16 = XORI t4, TargetConstant:i16<124>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38288020>
Selecting: t13: ch = BasicBlock< 0x16b38288020>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38288168>
Selecting: t11: ch = BasicBlock< 0x16b38288168>


ISEL: Starting selection on root node: t3: i16 = Register %2
Selecting: t3: i16 = Register %2


ISEL: Starting selection on root node: t1: i16 = Register %1
Selecting: t1: i16 = Register %1


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.9 'is_op:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %1
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %2
          t22: i16 = XORI t4, TargetConstant:i16<124>
        t23: i16 = ORR t22, t2
      t25: i16,glue = CMPI t23, TargetConstant:i16<0>
    t27: ch = JNEI BasicBlock:ch< 0x16b38288168>, t0, t25:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38288020>, t27


********** List Scheduling %bb.9 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38288020>, t27

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t27: ch = JNEI BasicBlock:ch< 0x16b38288168>, t0, t25:1

    t25: i16,glue = CMPI t23, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t23: i16 = ORR t22, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t22: i16 = XORI t4, TargetConstant:i16<124>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38288020>, t27


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38288020>, t27


Examining Available:
Height 1: SU(1): t27: ch = JNEI BasicBlock:ch< 0x16b38288168>, t0, t25:1

    t25: i16,glue = CMPI t23, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t27: ch = JNEI BasicBlock:ch< 0x16b38288168>, t0, t25:1

    t25: i16,glue = CMPI t23, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t23: i16 = ORR t22, t2


*** Scheduling [2]: SU(2): t23: i16 = ORR t22, t2


Examining Available:
Height 3: SU(4): t22: i16 = XORI t4, TargetConstant:i16<124>


*** Scheduling [3]: SU(4): t22: i16 = XORI t4, TargetConstant:i16<124>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %1

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %2

SU(4): t22: i16 = XORI t4, TargetConstant:i16<124>

SU(2): t23: i16 = ORR t22, t2

SU(1): t27: ch = JNEI BasicBlock:ch< 0x16b38288168>, t0, t25:1

    t25: i16,glue = CMPI t23, TargetConstant:i16<0>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38288020>, t27


Creating constant: t1: i8 = Constant<1>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>

Initial selection DAG: %bb.1 'is_op:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>

Combining: t6: ch = BasicBlock< 0x16b382882b0>

Combining: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<0>

Combining: t1: i8 = Constant<1>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.1 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>



Legalizing node: t6: ch = BasicBlock< 0x16b382882b0>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b382882b0>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<0>

Legalizing node: t1: i8 = Constant<1>
Analyzing result type: i8
Promote integer result: t1: i8 = Constant<1>
Creating constant: t8: i16 = Constant<1>

Legalizing node: t8: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i8 = Constant<1>
Promote integer operand: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16
Creating new node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
Replacing: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<1>, FrameIndex:i16<0>, undef:i16
     with: t9: ch = store<(store (s8) into %ir.<badref>), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16

Legalizing node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<1>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16

Legalizing node: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b382882b0>
Legal operand
Legally typed node: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.1 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>



Combining: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16

Combining: t8: i16 = Constant<1>

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

Combining: t6: ch = BasicBlock< 0x16b382882b0>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.1 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Legal node: nothing to do

Legalizing: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
Legalizing truncating store operations

Legalizing: t8: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b382882b0>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.1 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Legal node: nothing to do

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

Legalizing: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
Legalizing truncating store operations

Combining: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16

Legalizing: t8: i16 = Constant<1>
Legal node: nothing to do

Combining: t8: i16 = Constant<1>

Legalizing: t6: ch = BasicBlock< 0x16b382882b0>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b382882b0>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.1 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>


===== Instruction selection begins: %bb.1 ''

ISEL: Starting selection on root node: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Selecting: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16
Selecting: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> FrameIndex:i16<0>, Constant:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<1>
Selecting: t8: i16 = Constant<1>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t10: i16 = TargetConstant<1>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b382882b0>
Selecting: t6: ch = BasicBlock< 0x16b382882b0>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<0>
Selecting: t2: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t12: i16 = TargetConstant<0>
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.1 'is_op:'
SelectionDAG has 9 nodes:
      t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t8: i16 = MOVI TargetConstant:i16<1>
      t0: ch,glue = EntryToken
    t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0
  t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


********** List Scheduling %bb.1 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t8: i16 = MOVI TargetConstant:i16<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


Examining Available:
Height 1: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0


*** Scheduling [1]: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0


Examining Available:
Height 2: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<1>


*** Scheduling [2]: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<1>


*** Scheduling [3]: SU(2): t8: i16 = MOVI TargetConstant:i16<1>

*** Final schedule ***
SU(2): t8: i16 = MOVI TargetConstant:i16<1>

SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


Total amount of phi nodes to update: 0
Creating constant: t1: i8 = Constant<0>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>

Initial selection DAG: %bb.2 'is_op:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>

Combining: t6: ch = BasicBlock< 0x16b382882b0>

Combining: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<0>

Combining: t1: i8 = Constant<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.2 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b382882b0>



Legalizing node: t6: ch = BasicBlock< 0x16b382882b0>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b382882b0>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<0>

Legalizing node: t1: i8 = Constant<0>
Analyzing result type: i8
Promote integer result: t1: i8 = Constant<0>
Creating constant: t8: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i8 = Constant<0>
Promote integer operand: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16
Creating new node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Replacing: t5: ch = store<(store (s8) into %ir.2)> t0, Constant:i8<0>, FrameIndex:i16<0>, undef:i16
     with: t9: ch = store<(store (s8) into %ir.<badref>), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing node: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b382882b0>
Legal operand
Legally typed node: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.2 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>



Combining: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Combining: t8: i16 = Constant<0>

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

Combining: t6: ch = BasicBlock< 0x16b382882b0>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.2 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Legal node: nothing to do

Legalizing: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legalizing truncating store operations

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b382882b0>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.2 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Legal node: nothing to do

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

Legalizing: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legalizing truncating store operations

Combining: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Combining: t8: i16 = Constant<0>

Legalizing: t6: ch = BasicBlock< 0x16b382882b0>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b382882b0>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.2 'is_op:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>


===== Instruction selection begins: %bb.2 ''

ISEL: Starting selection on root node: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>
Selecting: t7: ch = br t9, BasicBlock:ch< 0x16b382882b0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Selecting: t9: ch = store<(store (s8) into %ir.2), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> FrameIndex:i16<0>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<0>
Selecting: t8: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t10: i16 = TargetConstant<0>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b382882b0>
Selecting: t6: ch = BasicBlock< 0x16b382882b0>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<0>
Selecting: t2: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.2 'is_op:'
SelectionDAG has 8 nodes:
      t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t8: i16 = MOVI TargetConstant:i16<0>
      t0: ch,glue = EntryToken
    t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0
  t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


********** List Scheduling %bb.2 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t8: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


Examining Available:
Height 1: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0


*** Scheduling [1]: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0


Examining Available:
Height 2: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [2]: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [3]: SU(2): t8: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(2): t8: i16 = MOVI TargetConstant:i16<0>

SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.2)> t2, t8, t0

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b382882b0>, t9


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i8,ch = load<(dereferenceable load (s8) from %ir.2)> t0, FrameIndex:i16<0>, undef:i16
Creating new node: t5: i16 = sign_extend t4
Creating new node: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t5
Creating new node: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1

Initial selection DAG: %bb.3 'is_op:'
SelectionDAG has 9 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
      t4: i8,ch = load<(dereferenceable load (s8) from %ir.2)> t0, FrameIndex:i16<0>, undef:i16
    t5: i16 = sign_extend t4
  t7: ch,glue = CopyToReg t0, Register:i16 $r1, t5
  t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1



Combining: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1

Combining: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t5

Combining: t6: i16 = Register $r1

Combining: t5: i16 = sign_extend t4
Creating new node: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16

Replacing.1 t5: i16 = sign_extend t4

With: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16
 and 0 other values

Combining: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16

Combining: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.3 'is_op:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16
  t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9
  t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1



Legalizing node: t6: i16 = Register $r1
Ignoring node results
Legally typed node: t6: i16 = Register $r1

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16

Legalizing node: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16
Legal operand
Legally typed node: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9

Legalizing node: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9
Legal operand
Analyzing operand: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9
Legal operand
Legally typed node: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1

Legalizing node: t65535: ch = handlenode t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1
Legal operand
Legally typed node: t65535: ch = handlenode t8

Type-legalized selection DAG: %bb.3 'is_op:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16
  t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9
  t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1



Legalizing: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1
Legal node: nothing to do

Legalizing: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t9
Legal node: nothing to do

Legalizing: t9: i16,ch = load<(dereferenceable load (s8) from %ir.2), sext from i8> t0, FrameIndex:i16<0>, undef:i16
Legalizing extending load operation
Creating new node: t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16
Creating new node: t12: i16 = sign_extend_inreg t10, ValueType:ch:i8

Legalizing: t6: i16 = Register $r1

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t12: i16 = sign_extend_inreg t10, ValueType:ch:i8
Trying to expand node
Creating constant: t13: i16 = Constant<8>
Creating new node: t14: i16 = shl t10, Constant:i16<8>
Creating new node: t15: i16 = sra t14, Constant:i16<8>
Successfully expanded node
 ... replacing: t12: i16 = sign_extend_inreg t10, ValueType:ch:i8
     with:      t15: i16 = sra t14, Constant:i16<8>

Legalizing: t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16
Legalizing extending load operation

Legalizing: t15: i16 = sra t14, Constant:i16<8>
Legal node: nothing to do

Legalizing: t14: i16 = shl t10, Constant:i16<8>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<8>
Legal node: nothing to do

Legalized selection DAG: %bb.3 'is_op:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
        t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16
      t14: i16 = shl t10, Constant:i16<8>
    t15: i16 = sra t14, Constant:i16<8>
  t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15
  t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1



Legalizing: t15: i16 = sra t14, Constant:i16<8>
Legal node: nothing to do

Combining: t15: i16 = sra t14, Constant:i16<8>

Legalizing: t14: i16 = shl t10, Constant:i16<8>
Legal node: nothing to do

Combining: t14: i16 = shl t10, Constant:i16<8>

Legalizing: t13: i16 = Constant<8>
Legal node: nothing to do

Combining: t13: i16 = Constant<8>

Legalizing: t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16
Legalizing extending load operation

Combining: t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16

Legalizing: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1
Legal node: nothing to do

Combining: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1

Legalizing: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15
Legal node: nothing to do

Combining: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15

Legalizing: t6: i16 = Register $r1

Combining: t6: i16 = Register $r1

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.3 'is_op:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
        t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16
      t14: i16 = shl t10, Constant:i16<8>
    t15: i16 = sra t14, Constant:i16<8>
  t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15
  t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1


===== Instruction selection begins: %bb.3 ''

ISEL: Starting selection on root node: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1
Selecting: t8: ch = SymphonyISD::RET_GLUE t7, Register:i16 $r1, t7:1

ISEL: Starting pattern match
  Initial Opcode index to 902
  Morphed node: t8: i16,ch = SymphonyRet Register:i16 $r1, t7, t7:1
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15
Selecting: t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15


ISEL: Starting selection on root node: t15: i16 = sra t14, Constant:i16<8>
Selecting: t15: i16 = sra t14, Constant:i16<8>

ISEL: Starting pattern match
  Initial Opcode index to 766
Creating constant: t16: i16 = TargetConstant<8>
  Morphed node: t15: i16 = ASRI t14, TargetConstant:i16<8>
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = shl t10, Constant:i16<8>
Selecting: t14: i16 = shl t10, Constant:i16<8>

ISEL: Starting pattern match
  Initial Opcode index to 646
  Morphed node: t14: i16 = LSLI t10, TargetConstant:i16<8>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16
Selecting: t10: i16,ch = load<(dereferenceable load (s8) from %ir.2), anyext from i8> t0, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Morphed node: t10: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.2)> FrameIndex:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = Register $r1
Selecting: t6: i16 = Register $r1


ISEL: Starting selection on root node: t1: i16 = FrameIndex<0>
Selecting: t1: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t18: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.3 'is_op:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
        t10: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.2)> t1, t0
      t14: i16 = LSLI t10, TargetConstant:i16<8>
    t15: i16 = ASRI t14, TargetConstant:i16<8>
  t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15
  t8: i16,ch = SymphonyRet Register:i16 $r1, t7, t7:1


********** List Scheduling %bb.3 '' **********
SU(0): t8: i16,ch = SymphonyRet Register:i16 $r1, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t15: i16 = ASRI t14, TargetConstant:i16<8>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t14: i16 = LSLI t10, TargetConstant:i16<8>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t10: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.2)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t8: i16,ch = SymphonyRet Register:i16 $r1, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15


*** Scheduling [0]: SU(0): t8: i16,ch = SymphonyRet Register:i16 $r1, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15


Examining Available:
Height 1: SU(1): t15: i16 = ASRI t14, TargetConstant:i16<8>


*** Scheduling [1]: SU(1): t15: i16 = ASRI t14, TargetConstant:i16<8>


Examining Available:
Height 2: SU(2): t14: i16 = LSLI t10, TargetConstant:i16<8>


*** Scheduling [2]: SU(2): t14: i16 = LSLI t10, TargetConstant:i16<8>


Examining Available:
Height 3: SU(3): t10: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.2)> t1, t0


*** Scheduling [3]: SU(3): t10: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.2)> t1, t0


Examining Available:
Height 4: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


*** Scheduling [4]: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

*** Final schedule ***
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(3): t10: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.2)> t1, t0

SU(2): t14: i16 = LSLI t10, TargetConstant:i16<8>

SU(1): t15: i16 = ASRI t14, TargetConstant:i16<8>

SU(0): t8: i16,ch = SymphonyRet Register:i16 $r1, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i16 $r1, t15


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function is_op: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=1, align=1, at location [SP]
  fi#1: size=2, align=2, at location [SP]
Function Live Ins: $r1 in %0

bb.0 (%ir-block.1):
  successors: %bb.1, %bb.4
  liveins: $r1
  %0:gpr = COPY $r1
  %3:gpr = ADDI %stack.1, 0
  STORE16R %3:gpr, %0:gpr :: (store (s16) into %ir.3)
  %2:gpr = LOAD16R %3:gpr :: (dereferenceable load (s16) from %ir.3)
  %1:gpr = MOVI 0, implicit $flags
  CMPI %2:gpr, 38, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.4, implicit $flags

bb.4 (%ir-block.1):
; predecessors: %bb.0
  successors: %bb.1, %bb.5

  %4:gpr = XORI %2:gpr, 43
  %5:gpr = ORR killed %4:gpr, %1:gpr
  CMPI killed %5:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.5, implicit $flags

bb.5 (%ir-block.1):
; predecessors: %bb.4
  successors: %bb.1, %bb.6

  %6:gpr = XORI %2:gpr, 45
  %7:gpr = ORR killed %6:gpr, %1:gpr
  CMPI killed %7:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.6, implicit $flags

bb.6 (%ir-block.1):
; predecessors: %bb.5
  successors: %bb.1, %bb.7

  %8:gpr = XORI %2:gpr, 60
  %9:gpr = ORR killed %8:gpr, %1:gpr
  CMPI killed %9:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.7, implicit $flags

bb.7 (%ir-block.1):
; predecessors: %bb.6
  successors: %bb.1, %bb.8

  %10:gpr = XORI %2:gpr, 62
  %11:gpr = ORR killed %10:gpr, %1:gpr
  CMPI killed %11:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.8, implicit $flags

bb.8 (%ir-block.1):
; predecessors: %bb.7
  successors: %bb.1, %bb.9

  %12:gpr = XORI %2:gpr, 94
  %13:gpr = ORR killed %12:gpr, %1:gpr
  CMPI killed %13:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.9, implicit $flags

bb.9 (%ir-block.1):
; predecessors: %bb.8
  successors: %bb.1, %bb.2

  %14:gpr = XORI %2:gpr, 124
  %15:gpr = ORR killed %14:gpr, %1:gpr
  CMPI killed %15:gpr, 0, implicit-def $flags
  JNEI %bb.2, implicit $flags
  JMPI %bb.1, implicit $flags

bb.1 (%ir-block.6):
; predecessors: %bb.0, %bb.4, %bb.5, %bb.6, %bb.7, %bb.8, %bb.9
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %16:gpr = MOVI 1, implicit $flags
  %17:gpr = ADDI %stack.0, 0
  STORE8R killed %17:gpr, killed %16:gpr :: (store (s8) into %ir.2)
  JMPI %bb.3, implicit $flags

bb.2 (%ir-block.7):
; predecessors: %bb.9
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %18:gpr = MOVI 0, implicit $flags
  %19:gpr = ADDI %stack.0, 0
  STORE8R killed %19:gpr, killed %18:gpr :: (store (s8) into %ir.2)
  JMPI %bb.3, implicit $flags

bb.3 (%ir-block.8):
; predecessors: %bb.1, %bb.2

  %20:gpr = ADDI %stack.0, 0
  %21:gpr = LOAD8R killed %20:gpr :: (dereferenceable load (s8) from %ir.2)
  %22:gpr = LSLI killed %21:gpr, 8
  %23:gpr = ASRI killed %22:gpr, 8
  $r1 = COPY %23:gpr
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1

# End machine code for function is_op.

Skipping pass 'Two-Address instruction pass' on function is_op
********** REWRITING TWO-ADDR INSTRS **********
********** Function: is_op
********** FAST REGISTER ALLOCATION **********
********** Function: is_op

Allocating bb.0 (%ir-block.1):
  successors: %bb.1, %bb.4
  liveins: $r1
  %0:gpr = COPY $r1
  %3:gpr = ADDI %stack.1, 0
  STORE16R %3:gpr, %0:gpr :: (store (s16) into %ir.3)
  %2:gpr = LOAD16R %3:gpr :: (dereferenceable load (s16) from %ir.3)
  %1:gpr = MOVI 0, implicit $flags
  CMPI %2:gpr, 38, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.4, implicit $flags

>> JMPI %bb.4, implicit $flags
Regs:
<< JMPI %bb.4, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI %2:gpr, 38, implicit-def $flags
Regs:
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< CMPI $r1, 38, implicit-def $flags

>> %1:gpr = MOVI 0, implicit $flags
Regs: R1=%2[O]
Search register for %1 in class GPR with hint $noreg
	Register: $r1 Cost: 50 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 50
Assigning %1 to $r2
Spill Reason: LO: 1 RL: 0
Spilling %1 in $r2 to stack slot #2
Freeing $r2: %1
<< $r2 = MOVI 0, implicit $flags

>> %2:gpr = LOAD16R %3:gpr :: (dereferenceable load (s16) from %ir.3)
Regs: R1=%2[O]
In def of %2 use existing assignment to $r1
Spill Reason: LO: 1 RL: 0
Spilling %2 in $r1 to stack slot #3
Freeing $r1: %2
Search register for %3 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %3 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.3)

>> STORE16R %3:gpr, %0:gpr :: (store (s16) into %ir.3)
Regs: R1=%3
Search register for %0 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %0 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.3)

>> %3:gpr = ADDI %stack.1, 0
Regs: R1=%3 R2=%0
In def of %3 use existing assignment to $r1
Freeing $r1: %3
<< $r1 = ADDI %stack.1, 0

>> %0:gpr = COPY $r1
Regs: R2=%0
In def of %0 use existing assignment to $r2
Freeing $r2: %0
<< $r2 = COPY killed $r1
Begin Regs: R1[P]
Loading live registers at begin of block.
bb.0 (%ir-block.1):
  successors: %bb.1, %bb.4
  liveins: $r1
  $r2 = COPY killed $r1
  $r1 = ADDI %stack.1, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.3)
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.3)
  $r13 = frameptrget %stack.3, implicit-def $r13
  STORE16R killed $r13, $r1
  $r2 = MOVI 0, implicit $flags
  $r13 = frameptrget %stack.2, implicit-def $r13
  STORE16R killed $r13, killed $r2
  CMPI $r1, 38, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.4, implicit $flags

Allocating bb.4 (%ir-block.1):
; predecessors: %bb.0
  successors: %bb.1, %bb.5

  %4:gpr = XORI %2:gpr, 43
  %5:gpr = ORR killed %4:gpr, %1:gpr
  CMPI killed %5:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.5, implicit $flags

>> JMPI %bb.5, implicit $flags
Regs:
<< JMPI %bb.5, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI killed %5:gpr, 0, implicit-def $flags
Regs:
Search register for %5 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %5 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %5:gpr = ORR killed %4:gpr, %1:gpr
Regs: R1=%5
In def of %5 use existing assignment to $r1
Freeing $r1: %5
Search register for %4 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %4 to $r1
Search register for %1 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %1 to $r2
<< $r1 = ORR killed $r1, $r2

>> %4:gpr = XORI %2:gpr, 43
Regs: R1=%4 R2=%1[O]
In def of %4 use existing assignment to $r1
Freeing $r1: %4
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< $r1 = XORI $r1, 43
Begin Regs: R1=%2[O] R2=%1[O]
Loading live registers at begin of block.
Reloading %1 into $r2
Reloading %2 into $r1
bb.4 (%ir-block.1):
; predecessors: %bb.0
  successors: %bb.1, %bb.5

  $r13 = frameptrget %stack.2, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.3, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 43
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.5, implicit $flags

Allocating bb.5 (%ir-block.1):
; predecessors: %bb.4
  successors: %bb.1, %bb.6

  %6:gpr = XORI %2:gpr, 45
  %7:gpr = ORR killed %6:gpr, %1:gpr
  CMPI killed %7:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.6, implicit $flags

>> JMPI %bb.6, implicit $flags
Regs:
<< JMPI %bb.6, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI killed %7:gpr, 0, implicit-def $flags
Regs:
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %7:gpr = ORR killed %6:gpr, %1:gpr
Regs: R1=%7
In def of %7 use existing assignment to $r1
Freeing $r1: %7
Search register for %6 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %6 to $r1
Search register for %1 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %1 to $r2
<< $r1 = ORR killed $r1, $r2

>> %6:gpr = XORI %2:gpr, 45
Regs: R1=%6 R2=%1[O]
In def of %6 use existing assignment to $r1
Freeing $r1: %6
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< $r1 = XORI $r1, 45
Begin Regs: R1=%2[O] R2=%1[O]
Loading live registers at begin of block.
Reloading %1 into $r2
Reloading %2 into $r1
bb.5 (%ir-block.1):
; predecessors: %bb.4
  successors: %bb.1, %bb.6

  $r13 = frameptrget %stack.2, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.3, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 45
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.6, implicit $flags

Allocating bb.6 (%ir-block.1):
; predecessors: %bb.5
  successors: %bb.1, %bb.7

  %8:gpr = XORI %2:gpr, 60
  %9:gpr = ORR killed %8:gpr, %1:gpr
  CMPI killed %9:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.7, implicit $flags

>> JMPI %bb.7, implicit $flags
Regs:
<< JMPI %bb.7, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI killed %9:gpr, 0, implicit-def $flags
Regs:
Search register for %9 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %9 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %9:gpr = ORR killed %8:gpr, %1:gpr
Regs: R1=%9
In def of %9 use existing assignment to $r1
Freeing $r1: %9
Search register for %8 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %8 to $r1
Search register for %1 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %1 to $r2
<< $r1 = ORR killed $r1, $r2

>> %8:gpr = XORI %2:gpr, 60
Regs: R1=%8 R2=%1[O]
In def of %8 use existing assignment to $r1
Freeing $r1: %8
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< $r1 = XORI $r1, 60
Begin Regs: R1=%2[O] R2=%1[O]
Loading live registers at begin of block.
Reloading %1 into $r2
Reloading %2 into $r1
bb.6 (%ir-block.1):
; predecessors: %bb.5
  successors: %bb.1, %bb.7

  $r13 = frameptrget %stack.2, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.3, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 60
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.7, implicit $flags

Allocating bb.7 (%ir-block.1):
; predecessors: %bb.6
  successors: %bb.1, %bb.8

  %10:gpr = XORI %2:gpr, 62
  %11:gpr = ORR killed %10:gpr, %1:gpr
  CMPI killed %11:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.8, implicit $flags

>> JMPI %bb.8, implicit $flags
Regs:
<< JMPI %bb.8, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI killed %11:gpr, 0, implicit-def $flags
Regs:
Search register for %11 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %11 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %11:gpr = ORR killed %10:gpr, %1:gpr
Regs: R1=%11
In def of %11 use existing assignment to $r1
Freeing $r1: %11
Search register for %10 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %10 to $r1
Search register for %1 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %1 to $r2
<< $r1 = ORR killed $r1, $r2

>> %10:gpr = XORI %2:gpr, 62
Regs: R1=%10 R2=%1[O]
In def of %10 use existing assignment to $r1
Freeing $r1: %10
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< $r1 = XORI $r1, 62
Begin Regs: R1=%2[O] R2=%1[O]
Loading live registers at begin of block.
Reloading %1 into $r2
Reloading %2 into $r1
bb.7 (%ir-block.1):
; predecessors: %bb.6
  successors: %bb.1, %bb.8

  $r13 = frameptrget %stack.2, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.3, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 62
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.8, implicit $flags

Allocating bb.8 (%ir-block.1):
; predecessors: %bb.7
  successors: %bb.1, %bb.9

  %12:gpr = XORI %2:gpr, 94
  %13:gpr = ORR killed %12:gpr, %1:gpr
  CMPI killed %13:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI killed %13:gpr, 0, implicit-def $flags
Regs:
Search register for %13 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %13 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %13:gpr = ORR killed %12:gpr, %1:gpr
Regs: R1=%13
In def of %13 use existing assignment to $r1
Freeing $r1: %13
Search register for %12 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %12 to $r1
Search register for %1 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %1 to $r2
<< $r1 = ORR killed $r1, $r2

>> %12:gpr = XORI %2:gpr, 94
Regs: R1=%12 R2=%1[O]
In def of %12 use existing assignment to $r1
Freeing $r1: %12
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< $r1 = XORI $r1, 94
Begin Regs: R1=%2[O] R2=%1[O]
Loading live registers at begin of block.
Reloading %1 into $r2
Reloading %2 into $r1
bb.8 (%ir-block.1):
; predecessors: %bb.7
  successors: %bb.1, %bb.9

  $r13 = frameptrget %stack.2, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.3, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 94
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.9, implicit $flags

Allocating bb.9 (%ir-block.1):
; predecessors: %bb.8
  successors: %bb.1, %bb.2

  %14:gpr = XORI %2:gpr, 124
  %15:gpr = ORR killed %14:gpr, %1:gpr
  CMPI killed %15:gpr, 0, implicit-def $flags
  JNEI %bb.2, implicit $flags
  JMPI %bb.1, implicit $flags

>> JMPI %bb.1, implicit $flags
Regs:
<< JMPI %bb.1, implicit $flags

>> JNEI %bb.2, implicit $flags
Regs:
<< JNEI %bb.2, implicit $flags

>> CMPI killed %15:gpr, 0, implicit-def $flags
Regs:
Search register for %15 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %15 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %15:gpr = ORR killed %14:gpr, %1:gpr
Regs: R1=%15
In def of %15 use existing assignment to $r1
Freeing $r1: %15
Search register for %14 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %14 to $r1
Search register for %1 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %1 to $r2
<< $r1 = ORR killed $r1, $r2

>> %14:gpr = XORI %2:gpr, 124
Regs: R1=%14 R2=%1[O]
In def of %14 use existing assignment to $r1
Freeing $r1: %14
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< $r1 = XORI $r1, 124
Begin Regs: R1=%2[O] R2=%1[O]
Loading live registers at begin of block.
Reloading %1 into $r2
Reloading %2 into $r1
bb.9 (%ir-block.1):
; predecessors: %bb.8
  successors: %bb.1, %bb.2

  $r13 = frameptrget %stack.2, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.3, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 124
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JNEI %bb.2, implicit $flags
  JMPI %bb.1, implicit $flags

Allocating bb.1 (%ir-block.6):
; predecessors: %bb.0, %bb.4, %bb.5, %bb.6, %bb.7, %bb.8, %bb.9
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %16:gpr = MOVI 1, implicit $flags
  %17:gpr = ADDI %stack.0, 0
  STORE8R killed %17:gpr, killed %16:gpr :: (store (s8) into %ir.2)
  JMPI %bb.3, implicit $flags

>> JMPI %bb.3, implicit $flags
Regs:
<< JMPI %bb.3, implicit $flags

>> STORE8R killed %17:gpr, killed %16:gpr :: (store (s8) into %ir.2)
Regs:
Search register for %17 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %17 to $r1
Search register for %16 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %16 to $r2
<< STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.2)

>> %17:gpr = ADDI %stack.0, 0
Regs: R1=%17 R2=%16
In def of %17 use existing assignment to $r1
Freeing $r1: %17
<< $r1 = ADDI %stack.0, 0

>> %16:gpr = MOVI 1, implicit $flags
Regs: R2=%16
In def of %16 use existing assignment to $r2
Freeing $r2: %16
<< $r2 = MOVI 1, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.1 (%ir-block.6):
; predecessors: %bb.0, %bb.4, %bb.5, %bb.6, %bb.7, %bb.8, %bb.9
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  $r2 = MOVI 1, implicit $flags
  $r1 = ADDI %stack.0, 0
  STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.2)
  JMPI %bb.3, implicit $flags

Allocating bb.2 (%ir-block.7):
; predecessors: %bb.9
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %18:gpr = MOVI 0, implicit $flags
  %19:gpr = ADDI %stack.0, 0
  STORE8R killed %19:gpr, killed %18:gpr :: (store (s8) into %ir.2)
  JMPI %bb.3, implicit $flags

>> JMPI %bb.3, implicit $flags
Regs:
<< JMPI %bb.3, implicit $flags

>> STORE8R killed %19:gpr, killed %18:gpr :: (store (s8) into %ir.2)
Regs:
Search register for %19 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %19 to $r1
Search register for %18 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %18 to $r2
<< STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.2)

>> %19:gpr = ADDI %stack.0, 0
Regs: R1=%19 R2=%18
In def of %19 use existing assignment to $r1
Freeing $r1: %19
<< $r1 = ADDI %stack.0, 0

>> %18:gpr = MOVI 0, implicit $flags
Regs: R2=%18
In def of %18 use existing assignment to $r2
Freeing $r2: %18
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.2 (%ir-block.7):
; predecessors: %bb.9
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.0, 0
  STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.2)
  JMPI %bb.3, implicit $flags

Allocating bb.3 (%ir-block.8):
; predecessors: %bb.1, %bb.2

  %20:gpr = ADDI %stack.0, 0
  %21:gpr = LOAD8R killed %20:gpr :: (dereferenceable load (s8) from %ir.2)
  %22:gpr = LSLI killed %21:gpr, 8
  %23:gpr = ASRI killed %22:gpr, 8
  $r1 = COPY %23:gpr
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1

>> SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1
Regs:
<< SymphonyRet implicit-def dead $sp, implicit $flags, implicit killed $r1

>> $r1 = COPY %23:gpr
Regs: R1[P]
Freeing $r1:
Search register for %23 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %23 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %23:gpr = ASRI killed %22:gpr, 8
Regs: R1=%23
In def of %23 use existing assignment to $r1
Freeing $r1: %23
Search register for %22 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %22 to $r1
<< $r1 = ASRI killed $r1, 8

>> %22:gpr = LSLI killed %21:gpr, 8
Regs: R1=%22
In def of %22 use existing assignment to $r1
Freeing $r1: %22
Search register for %21 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %21 to $r1
<< $r1 = LSLI killed $r1, 8

>> %21:gpr = LOAD8R killed %20:gpr :: (dereferenceable load (s8) from %ir.2)
Regs: R1=%21
In def of %21 use existing assignment to $r1
Freeing $r1: %21
Search register for %20 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %20 to $r1
<< $r1 = LOAD8R killed $r1 :: (dereferenceable load (s8) from %ir.2)

>> %20:gpr = ADDI %stack.0, 0
Regs: R1=%20
In def of %20 use existing assignment to $r1
Freeing $r1: %20
<< $r1 = ADDI %stack.0, 0
Begin Regs:
Loading live registers at begin of block.
bb.3 (%ir-block.8):
; predecessors: %bb.1, %bb.2

  $r1 = ADDI %stack.0, 0
  $r1 = LOAD8R killed $r1 :: (dereferenceable load (s8) from %ir.2)
  $r1 = LSLI killed $r1, 8
  $r1 = ASRI killed $r1, 8
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit killed $r1
Skipping pass 'Fixup Statepoint Caller Saved' on function is_op
alloc FI(0) at SP[-1]
alloc FI(1) at SP[-4]
alloc FI(2) at SP[-6]
alloc FI(3) at SP[-8]
$r13 = frameptrget %stack.2, implicit-def $r13
$r13 = frameptrget %stack.3, implicit-def $r13
$r1 = ADDI %stack.1, 0
$r13 = frameptrget %stack.3, implicit-def $r13
$r13 = frameptrget %stack.2, implicit-def $r13
$r13 = frameptrget %stack.3, implicit-def $r13
$r13 = frameptrget %stack.2, implicit-def $r13
$r13 = frameptrget %stack.3, implicit-def $r13
$r13 = frameptrget %stack.2, implicit-def $r13
$r13 = frameptrget %stack.3, implicit-def $r13
$r13 = frameptrget %stack.2, implicit-def $r13
$r13 = frameptrget %stack.3, implicit-def $r13
$r13 = frameptrget %stack.2, implicit-def $r13
$r13 = frameptrget %stack.3, implicit-def $r13
$r13 = frameptrget %stack.2, implicit-def $r13
$r1 = ADDI %stack.0, 0
$r1 = ADDI %stack.0, 0
$r1 = ADDI %stack.0, 0
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: is_op
Skipping pass 'Remove Loads Into Fake Uses' on function is_op

Debug Range Extension: is_op
[SafeStack] Function: do_calc
[SafeStack]     safestack is not requested for this function
Skipping pass 'Symphony DAG->DAG Pattern Instruction Selection' on function do_calc
	FastISel is enabled



=== do_calc
Enabling fast-isel
Found argument copy elision candidate:   %5 = alloca i32, align 4
Found argument copy elision candidate:   %6 = alloca i16, align 2
Found argument copy elision candidate:   %7 = alloca i16, align 2
Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Creating new node: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Creating new node: t6: i16,ch = CopyFromReg t0, Register:i16 %2
Creating new node: t8: i16,ch = CopyFromReg t0, Register:i16 %3
Creating new node: t9: i32 = build_pair t4, t2
Creating constant: t10: i16 = Constant<1>
Creating constant: t11: i16 = Constant<0>
Creating new node: t13: ch = CopyToReg t0, Register:i16 %4, t2
Creating new node: t15: ch = CopyToReg t0, Register:i16 %5, t4
Creating new node: t16: ch = TokenFactor t13, t15
Creating new node: t18: i16 = undef
Creating new node: t19: ch = store<(store (s32) into %ir.5)> t0, t9, FrameIndex:i16<1>, undef:i16
Creating new node: t21: ch = store<(store (s16) into %ir.6)> t19, t6, FrameIndex:i16<2>, undef:i16
Creating new node: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Creating new node: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
Case clusters: 0 1 2 3 4 5 6 
Creating new node: t25: i16 = extract_element t24, Constant:i16<1>
Creating new node: t26: i16 = extract_element t24, Constant:i16<0>
Creating new node: t28: ch = CopyToReg t0, Register:i16 %6, t25
Creating new node: t30: ch = CopyToReg t0, Register:i16 %7, t26
Creating new node: t31: ch = TokenFactor t28, t30
Creating constant: t32: i32 = Constant<0>
Creating new node: t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
Creating new node: t36: ch = TokenFactor t16, t31, t23
Creating new node: t37: ch = brcond t36, t34, BasicBlock:ch< 0x16b38286f10>
Creating new node: t39: ch = br t37, BasicBlock:ch< 0x16b38282830>

Initial selection DAG: %bb.0 'do_calc:'
SelectionDAG has 40 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
        t9: i32 = build_pair t4, t2
      t19: ch = store<(store (s32) into %ir.5)> t0, t9, FrameIndex:i16<1>, undef:i16
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
    t21: ch = store<(store (s16) into %ir.6)> t19, t6, FrameIndex:i16<2>, undef:i16
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
  t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
  t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
            t25: i16 = extract_element t24, Constant:i16<1>
          t28: ch = CopyToReg t0, Register:i16 %6, t25
            t26: i16 = extract_element t24, Constant:i16<0>
          t30: ch = CopyToReg t0, Register:i16 %7, t26
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
      t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
    t37: ch = brcond t36, t34, BasicBlock:ch< 0x16b38286f10>
  t39: ch = br t37, BasicBlock:ch< 0x16b38282830>



Combining: t39: ch = br t37, BasicBlock:ch< 0x16b38282830>

Combining: t38: ch = BasicBlock< 0x16b38282830>

Combining: t37: ch = brcond t36, t34, BasicBlock:ch< 0x16b38286f10>

Combining: t36: ch = TokenFactor t16, t31, t23

Combining: t35: ch = BasicBlock< 0x16b38286f10>

Combining: t34: i1 = setcc t24, Constant:i32<0>, seteq:ch

Combining: t33: ch = seteq

Combining: t32: i32 = Constant<0>

Combining: t31: ch = TokenFactor t28, t30

Combining: t30: ch = CopyToReg t0, Register:i16 %7, t26

Combining: t29: i16 = Register %7

Combining: t28: ch = CopyToReg t0, Register:i16 %6, t25

Combining: t27: i16 = Register %6

Combining: t26: i16 = extract_element t24, Constant:i16<0>

Combining: t25: i16 = extract_element t24, Constant:i16<1>

Combining: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16

Combining: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16

Combining: t22: i16 = FrameIndex<3>

Combining: t21: ch = store<(store (s16) into %ir.6)> t19, t6, FrameIndex:i16<2>, undef:i16

Combining: t20: i16 = FrameIndex<2>

Combining: t19: ch = store<(store (s32) into %ir.5)> t0, t9, FrameIndex:i16<1>, undef:i16

Combining: t18: i16 = undef

Combining: t17: i16 = FrameIndex<1>

Combining: t16: ch = TokenFactor t13, t15

Combining: t15: ch = CopyToReg t0, Register:i16 %5, t4

Combining: t14: i16 = Register %5

Combining: t13: ch = CopyToReg t0, Register:i16 %4, t2

Combining: t12: i16 = Register %4

Combining: t11: i16 = Constant<0>

Combining: t10: i16 = Constant<1>

Combining: t9: i32 = build_pair t4, t2

Combining: t8: i16,ch = CopyFromReg t0, Register:i16 %3

Combining: t7: i16 = Register %3

Combining: t6: i16,ch = CopyFromReg t0, Register:i16 %2

Combining: t5: i16 = Register %2

Combining: t4: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t3: i16 = Register %1

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Combining: t1: i16 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 'do_calc:'
SelectionDAG has 40 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
        t9: i32 = build_pair t4, t2
      t19: ch = store<(store (s32) into %ir.5)> t0, t9, FrameIndex:i16<1>, undef:i16
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
    t21: ch = store<(store (s16) into %ir.6)> t19, t6, FrameIndex:i16<2>, undef:i16
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
  t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
  t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
            t25: i16 = extract_element t24, Constant:i16<1>
          t28: ch = CopyToReg t0, Register:i16 %6, t25
            t26: i16 = extract_element t24, Constant:i16<0>
          t30: ch = CopyToReg t0, Register:i16 %7, t26
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
      t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
    t37: ch = brcond t36, t34, BasicBlock:ch< 0x16b38286f10>
  t39: ch = br t37, BasicBlock:ch< 0x16b38282830>



Legalizing node: t38: ch = BasicBlock< 0x16b38282830>
Analyzing result type: ch
Legal result type
Legally typed node: t38: ch = BasicBlock< 0x16b38282830>

Legalizing node: t35: ch = BasicBlock< 0x16b38286f10>
Analyzing result type: ch
Legal result type
Legally typed node: t35: ch = BasicBlock< 0x16b38286f10>

Legalizing node: t33: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t33: ch = seteq

Legalizing node: t32: i32 = Constant<0>
Analyzing result type: i32
Expand integer result: t32: i32 = Constant<0>

Legalizing node: t29: i16 = Register %7
Ignoring node results
Legally typed node: t29: i16 = Register %7

Legalizing node: t27: i16 = Register %6
Ignoring node results
Legally typed node: t27: i16 = Register %6

Legalizing node: t22: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t22: i16 = FrameIndex<3>

Legalizing node: t20: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t20: i16 = FrameIndex<2>

Legalizing node: t18: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = undef

Legalizing node: t17: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t17: i16 = FrameIndex<1>

Legalizing node: t14: i16 = Register %5
Ignoring node results
Legally typed node: t14: i16 = Register %5

Legalizing node: t12: i16 = Register %4
Ignoring node results
Legally typed node: t12: i16 = Register %4

Legalizing node: t11: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = Constant<0>

Legalizing node: t10: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t10: i16 = Constant<1>

Legalizing node: t7: i16 = Register %3
Ignoring node results
Legally typed node: t7: i16 = Register %3

Legalizing node: t5: i16 = Register %2
Ignoring node results
Legally typed node: t5: i16 = Register %2

Legalizing node: t3: i16 = Register %1
Ignoring node results
Legally typed node: t3: i16 = Register %1

Legalizing node: t1: i16 = Register %0
Ignoring node results
Legally typed node: t1: i16 = Register %0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Legalizing node: t13: ch = CopyToReg t0, Register:i16 %4, t2
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal operand
Legally typed node: t13: ch = CopyToReg t0, Register:i16 %4, t2

Legalizing node: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing node: t9: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t9: i32 = build_pair t4, t2

Legalizing node: t19: ch = store<(store (s32) into %ir.5)> t0, t9, FrameIndex:i16<1>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i32 = build_pair t4, t2
Expand integer operand: t19: ch = store<(store (s32) into %ir.5)> t0, t9, FrameIndex:i16<1>, undef:i16
Creating new node: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
Creating constant: t41: i16 = Constant<2>
Creating new node: t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>
Creating new node: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t42, undef:i16
Creating new node: t44: ch = TokenFactor t40, t43

Legalizing node: t41: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t41: i16 = Constant<2>

Legalizing node: t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t41: i16 = Constant<2>
Legal operand
Legally typed node: t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>

Legalizing node: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t42, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Analyzing operand: t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>
Legal operand
Analyzing operand: t18: i16 = undef
Legal operand
Legally typed node: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t42, undef:i16

Legalizing node: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal operand
Analyzing operand: t17: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t18: i16 = undef
Legal operand
Legally typed node: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16

Legalizing node: t44: ch = TokenFactor t40, t43
Analyzing result type: ch
Legal result type
Analyzing operand: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t42, undef:i16
Legal operand
Legally typed node: t44: ch = TokenFactor t40, t43

Legalizing node: t15: ch = CopyToReg t0, Register:i16 %5, t4
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Legal operand
Legally typed node: t15: ch = CopyToReg t0, Register:i16 %5, t4

Legalizing node: t16: ch = TokenFactor t13, t15
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = CopyToReg t0, Register:i16 %4, t2
Legal operand
Analyzing operand: t15: ch = CopyToReg t0, Register:i16 %5, t4
Legal operand
Legally typed node: t16: ch = TokenFactor t13, t15

Legalizing node: t6: i16,ch = CopyFromReg t0, Register:i16 %2
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t6: i16,ch = CopyFromReg t0, Register:i16 %2

Legalizing node: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t44: ch = TokenFactor t40, t43
Legal operand
Analyzing operand: t6: i16,ch = CopyFromReg t0, Register:i16 %2
Legal operand
Analyzing operand: t20: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t18: i16 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16

Legalizing node: t8: i16,ch = CopyFromReg t0, Register:i16 %3
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: i16,ch = CopyFromReg t0, Register:i16 %3

Legalizing node: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t8: i16,ch = CopyFromReg t0, Register:i16 %3
Legal operand
Analyzing operand: t22: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t18: i16 = undef
Legal operand
Legally typed node: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16

Legalizing node: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
Analyzing result type: i32
Expand integer result: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
Creating new node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Creating new node: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16
Creating new node: t47: ch = TokenFactor t45:1, t46:1

Legalizing node: t25: i16 = extract_element t24, Constant:i16<1>
Analyzing result type: i16
Legal result type
Analyzing operand: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
Expand integer operand: t25: i16 = extract_element t24, Constant:i16<1>

Legalizing node: t26: i16 = extract_element t24, Constant:i16<0>
Analyzing result type: i16
Legal result type
Analyzing operand: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
Expand integer operand: t26: i16 = extract_element t24, Constant:i16<0>

Legalizing node: t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
Analyzing result type: i1
Promote integer result: t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
Creating new node: t48: i16 = setcc t24, Constant:i32<0>, seteq:ch

Legalizing node: t48: i16 = setcc t24, Constant:i32<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t24: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t23, FrameIndex:i16<1>, undef:i16
Expand integer operand: t48: i16 = setcc t24, Constant:i32<0>, seteq:ch
Creating new node: t49: i16 = or t46, t45

Legalizing node: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>
Legal operand
Analyzing operand: t18: i16 = undef
Legal operand
Legally typed node: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16

Legalizing node: t30: ch = CopyToReg t0, Register:i16 %7, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16
Legal operand
Legally typed node: t30: ch = CopyToReg t0, Register:i16 %7, t46

Legalizing node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t17: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t18: i16 = undef
Legal operand
Legally typed node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16

Legalizing node: t47: ch = TokenFactor t45:1, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16
Legal operand
Legally typed node: t47: ch = TokenFactor t45:1, t46:1

Legalizing node: t28: ch = CopyToReg t0, Register:i16 %6, t45
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t28: ch = CopyToReg t0, Register:i16 %6, t45

Legalizing node: t31: ch = TokenFactor t28, t30
Analyzing result type: ch
Legal result type
Analyzing operand: t28: ch = CopyToReg t0, Register:i16 %6, t45
Legal operand
Analyzing operand: t30: ch = CopyToReg t0, Register:i16 %7, t46
Legal operand
Legally typed node: t31: ch = TokenFactor t28, t30

Legalizing node: t36: ch = TokenFactor t16, t31, t23
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = TokenFactor t13, t15
Legal operand
Analyzing operand: t31: ch = TokenFactor t28, t30
Legal operand
Analyzing operand: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t36: ch = TokenFactor t16, t31, t23

Legalizing node: t37: ch = brcond t36, t34, BasicBlock:ch< 0x16b38286f10>
Analyzing result type: ch
Legal result type
Analyzing operand: t36: ch = TokenFactor t16, t31, t23
Legal operand
Analyzing operand: t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
Promote integer operand: t37: ch = brcond t36, t34, BasicBlock:ch< 0x16b38286f10>
Creating new node: t50: i16 = any_extend t34

Legalizing node: t50: i16 = any_extend t34
Analyzing result type: i16
Legal result type
Analyzing operand: t34: i1 = setcc t24, Constant:i32<0>, seteq:ch
Promote integer operand: t50: i16 = any_extend t34
Replacing: t50: i16 = any_extend t34
     with: t48: i16 = setcc t49, Constant:i16<0>, seteq:ch

Legalizing node: t49: i16 = or t46, t45
Analyzing result type: i16
Legal result type
Analyzing operand: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16
Legal operand
Analyzing operand: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t49: i16 = or t46, t45

Legalizing node: t48: i16 = setcc t49, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t49: i16 = or t46, t45
Legal operand
Analyzing operand: t11: i16 = Constant<0>
Legal operand
Analyzing operand: t33: ch = seteq
Legal operand
Legally typed node: t48: i16 = setcc t49, Constant:i16<0>, seteq:ch

Legalizing node: t37: ch = brcond t36, t48, BasicBlock:ch< 0x16b38286f10>
Analyzing result type: ch
Legal result type
Analyzing operand: t36: ch = TokenFactor t16, t31, t23
Legal operand
Analyzing operand: t48: i16 = setcc t49, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t35: ch = BasicBlock< 0x16b38286f10>
Legal operand
Legally typed node: t37: ch = brcond t36, t48, BasicBlock:ch< 0x16b38286f10>

Legalizing node: t39: ch = br t37, BasicBlock:ch< 0x16b38282830>
Analyzing result type: ch
Legal result type
Analyzing operand: t37: ch = brcond t36, t48, BasicBlock:ch< 0x16b38286f10>
Legal operand
Analyzing operand: t38: ch = BasicBlock< 0x16b38282830>
Legal operand
Legally typed node: t39: ch = br t37, BasicBlock:ch< 0x16b38282830>

Legalizing node: t65535: ch = handlenode t39
Analyzing result type: ch
Legal result type
Analyzing operand: t39: ch = br t37, BasicBlock:ch< 0x16b38282830>
Legal operand
Legally typed node: t65535: ch = handlenode t39

Type-legalized selection DAG: %bb.0 'do_calc:'
SelectionDAG has 41 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
        t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
        t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t42, undef:i16
      t44: ch = TokenFactor t40, t43
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
    t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
  t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
  t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
  t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
          t28: ch = CopyToReg t0, Register:i16 %6, t45
          t30: ch = CopyToReg t0, Register:i16 %7, t46
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
        t49: i16 = or t46, t45
      t48: i16 = setcc t49, Constant:i16<0>, seteq:ch
    t37: ch = brcond t36, t48, BasicBlock:ch< 0x16b38286f10>
  t39: ch = br t37, BasicBlock:ch< 0x16b38282830>



Combining: t49: i16 = or t46, t45

Combining: t48: i16 = setcc t49, Constant:i16<0>, seteq:ch

Combining: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t42, undef:i16

Combining: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16

Combining: t44: ch = TokenFactor t40, t43

Combining: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t42, undef:i16

Combining: t42: i16 = add nuw FrameIndex:i16<1>, Constant:i16<2>
Creating new node: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
 ... into: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>

Combining: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>

Combining: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16

Combining: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16

Combining: t41: i16 = Constant<2>

Combining: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16

Combining: t39: ch = br t37, BasicBlock:ch< 0x16b38282830>

Combining: t38: ch = BasicBlock< 0x16b38282830>

Combining: t37: ch = brcond t36, t48, BasicBlock:ch< 0x16b38286f10>
Creating new node: t52: ch = br_cc t36, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38286f10>
 ... into: t52: ch = br_cc t36, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38286f10>

Combining: t49: i16 = or t46, t45

Combining: t52: ch = br_cc t36, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38286f10>

Combining: t39: ch = br t52, BasicBlock:ch< 0x16b38282830>

Combining: t36: ch = TokenFactor t16, t31, t23

Combining: t35: ch = BasicBlock< 0x16b38286f10>

Combining: t33: ch = seteq

Combining: t31: ch = TokenFactor t28, t30

Combining: t30: ch = CopyToReg t0, Register:i16 %7, t46

Combining: t29: i16 = Register %7

Combining: t28: ch = CopyToReg t0, Register:i16 %6, t45

Combining: t27: i16 = Register %6

Combining: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16

Combining: t22: i16 = FrameIndex<3>

Combining: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16

Combining: t20: i16 = FrameIndex<2>

Combining: t18: i16 = undef

Combining: t17: i16 = FrameIndex<1>

Combining: t16: ch = TokenFactor t13, t15

Combining: t15: ch = CopyToReg t0, Register:i16 %5, t4

Combining: t14: i16 = Register %5

Combining: t13: ch = CopyToReg t0, Register:i16 %4, t2

Combining: t12: i16 = Register %4

Combining: t11: i16 = Constant<0>

Combining: t8: i16,ch = CopyFromReg t0, Register:i16 %3

Combining: t7: i16 = Register %3

Combining: t6: i16,ch = CopyFromReg t0, Register:i16 %2

Combining: t5: i16 = Register %2

Combining: t4: i16,ch = CopyFromReg t0, Register:i16 %1

Combining: t3: i16 = Register %1

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Combining: t1: i16 = Register %0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.0 'do_calc:'
SelectionDAG has 40 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
        t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
        t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16
      t44: ch = TokenFactor t40, t43
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
    t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
  t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
  t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16
  t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
          t28: ch = CopyToReg t0, Register:i16 %6, t45
          t30: ch = CopyToReg t0, Register:i16 %7, t46
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
      t49: i16 = or t46, t45
    t52: ch = br_cc t36, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38286f10>
  t39: ch = br t52, BasicBlock:ch< 0x16b38282830>



Legalizing: t39: ch = br t52, BasicBlock:ch< 0x16b38282830>
Legal node: nothing to do

Legalizing: t52: ch = br_cc t36, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38286f10>
Trying custom legalization
Creating new node: t53: glue = SymphonyISD::CMP t49, Constant:i16<0>
Creating constant: t54: i16 = Constant<1>
Creating new node: t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53
Successfully custom legalized node
 ... replacing: t52: ch = br_cc t36, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38286f10>
     with:      t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53

Legalizing: t36: ch = TokenFactor t16, t31, t23
Legal node: nothing to do

Legalizing: t31: ch = TokenFactor t28, t30
Legal node: nothing to do

Legalizing: t28: ch = CopyToReg t0, Register:i16 %6, t45
Legal node: nothing to do

Legalizing: t49: i16 = or t46, t45
Legal node: nothing to do

Legalizing: t30: ch = CopyToReg t0, Register:i16 %7, t46
Legal node: nothing to do

Legalizing: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16
Legalizing non-extending load operation

Legalizing: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t44: ch = TokenFactor t40, t43
Legal node: nothing to do

Legalizing: t16: ch = TokenFactor t13, t15
Legal node: nothing to do

Legalizing: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: ch = CopyToReg t0, Register:i16 %5, t4
Legal node: nothing to do

Legalizing: t13: ch = CopyToReg t0, Register:i16 %4, t2
Legal node: nothing to do

Legalizing: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t8: i16,ch = CopyFromReg t0, Register:i16 %3
Legal node: nothing to do

Legalizing: t6: i16,ch = CopyFromReg t0, Register:i16 %2
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal node: nothing to do

Legalizing: t41: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t38: ch = BasicBlock< 0x16b38282830>
Legal node: nothing to do

Legalizing: t35: ch = BasicBlock< 0x16b38286f10>
Legal node: nothing to do

Legalizing: t29: i16 = Register %7

Legalizing: t27: i16 = Register %6

Legalizing: t22: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t20: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t18: i16 = undef
Legal node: nothing to do

Legalizing: t17: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t14: i16 = Register %5

Legalizing: t12: i16 = Register %4

Legalizing: t11: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i16 = Register %3

Legalizing: t5: i16 = Register %2

Legalizing: t3: i16 = Register %1

Legalizing: t1: i16 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53
Legal node: nothing to do

Legalizing: t54: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t53: glue = SymphonyISD::CMP t49, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.0 'do_calc:'
SelectionDAG has 41 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
  t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
        t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
        t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16
      t44: ch = TokenFactor t40, t43
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
    t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
  t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
  t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
          t28: ch = CopyToReg t0, Register:i16 %6, t45
          t30: ch = CopyToReg t0, Register:i16 %7, t46
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
        t49: i16 = or t46, t45
      t53: glue = SymphonyISD::CMP t49, Constant:i16<0>
    t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53
  t39: ch = br t55, BasicBlock:ch< 0x16b38282830>



Legalizing: t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53
Legal node: nothing to do

Combining: t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53

Legalizing: t54: i16 = Constant<1>
Legal node: nothing to do

Combining: t54: i16 = Constant<1>

Legalizing: t53: glue = SymphonyISD::CMP t49, Constant:i16<0>
Legal node: nothing to do

Combining: t53: glue = SymphonyISD::CMP t49, Constant:i16<0>

Legalizing: t39: ch = br t55, BasicBlock:ch< 0x16b38282830>
Legal node: nothing to do

Combining: t39: ch = br t55, BasicBlock:ch< 0x16b38282830>

Legalizing: t36: ch = TokenFactor t16, t31, t23
Legal node: nothing to do

Combining: t36: ch = TokenFactor t16, t31, t23

Legalizing: t31: ch = TokenFactor t28, t30
Legal node: nothing to do

Combining: t31: ch = TokenFactor t28, t30

Legalizing: t28: ch = CopyToReg t0, Register:i16 %6, t45
Legal node: nothing to do

Combining: t28: ch = CopyToReg t0, Register:i16 %6, t45

Legalizing: t49: i16 = or t46, t45
Legal node: nothing to do

Combining: t49: i16 = or t46, t45

Legalizing: t30: ch = CopyToReg t0, Register:i16 %7, t46
Legal node: nothing to do

Combining: t30: ch = CopyToReg t0, Register:i16 %7, t46

Legalizing: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16

Legalizing: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16
Legalizing non-extending load operation

Combining: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16

Legalizing: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16

Legalizing: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16

Legalizing: t44: ch = TokenFactor t40, t43
Legal node: nothing to do

Combining: t44: ch = TokenFactor t40, t43

Legalizing: t16: ch = TokenFactor t13, t15
Legal node: nothing to do

Combining: t16: ch = TokenFactor t13, t15

Legalizing: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16

Legalizing: t15: ch = CopyToReg t0, Register:i16 %5, t4
Legal node: nothing to do

Combining: t15: ch = CopyToReg t0, Register:i16 %5, t4

Legalizing: t13: ch = CopyToReg t0, Register:i16 %4, t2
Legal node: nothing to do

Combining: t13: ch = CopyToReg t0, Register:i16 %4, t2

Legalizing: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16

Legalizing: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
Legal node: nothing to do

Combining: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>

Legalizing: t8: i16,ch = CopyFromReg t0, Register:i16 %3
Legal node: nothing to do

Combining: t8: i16,ch = CopyFromReg t0, Register:i16 %3

Legalizing: t6: i16,ch = CopyFromReg t0, Register:i16 %2
Legal node: nothing to do

Combining: t6: i16,ch = CopyFromReg t0, Register:i16 %2

Legalizing: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t0, Register:i16 %1

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %0

Legalizing: t41: i16 = Constant<2>
Legal node: nothing to do

Combining: t41: i16 = Constant<2>

Legalizing: t38: ch = BasicBlock< 0x16b38282830>
Legal node: nothing to do

Combining: t38: ch = BasicBlock< 0x16b38282830>

Legalizing: t35: ch = BasicBlock< 0x16b38286f10>
Legal node: nothing to do

Combining: t35: ch = BasicBlock< 0x16b38286f10>

Legalizing: t29: i16 = Register %7

Combining: t29: i16 = Register %7

Legalizing: t27: i16 = Register %6

Combining: t27: i16 = Register %6

Legalizing: t22: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t22: i16 = FrameIndex<3>

Legalizing: t20: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t20: i16 = FrameIndex<2>

Legalizing: t18: i16 = undef
Legal node: nothing to do

Combining: t18: i16 = undef

Legalizing: t17: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t17: i16 = FrameIndex<1>

Legalizing: t14: i16 = Register %5

Combining: t14: i16 = Register %5

Legalizing: t12: i16 = Register %4

Combining: t12: i16 = Register %4

Legalizing: t11: i16 = Constant<0>
Legal node: nothing to do

Combining: t11: i16 = Constant<0>

Legalizing: t7: i16 = Register %3

Combining: t7: i16 = Register %3

Legalizing: t5: i16 = Register %2

Combining: t5: i16 = Register %2

Legalizing: t3: i16 = Register %1

Combining: t3: i16 = Register %1

Legalizing: t1: i16 = Register %0

Combining: t1: i16 = Register %0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 'do_calc:'
SelectionDAG has 41 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
  t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
        t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
        t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16
      t44: ch = TokenFactor t40, t43
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
    t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
  t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
  t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
          t28: ch = CopyToReg t0, Register:i16 %6, t45
          t30: ch = CopyToReg t0, Register:i16 %7, t46
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
        t49: i16 = or t46, t45
      t53: glue = SymphonyISD::CMP t49, Constant:i16<0>
    t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53
  t39: ch = br t55, BasicBlock:ch< 0x16b38282830>


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t39: ch = br t55, BasicBlock:ch< 0x16b38282830>
Selecting: t39: ch = br t55, BasicBlock:ch< 0x16b38282830>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t39: ch = JMPI BasicBlock:ch< 0x16b38282830>, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53
Selecting: t55: ch = SymphonyISD::BR_CC t36, BasicBlock:ch< 0x16b38286f10>, Constant:i16<1>, t53

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t55: ch = JEI BasicBlock:ch< 0x16b38286f10>, t36, t53
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = TokenFactor t16, t31, t23
Selecting: t36: ch = TokenFactor t16, t31, t23


ISEL: Starting selection on root node: t31: ch = TokenFactor t28, t30
Selecting: t31: ch = TokenFactor t28, t30


ISEL: Starting selection on root node: t53: glue = SymphonyISD::CMP t49, Constant:i16<0>
Selecting: t53: glue = SymphonyISD::CMP t49, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t56: i16 = TargetConstant<0>
  Morphed node: t53: i16,glue = CMPI t49, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t28: ch = CopyToReg t0, Register:i16 %6, t45
Selecting: t28: ch = CopyToReg t0, Register:i16 %6, t45


ISEL: Starting selection on root node: t49: i16 = or t46, t45
Selecting: t49: i16 = or t46, t45

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t49: i16 = ORR t46, t45
ISEL: Match complete!

ISEL: Starting selection on root node: t30: ch = CopyToReg t0, Register:i16 %7, t46
Selecting: t30: ch = CopyToReg t0, Register:i16 %7, t46


ISEL: Starting selection on root node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16
Selecting: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t23, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> FrameIndex:i16<1>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16
Selecting: t46: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t23, t51, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t46: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t51, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16
Selecting: t23: ch = store<(store (s16) into %ir.7)> t21, t8, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t23: ch = STORE16R<Mem:(store (s16) into %ir.7)> FrameIndex:i16<3>, t8, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16
Selecting: t21: ch = store<(store (s16) into %ir.6)> t44, t6, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> FrameIndex:i16<2>, t6, t44
ISEL: Match complete!

ISEL: Starting selection on root node: t44: ch = TokenFactor t40, t43
Selecting: t44: ch = TokenFactor t40, t43


ISEL: Starting selection on root node: t16: ch = TokenFactor t13, t15
Selecting: t16: ch = TokenFactor t13, t15


ISEL: Starting selection on root node: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16
Selecting: t43: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, t4, t51, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch = CopyToReg t0, Register:i16 %5, t4
Selecting: t15: ch = CopyToReg t0, Register:i16 %5, t4


ISEL: Starting selection on root node: t13: ch = CopyToReg t0, Register:i16 %4, t2
Selecting: t13: ch = CopyToReg t0, Register:i16 %4, t2


ISEL: Starting selection on root node: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16
Selecting: t40: ch = store<(store (s16) into %ir.5, align 4)> t0, t2, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<1>, t2, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>
Selecting: t51: i16 = or disjoint FrameIndex:i16<1>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t57: i16 = TargetConstant<2>
  Morphed node: t51: i16 = ORI disjoint FrameIndex:i16<1>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16,ch = CopyFromReg t0, Register:i16 %3
Selecting: t8: i16,ch = CopyFromReg t0, Register:i16 %3


ISEL: Starting selection on root node: t6: i16,ch = CopyFromReg t0, Register:i16 %2
Selecting: t6: i16,ch = CopyFromReg t0, Register:i16 %2


ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t0, Register:i16 %1
Selecting: t4: i16,ch = CopyFromReg t0, Register:i16 %1


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %0
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %0


ISEL: Starting selection on root node: t38: ch = BasicBlock< 0x16b38282830>
Selecting: t38: ch = BasicBlock< 0x16b38282830>


ISEL: Starting selection on root node: t35: ch = BasicBlock< 0x16b38286f10>
Selecting: t35: ch = BasicBlock< 0x16b38286f10>


ISEL: Starting selection on root node: t29: i16 = Register %7
Selecting: t29: i16 = Register %7


ISEL: Starting selection on root node: t27: i16 = Register %6
Selecting: t27: i16 = Register %6


ISEL: Starting selection on root node: t22: i16 = FrameIndex<3>
Selecting: t22: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t22: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16 = FrameIndex<2>
Selecting: t20: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = FrameIndex<1>
Selecting: t17: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t17: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = Register %5
Selecting: t14: i16 = Register %5


ISEL: Starting selection on root node: t12: i16 = Register %4
Selecting: t12: i16 = Register %4


ISEL: Starting selection on root node: t7: i16 = Register %3
Selecting: t7: i16 = Register %3


ISEL: Starting selection on root node: t5: i16 = Register %2
Selecting: t5: i16 = Register %2


ISEL: Starting selection on root node: t3: i16 = Register %1
Selecting: t3: i16 = Register %1


ISEL: Starting selection on root node: t1: i16 = Register %0
Selecting: t1: i16 = Register %0


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.0 'do_calc:'
SelectionDAG has 42 nodes:
  t0: ch,glue = EntryToken
  t17: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t4: i16,ch = CopyFromReg t0, Register:i16 %1
  t51: i16 = ORI disjoint t17, TargetConstant:i16<2>
    t22: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
    t8: i16,ch = CopyFromReg t0, Register:i16 %3
      t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
      t6: i16,ch = CopyFromReg t0, Register:i16 %2
        t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0
        t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0
      t44: ch = TokenFactor t40, t43
    t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> t20, t6, t44
  t23: ch = STORE16R<Mem:(store (s16) into %ir.7)> t22, t8, t21
  t46: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t51, t23
  t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t17, t23
          t13: ch = CopyToReg t0, Register:i16 %4, t2
          t15: ch = CopyToReg t0, Register:i16 %5, t4
        t16: ch = TokenFactor t13, t15
          t28: ch = CopyToReg t0, Register:i16 %6, t45
          t30: ch = CopyToReg t0, Register:i16 %7, t46
        t31: ch = TokenFactor t28, t30
      t36: ch = TokenFactor t16, t31, t23
        t49: i16 = ORR t46, t45
      t53: i16,glue = CMPI t49, TargetConstant:i16<0>
    t55: ch = JEI BasicBlock:ch< 0x16b38286f10>, t36, t53:1
  t39: ch = JMPI BasicBlock:ch< 0x16b38282830>, t55


********** List Scheduling %bb.0 '' **********
SU(0): t39: ch = JMPI BasicBlock:ch< 0x16b38282830>, t55

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t55: ch = JEI BasicBlock:ch< 0x16b38286f10>, t36, t53:1

    t53: i16,glue = CMPI t49, TargetConstant:i16<0>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 1
  Predecessors:
    SU(18): Ord  Latency=0 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t49: i16 = ORR t46, t45

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(17): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t17, t23

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
    SU(21): Data Latency=1
SU(4): t23: ch = STORE16R<Mem:(store (s16) into %ir.7)> t22, t8, t21

  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(15): Data Latency=1
    SU(14): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
SU(5): t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> t20, t6, t44

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(12): Data Latency=1
    SU(6): Ord  Latency=0 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(6): t44: ch = TokenFactor t40, t43

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 5
  Predecessors:
    SU(10): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=0 Barrier
SU(7): t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 6
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(8): t4: i16,ch = CopyFromReg t0, Register:i16 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(7): Data Latency=1
    SU(23): Data Latency=1
SU(9): t51: i16 = ORI disjoint t17, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 7
  Predecessors:
    SU(16): Data Latency=1
  Successors:
    SU(7): Data Latency=1
    SU(17): Data Latency=1
SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(16): Data Latency=1
    SU(11): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(11): t2: i16,ch = CopyFromReg t0, Register:i16 %0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(10): Data Latency=1
    SU(24): Data Latency=1
SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(5): Data Latency=1
SU(13): t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(5): Data Latency=1
SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=1
SU(15): t22: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=1
SU(16): t17: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(3): Data Latency=1
    SU(9): Data Latency=1
    SU(10): Data Latency=1
SU(17): t46: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t51, t23

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(9): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
    SU(20): Data Latency=1
SU(18): t36: ch = TokenFactor t16, t31, t23

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 1
  Predecessors:
    SU(22): Ord  Latency=0 Barrier
    SU(19): Ord  Latency=0 Barrier
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(19): t31: ch = TokenFactor t28, t30

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 1
  Predecessors:
    SU(21): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
  Successors:
    SU(18): Ord  Latency=0 Barrier
SU(20): t30: ch = CopyToReg t0, Register:i16 %7, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(17): Data Latency=1
  Successors:
    SU(19): Ord  Latency=1 Barrier
SU(21): t28: ch = CopyToReg t0, Register:i16 %6, t45

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(19): Ord  Latency=1 Barrier
SU(22): t16: ch = TokenFactor t13, t15

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
  Successors:
    SU(18): Ord  Latency=0 Barrier
SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(22): Ord  Latency=1 Barrier
SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(22): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t39: ch = JMPI BasicBlock:ch< 0x16b38282830>, t55


*** Scheduling [0]: SU(0): t39: ch = JMPI BasicBlock:ch< 0x16b38282830>, t55


Examining Available:
Height 1: SU(1): t55: ch = JEI BasicBlock:ch< 0x16b38286f10>, t36, t53:1

    t53: i16,glue = CMPI t49, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t55: ch = JEI BasicBlock:ch< 0x16b38286f10>, t36, t53:1

    t53: i16,glue = CMPI t49, TargetConstant:i16<0>


Examining Available:
Height 1: SU(18): t36: ch = TokenFactor t16, t31, t23

Height 2: SU(2): t49: i16 = ORR t46, t45


*** Scheduling [2]: SU(18): t36: ch = TokenFactor t16, t31, t23


Examining Available:
Height 2: SU(19): t31: ch = TokenFactor t28, t30

Height 2: SU(22): t16: ch = TokenFactor t13, t15

Height 2: SU(2): t49: i16 = ORR t46, t45


*** Scheduling [3]: SU(19): t31: ch = TokenFactor t28, t30


Examining Available:
Height 2: SU(22): t16: ch = TokenFactor t13, t15

Height 4: SU(21): t28: ch = CopyToReg t0, Register:i16 %6, t45

Height 4: SU(20): t30: ch = CopyToReg t0, Register:i16 %7, t46

Height 2: SU(2): t49: i16 = ORR t46, t45


*** Scheduling [4]: SU(22): t16: ch = TokenFactor t13, t15


Examining Available:
Height 4: SU(21): t28: ch = CopyToReg t0, Register:i16 %6, t45

Height 4: SU(20): t30: ch = CopyToReg t0, Register:i16 %7, t46

Height 2: SU(2): t49: i16 = ORR t46, t45

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [5]: SU(21): t28: ch = CopyToReg t0, Register:i16 %6, t45


Examining Available:
Height 4: SU(20): t30: ch = CopyToReg t0, Register:i16 %7, t46

Height 2: SU(2): t49: i16 = ORR t46, t45

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [6]: SU(20): t30: ch = CopyToReg t0, Register:i16 %7, t46


Examining Available:
Height 2: SU(2): t49: i16 = ORR t46, t45

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [7]: SU(2): t49: i16 = ORR t46, t45


Examining Available:
Height 8: SU(17): t46: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t51, t23

Height 8: SU(3): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t17, t23

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [8]: SU(17): t46: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t51, t23


Examining Available:
Height 8: SU(3): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t17, t23

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [9]: SU(3): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t17, t23


Examining Available:
Height 10: SU(4): t23: ch = STORE16R<Mem:(store (s16) into %ir.7)> t22, t8, t21

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [10]: SU(4): t23: ch = STORE16R<Mem:(store (s16) into %ir.7)> t22, t8, t21


Examining Available:
Height 11: SU(15): t22: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 11: SU(5): t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> t20, t6, t44

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [11]: SU(15): t22: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 11: SU(5): t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> t20, t6, t44

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [12]: SU(5): t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> t20, t6, t44


Examining Available:
Height 12: SU(6): t44: ch = TokenFactor t40, t43

Height 13: SU(13): t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [13]: SU(6): t44: ch = TokenFactor t40, t43


Examining Available:
Height 13: SU(13): t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  Comparing latency of SU (7) depth 2 vs SU (10) depth 1
Height 14: SU(7): t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0

Height 14: SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0

Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [14]: SU(13): t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


Examining Available:
  Comparing latency of SU (7) depth 2 vs SU (10) depth 1
Height 14: SU(7): t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0

Height 14: SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0

Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4

  Comparing latency of SU (7) depth 2 vs SU (10) depth 1

*** Scheduling [15]: SU(7): t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0


Examining Available:
Height 16: SU(9): t51: i16 = ORI disjoint t17, TargetConstant:i16<2>

Height 14: SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0

Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [16]: SU(9): t51: i16 = ORI disjoint t17, TargetConstant:i16<2>


Examining Available:
Height 14: SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0

Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [17]: SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0


Examining Available:
Height 18: SU(16): t17: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [18]: SU(16): t17: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 13: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [19]: SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2


Examining Available:
Height 11: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [20]: SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3


Examining Available:
Height 5: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [21]: SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2


Examining Available:
Height 22: SU(11): t2: i16,ch = CopyFromReg t0, Register:i16 %0

Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [22]: SU(11): t2: i16,ch = CopyFromReg t0, Register:i16 %0


Examining Available:
Height 5: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


*** Scheduling [23]: SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4


Examining Available:
Height 24: SU(8): t4: i16,ch = CopyFromReg t0, Register:i16 %1


*** Scheduling [24]: SU(8): t4: i16,ch = CopyFromReg t0, Register:i16 %1

*** Final schedule ***
SU(8): t4: i16,ch = CopyFromReg t0, Register:i16 %1

SU(23): t15: ch = CopyToReg t0, Register:i16 %5, t4

SU(11): t2: i16,ch = CopyFromReg t0, Register:i16 %0

SU(24): t13: ch = CopyToReg t0, Register:i16 %4, t2

SU(14): t8: i16,ch = CopyFromReg t0, Register:i16 %3

SU(12): t6: i16,ch = CopyFromReg t0, Register:i16 %2

SU(16): t17: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(10): t40: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t17, t2, t0

SU(9): t51: i16 = ORI disjoint t17, TargetConstant:i16<2>

SU(7): t43: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t51, t4, t0

SU(13): t20: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(6): t44: ch = TokenFactor t40, t43

SU(5): t21: ch = STORE16R<Mem:(store (s16) into %ir.6)> t20, t6, t44

SU(15): t22: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(4): t23: ch = STORE16R<Mem:(store (s16) into %ir.7)> t22, t8, t21

SU(3): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t17, t23

SU(17): t46: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t51, t23

SU(2): t49: i16 = ORR t46, t45

SU(20): t30: ch = CopyToReg t0, Register:i16 %7, t46

SU(21): t28: ch = CopyToReg t0, Register:i16 %6, t45

SU(22): t16: ch = TokenFactor t13, t15

SU(19): t31: ch = TokenFactor t28, t30

SU(18): t36: ch = TokenFactor t16, t31, t23

SU(1): t55: ch = JEI BasicBlock:ch< 0x16b38286f10>, t36, t53:1

    t53: i16,glue = CMPI t49, TargetConstant:i16<0>

SU(0): t39: ch = JMPI BasicBlock:ch< 0x16b38282830>, t55


Total amount of phi nodes to update: 0
Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<1>
Creating new node: t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287058>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38282978>

Initial selection DAG: %bb.10 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287058>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282978>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282978>

Combining: t11: ch = BasicBlock< 0x16b38282978>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287058>

Combining: t9: ch = BasicBlock< 0x16b38287058>

Combining: t8: i1 = setcc t5, Constant:i32<1>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<1>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.10 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287058>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282978>



Legalizing node: t11: ch = BasicBlock< 0x16b38282978>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282978>

Legalizing node: t9: ch = BasicBlock< 0x16b38287058>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38287058>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<1>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<1>
Creating constant: t13: i16 = Constant<1>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<1>

Legalizing node: t3: i16 = Register %7
Ignoring node results
Legally typed node: t3: i16 = Register %7

Legalizing node: t1: i16 = Register %6
Ignoring node results
Legally typed node: t1: i16 = Register %6

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<1>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287058>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287058>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<1>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<1>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<1>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<1>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<1>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<1>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal operand
Analyzing operand: t13: i16 = Constant<1>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<1>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<1>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287058>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38287058>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287058>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38282978>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287058>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282978>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38282978>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38282978>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.10 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<1>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287058>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282978>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<1>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<1>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282978>

Combining: t11: ch = BasicBlock< 0x16b38282978>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287058>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287058>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287058>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287058>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38282978>

Combining: t9: ch = BasicBlock< 0x16b38287058>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.10 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t17: i16 = xor t4, Constant:i16<1>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287058>
  t12: ch = br t19, BasicBlock:ch< 0x16b38282978>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38282978>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287058>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating new node: t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287058>
     with:      t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<1>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282978>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38287058>
Legal node: nothing to do

Legalizing: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.10 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<1>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20
  t12: ch = br t21, BasicBlock:ch< 0x16b38282978>



Legalizing: t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t21, BasicBlock:ch< 0x16b38282978>
Legal node: nothing to do

Combining: t12: ch = br t21, BasicBlock:ch< 0x16b38282978>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<1>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<1>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<1>
Legal node: nothing to do

Combining: t13: i16 = Constant<1>

Legalizing: t11: ch = BasicBlock< 0x16b38282978>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282978>

Legalizing: t9: ch = BasicBlock< 0x16b38287058>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38287058>

Legalizing: t3: i16 = Register %7

Combining: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Combining: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.10 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<1>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20
  t12: ch = br t21, BasicBlock:ch< 0x16b38282978>


===== Instruction selection begins: %bb.10 ''

ISEL: Starting selection on root node: t12: ch = br t21, BasicBlock:ch< 0x16b38282978>
Selecting: t12: ch = br t21, BasicBlock:ch< 0x16b38282978>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38282978>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20
Selecting: t21: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287058>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t21: ch = JEI BasicBlock:ch< 0x16b38287058>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t22: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<1>
Selecting: t17: i16 = xor t4, Constant:i16<1>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t23: i16 = TargetConstant<1>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %6


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282978>
Selecting: t11: ch = BasicBlock< 0x16b38282978>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38287058>
Selecting: t9: ch = BasicBlock< 0x16b38287058>


ISEL: Starting selection on root node: t3: i16 = Register %7
Selecting: t3: i16 = Register %7


ISEL: Starting selection on root node: t1: i16 = Register %6
Selecting: t1: i16 = Register %6


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.10 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = XORI t4, TargetConstant:i16<1>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t21: ch = JEI BasicBlock:ch< 0x16b38287058>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38282978>, t21


********** List Scheduling %bb.10 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282978>, t21

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t21: ch = JEI BasicBlock:ch< 0x16b38287058>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282978>, t21


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282978>, t21


Examining Available:
Height 1: SU(1): t21: ch = JEI BasicBlock:ch< 0x16b38287058>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t21: ch = JEI BasicBlock:ch< 0x16b38287058>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<1>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<1>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

SU(4): t17: i16 = XORI t4, TargetConstant:i16<1>

SU(2): t18: i16 = ORR t17, t2

SU(1): t21: ch = JEI BasicBlock:ch< 0x16b38287058>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282978>, t21


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<2>
Creating new node: t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382871a0>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>

Initial selection DAG: %bb.11 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382871a0>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>

Combining: t11: ch = BasicBlock< 0x16b38282ac0>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382871a0>

Combining: t9: ch = BasicBlock< 0x16b382871a0>

Combining: t8: i1 = setcc t5, Constant:i32<2>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<2>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.11 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382871a0>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>



Legalizing node: t11: ch = BasicBlock< 0x16b38282ac0>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282ac0>

Legalizing node: t9: ch = BasicBlock< 0x16b382871a0>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b382871a0>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<2>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<2>
Creating constant: t13: i16 = Constant<2>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<2>

Legalizing node: t3: i16 = Register %7
Ignoring node results
Legally typed node: t3: i16 = Register %7

Legalizing node: t1: i16 = Register %6
Ignoring node results
Legally typed node: t1: i16 = Register %6

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<2>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382871a0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382871a0>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<2>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<2>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<2>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<2>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<2>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal operand
Analyzing operand: t13: i16 = Constant<2>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<2>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<2>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382871a0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b382871a0>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382871a0>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382871a0>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282ac0>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.11 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<2>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382871a0>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<2>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<2>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282ac0>

Combining: t11: ch = BasicBlock< 0x16b38282ac0>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382871a0>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382871a0>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382871a0>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382871a0>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38282ac0>

Combining: t9: ch = BasicBlock< 0x16b382871a0>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.11 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t17: i16 = xor t4, Constant:i16<2>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382871a0>
  t12: ch = br t19, BasicBlock:ch< 0x16b38282ac0>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38282ac0>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382871a0>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382871a0>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<2>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282ac0>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b382871a0>
Legal node: nothing to do

Legalizing: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.11 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<2>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282ac0>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38282ac0>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38282ac0>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<2>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<2>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<2>
Legal node: nothing to do

Combining: t13: i16 = Constant<2>

Legalizing: t11: ch = BasicBlock< 0x16b38282ac0>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282ac0>

Legalizing: t9: ch = BasicBlock< 0x16b382871a0>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b382871a0>

Legalizing: t3: i16 = Register %7

Combining: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Combining: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.11 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<2>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282ac0>


===== Instruction selection begins: %bb.11 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38282ac0>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38282ac0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38282ac0>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382871a0>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b382871a0>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<2>
Selecting: t17: i16 = xor t4, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<2>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %6


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282ac0>
Selecting: t11: ch = BasicBlock< 0x16b38282ac0>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b382871a0>
Selecting: t9: ch = BasicBlock< 0x16b382871a0>


ISEL: Starting selection on root node: t3: i16 = Register %7
Selecting: t3: i16 = Register %7


ISEL: Starting selection on root node: t1: i16 = Register %6
Selecting: t1: i16 = Register %6


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.11 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = XORI t4, TargetConstant:i16<2>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b382871a0>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38282ac0>, t22


********** List Scheduling %bb.11 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282ac0>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382871a0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282ac0>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282ac0>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382871a0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382871a0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<2>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<2>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

SU(4): t17: i16 = XORI t4, TargetConstant:i16<2>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382871a0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282ac0>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<3>
Creating new node: t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382872e8>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>

Initial selection DAG: %bb.12 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382872e8>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>

Combining: t11: ch = BasicBlock< 0x16b38282c08>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382872e8>

Combining: t9: ch = BasicBlock< 0x16b382872e8>

Combining: t8: i1 = setcc t5, Constant:i32<3>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<3>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.12 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382872e8>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>



Legalizing node: t11: ch = BasicBlock< 0x16b38282c08>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282c08>

Legalizing node: t9: ch = BasicBlock< 0x16b382872e8>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b382872e8>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<3>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<3>
Creating constant: t13: i16 = Constant<3>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<3>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<3>

Legalizing node: t3: i16 = Register %7
Ignoring node results
Legally typed node: t3: i16 = Register %7

Legalizing node: t1: i16 = Register %6
Ignoring node results
Legally typed node: t1: i16 = Register %6

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<3>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382872e8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382872e8>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<3>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<3>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<3>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<3>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<3>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal operand
Analyzing operand: t13: i16 = Constant<3>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<3>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<3>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382872e8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b382872e8>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382872e8>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382872e8>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282c08>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.12 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<3>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382872e8>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<3>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<3>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282c08>

Combining: t11: ch = BasicBlock< 0x16b38282c08>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382872e8>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382872e8>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382872e8>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382872e8>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38282c08>

Combining: t9: ch = BasicBlock< 0x16b382872e8>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.12 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t17: i16 = xor t4, Constant:i16<3>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382872e8>
  t12: ch = br t19, BasicBlock:ch< 0x16b38282c08>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38282c08>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382872e8>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382872e8>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<3>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<3>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282c08>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b382872e8>
Legal node: nothing to do

Legalizing: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.12 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<3>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282c08>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38282c08>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38282c08>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<3>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<3>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<3>
Legal node: nothing to do

Combining: t13: i16 = Constant<3>

Legalizing: t11: ch = BasicBlock< 0x16b38282c08>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282c08>

Legalizing: t9: ch = BasicBlock< 0x16b382872e8>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b382872e8>

Legalizing: t3: i16 = Register %7

Combining: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Combining: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.12 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<3>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282c08>


===== Instruction selection begins: %bb.12 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38282c08>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38282c08>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38282c08>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382872e8>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b382872e8>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<3>
Selecting: t17: i16 = xor t4, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<3>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %6


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282c08>
Selecting: t11: ch = BasicBlock< 0x16b38282c08>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b382872e8>
Selecting: t9: ch = BasicBlock< 0x16b382872e8>


ISEL: Starting selection on root node: t3: i16 = Register %7
Selecting: t3: i16 = Register %7


ISEL: Starting selection on root node: t1: i16 = Register %6
Selecting: t1: i16 = Register %6


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.12 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = XORI t4, TargetConstant:i16<3>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b382872e8>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38282c08>, t22


********** List Scheduling %bb.12 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282c08>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382872e8>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282c08>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282c08>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382872e8>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382872e8>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<3>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<3>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

SU(4): t17: i16 = XORI t4, TargetConstant:i16<3>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382872e8>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282c08>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<4>
Creating new node: t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287430>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>

Initial selection DAG: %bb.13 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287430>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>

Combining: t11: ch = BasicBlock< 0x16b38282d50>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287430>

Combining: t9: ch = BasicBlock< 0x16b38287430>

Combining: t8: i1 = setcc t5, Constant:i32<4>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<4>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.13 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287430>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>



Legalizing node: t11: ch = BasicBlock< 0x16b38282d50>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282d50>

Legalizing node: t9: ch = BasicBlock< 0x16b38287430>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38287430>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<4>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<4>
Creating constant: t13: i16 = Constant<4>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<4>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<4>

Legalizing node: t3: i16 = Register %7
Ignoring node results
Legally typed node: t3: i16 = Register %7

Legalizing node: t1: i16 = Register %6
Ignoring node results
Legally typed node: t1: i16 = Register %6

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<4>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287430>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287430>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<4>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<4>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<4>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<4>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<4>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<4>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal operand
Analyzing operand: t13: i16 = Constant<4>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<4>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<4>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287430>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38287430>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287430>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287430>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282d50>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.13 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<4>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287430>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<4>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<4>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282d50>

Combining: t11: ch = BasicBlock< 0x16b38282d50>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287430>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287430>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287430>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287430>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38282d50>

Combining: t9: ch = BasicBlock< 0x16b38287430>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.13 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t17: i16 = xor t4, Constant:i16<4>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287430>
  t12: ch = br t19, BasicBlock:ch< 0x16b38282d50>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38282d50>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287430>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287430>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<4>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<4>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282d50>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38287430>
Legal node: nothing to do

Legalizing: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.13 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<4>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282d50>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38282d50>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38282d50>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<4>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<4>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<4>
Legal node: nothing to do

Combining: t13: i16 = Constant<4>

Legalizing: t11: ch = BasicBlock< 0x16b38282d50>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282d50>

Legalizing: t9: ch = BasicBlock< 0x16b38287430>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38287430>

Legalizing: t3: i16 = Register %7

Combining: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Combining: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.13 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<4>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282d50>


===== Instruction selection begins: %bb.13 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38282d50>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38282d50>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38282d50>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287430>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38287430>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<4>
Selecting: t17: i16 = xor t4, Constant:i16<4>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<4>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %6


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282d50>
Selecting: t11: ch = BasicBlock< 0x16b38282d50>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38287430>
Selecting: t9: ch = BasicBlock< 0x16b38287430>


ISEL: Starting selection on root node: t3: i16 = Register %7
Selecting: t3: i16 = Register %7


ISEL: Starting selection on root node: t1: i16 = Register %6
Selecting: t1: i16 = Register %6


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.13 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = XORI t4, TargetConstant:i16<4>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38287430>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38282d50>, t22


********** List Scheduling %bb.13 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282d50>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287430>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<4>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282d50>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282d50>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287430>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287430>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<4>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<4>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

SU(4): t17: i16 = XORI t4, TargetConstant:i16<4>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287430>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282d50>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<5>
Creating new node: t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287578>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>

Initial selection DAG: %bb.14 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287578>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>

Combining: t11: ch = BasicBlock< 0x16b38282e98>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287578>

Combining: t9: ch = BasicBlock< 0x16b38287578>

Combining: t8: i1 = setcc t5, Constant:i32<5>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<5>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.14 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287578>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>



Legalizing node: t11: ch = BasicBlock< 0x16b38282e98>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282e98>

Legalizing node: t9: ch = BasicBlock< 0x16b38287578>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b38287578>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<5>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<5>
Creating constant: t13: i16 = Constant<5>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<5>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<5>

Legalizing node: t3: i16 = Register %7
Ignoring node results
Legally typed node: t3: i16 = Register %7

Legalizing node: t1: i16 = Register %6
Ignoring node results
Legally typed node: t1: i16 = Register %6

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<5>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287578>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b38287578>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<5>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<5>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<5>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<5>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<5>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<5>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal operand
Analyzing operand: t13: i16 = Constant<5>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<5>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<5>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287578>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b38287578>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287578>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287578>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282e98>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.14 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<5>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287578>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<5>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<5>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282e98>

Combining: t11: ch = BasicBlock< 0x16b38282e98>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b38287578>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287578>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287578>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287578>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38282e98>

Combining: t9: ch = BasicBlock< 0x16b38287578>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.14 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t17: i16 = xor t4, Constant:i16<5>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287578>
  t12: ch = br t19, BasicBlock:ch< 0x16b38282e98>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38282e98>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287578>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b38287578>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<5>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<5>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282e98>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b38287578>
Legal node: nothing to do

Legalizing: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.14 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<5>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282e98>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38282e98>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38282e98>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<5>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<5>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<5>
Legal node: nothing to do

Combining: t13: i16 = Constant<5>

Legalizing: t11: ch = BasicBlock< 0x16b38282e98>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282e98>

Legalizing: t9: ch = BasicBlock< 0x16b38287578>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b38287578>

Legalizing: t3: i16 = Register %7

Combining: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Combining: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.14 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<5>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282e98>


===== Instruction selection begins: %bb.14 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38282e98>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38282e98>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38282e98>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287578>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b38287578>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<5>
Selecting: t17: i16 = xor t4, Constant:i16<5>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<5>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<5>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %6


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282e98>
Selecting: t11: ch = BasicBlock< 0x16b38282e98>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b38287578>
Selecting: t9: ch = BasicBlock< 0x16b38287578>


ISEL: Starting selection on root node: t3: i16 = Register %7
Selecting: t3: i16 = Register %7


ISEL: Starting selection on root node: t1: i16 = Register %6
Selecting: t1: i16 = Register %6


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.14 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = XORI t4, TargetConstant:i16<5>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b38287578>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38282e98>, t22


********** List Scheduling %bb.14 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282e98>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287578>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<5>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282e98>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282e98>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287578>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287578>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<5>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<5>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

SU(4): t17: i16 = XORI t4, TargetConstant:i16<5>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b38287578>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282e98>, t22


Creating new node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Creating new node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Creating new node: t5: i32 = build_pair t4, t2
Creating constant: t6: i32 = Constant<6>
Creating new node: t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
Creating new node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382876c0>
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b38282460>

Initial selection DAG: %bb.15 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382876c0>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282460>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282460>

Combining: t11: ch = BasicBlock< 0x16b38282460>

Combining: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382876c0>

Combining: t9: ch = BasicBlock< 0x16b382876c0>

Combining: t8: i1 = setcc t5, Constant:i32<6>, seteq:ch

Combining: t7: ch = seteq

Combining: t6: i32 = Constant<6>

Combining: t5: i32 = build_pair t4, t2

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.15 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t5: i32 = build_pair t4, t2
      t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
    t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382876c0>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282460>



Legalizing node: t11: ch = BasicBlock< 0x16b38282460>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282460>

Legalizing node: t9: ch = BasicBlock< 0x16b382876c0>
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = BasicBlock< 0x16b382876c0>

Legalizing node: t7: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t7: ch = seteq

Legalizing node: t6: i32 = Constant<6>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<6>
Creating constant: t13: i16 = Constant<6>
Creating constant: t14: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<0>

Legalizing node: t13: i16 = Constant<6>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<6>

Legalizing node: t3: i16 = Register %7
Ignoring node results
Legally typed node: t3: i16 = Register %7

Legalizing node: t1: i16 = Register %6
Ignoring node results
Legally typed node: t1: i16 = Register %6

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing node: t5: i32 = build_pair t4, t2
Analyzing result type: i32
Expand integer result: t5: i32 = build_pair t4, t2

Legalizing node: t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
Analyzing result type: i1
Promote integer result: t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
Creating new node: t15: i16 = setcc t5, Constant:i32<6>, seteq:ch

Legalizing node: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382876c0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
Promote integer operand: t10: ch = brcond t0, t8, BasicBlock:ch< 0x16b382876c0>
Creating new node: t16: i16 = any_extend t8

Legalizing node: t16: i16 = any_extend t8
Analyzing result type: i16
Legal result type
Analyzing operand: t8: i1 = setcc t5, Constant:i32<6>, seteq:ch
Promote integer operand: t16: i16 = any_extend t8
Replacing: t16: i16 = any_extend t8
     with: t15: i16 = setcc t5, Constant:i32<6>, seteq:ch

Legalizing node: t15: i16 = setcc t5, Constant:i32<6>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t5: i32 = build_pair t4, t2
Expand integer operand: t15: i16 = setcc t5, Constant:i32<6>, seteq:ch
Creating new node: t17: i16 = xor t4, Constant:i16<6>
Creating new node: t18: i16 = or t17, t2

Legalizing node: t17: i16 = xor t4, Constant:i16<6>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal operand
Analyzing operand: t13: i16 = Constant<6>
Legal operand
Legally typed node: t17: i16 = xor t4, Constant:i16<6>

Legalizing node: t18: i16 = or t17, t2
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16 = xor t4, Constant:i16<6>
Legal operand
Analyzing operand: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal operand
Legally typed node: t18: i16 = or t17, t2

Legalizing node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16 = or t17, t2
Legal operand
Analyzing operand: t14: i16 = Constant<0>
Legal operand
Analyzing operand: t7: ch = seteq
Legal operand
Legally typed node: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Legalizing node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382876c0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t9: ch = BasicBlock< 0x16b382876c0>
Legal operand
Legally typed node: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382876c0>

Legalizing node: t12: ch = br t10, BasicBlock:ch< 0x16b38282460>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382876c0>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282460>
Legal operand
Legally typed node: t12: ch = br t10, BasicBlock:ch< 0x16b38282460>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t10, BasicBlock:ch< 0x16b38282460>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.15 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<6>
        t18: i16 = or t17, t2
      t15: i16 = setcc t18, Constant:i16<0>, seteq:ch
    t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382876c0>
  t12: ch = br t10, BasicBlock:ch< 0x16b38282460>



Combining: t18: i16 = or t17, t2

Combining: t17: i16 = xor t4, Constant:i16<6>

Combining: t15: i16 = setcc t18, Constant:i16<0>, seteq:ch

Combining: t14: i16 = Constant<0>

Combining: t13: i16 = Constant<6>

Combining: t12: ch = br t10, BasicBlock:ch< 0x16b38282460>

Combining: t11: ch = BasicBlock< 0x16b38282460>

Combining: t10: ch = brcond t0, t15, BasicBlock:ch< 0x16b382876c0>
Creating new node: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382876c0>
 ... into: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382876c0>

Combining: t18: i16 = or t17, t2

Combining: t14: i16 = Constant<0>

Combining: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382876c0>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b38282460>

Combining: t9: ch = BasicBlock< 0x16b382876c0>

Combining: t7: ch = seteq

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Combining: t3: i16 = Register %7

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Combining: t1: i16 = Register %6

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.15 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
          t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
        t17: i16 = xor t4, Constant:i16<6>
      t18: i16 = or t17, t2
    t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382876c0>
  t12: ch = br t19, BasicBlock:ch< 0x16b38282460>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b38282460>
Legal node: nothing to do

Legalizing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382876c0>
Trying custom legalization
Creating new node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Creating constant: t21: i16 = Constant<1>
Creating new node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20
Successfully custom legalized node
 ... replacing: t19: ch = br_cc t0, seteq:ch, t18, Constant:i16<0>, BasicBlock:ch< 0x16b382876c0>
     with:      t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Legalizing: t17: i16 = xor t4, Constant:i16<6>
Legal node: nothing to do

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<6>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282460>
Legal node: nothing to do

Legalizing: t9: ch = BasicBlock< 0x16b382876c0>
Legal node: nothing to do

Legalizing: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20
Legal node: nothing to do

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.15 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<6>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282460>



Legalizing: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20
Legal node: nothing to do

Combining: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20

Legalizing: t21: i16 = Constant<1>
Legal node: nothing to do

Combining: t21: i16 = Constant<1>

Legalizing: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Legal node: nothing to do

Combining: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

Legalizing: t12: ch = br t22, BasicBlock:ch< 0x16b38282460>
Legal node: nothing to do

Combining: t12: ch = br t22, BasicBlock:ch< 0x16b38282460>

Legalizing: t18: i16 = or t17, t2
Legal node: nothing to do

Combining: t18: i16 = or t17, t2

Legalizing: t17: i16 = xor t4, Constant:i16<6>
Legal node: nothing to do

Combining: t17: i16 = xor t4, Constant:i16<6>

Legalizing: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Legal node: nothing to do

Combining: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

Legalizing: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Legal node: nothing to do

Combining: t2: i16,ch = CopyFromReg t0, Register:i16 %6

Legalizing: t14: i16 = Constant<0>
Legal node: nothing to do

Combining: t14: i16 = Constant<0>

Legalizing: t13: i16 = Constant<6>
Legal node: nothing to do

Combining: t13: i16 = Constant<6>

Legalizing: t11: ch = BasicBlock< 0x16b38282460>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282460>

Legalizing: t9: ch = BasicBlock< 0x16b382876c0>
Legal node: nothing to do

Combining: t9: ch = BasicBlock< 0x16b382876c0>

Legalizing: t3: i16 = Register %7

Combining: t3: i16 = Register %7

Legalizing: t1: i16 = Register %6

Combining: t1: i16 = Register %6

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.15 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = xor t4, Constant:i16<6>
        t18: i16 = or t17, t2
      t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
    t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20
  t12: ch = br t22, BasicBlock:ch< 0x16b38282460>


===== Instruction selection begins: %bb.15 ''

ISEL: Starting selection on root node: t12: ch = br t22, BasicBlock:ch< 0x16b38282460>
Selecting: t12: ch = br t22, BasicBlock:ch< 0x16b38282460>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b38282460>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20
Selecting: t22: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876c0>, Constant:i16<1>, t20

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t22: ch = JEI BasicBlock:ch< 0x16b382876c0>, t0, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>
Selecting: t20: glue = SymphonyISD::CMP t18, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t20: i16,glue = CMPI t18, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16 = or t17, t2
Selecting: t18: i16 = or t17, t2

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t18: i16 = ORR t17, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t17: i16 = xor t4, Constant:i16<6>
Selecting: t17: i16 = xor t4, Constant:i16<6>

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
Creating constant: t24: i16 = TargetConstant<6>
  Morphed node: t17: i16 = XORI t4, TargetConstant:i16<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
Selecting: t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %6
Selecting: t2: i16,ch = CopyFromReg t0, Register:i16 %6


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282460>
Selecting: t11: ch = BasicBlock< 0x16b38282460>


ISEL: Starting selection on root node: t9: ch = BasicBlock< 0x16b382876c0>
Selecting: t9: ch = BasicBlock< 0x16b382876c0>


ISEL: Starting selection on root node: t3: i16 = Register %7
Selecting: t3: i16 = Register %7


ISEL: Starting selection on root node: t1: i16 = Register %6
Selecting: t1: i16 = Register %6


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.15 'do_calc:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %6
            t4: i16,ch = CopyFromReg t2:1, Register:i16 %7
          t17: i16 = XORI t4, TargetConstant:i16<6>
        t18: i16 = ORR t17, t2
      t20: i16,glue = CMPI t18, TargetConstant:i16<0>
    t22: ch = JEI BasicBlock:ch< 0x16b382876c0>, t0, t20:1
  t12: ch = JMPI BasicBlock:ch< 0x16b38282460>, t22


********** List Scheduling %bb.15 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282460>, t22

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382876c0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t18: i16 = ORR t17, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(4): t17: i16 = XORI t4, TargetConstant:i16<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282460>, t22


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282460>, t22


Examining Available:
Height 1: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382876c0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382876c0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t18: i16 = ORR t17, t2


*** Scheduling [2]: SU(2): t18: i16 = ORR t17, t2


Examining Available:
Height 3: SU(4): t17: i16 = XORI t4, TargetConstant:i16<6>


*** Scheduling [3]: SU(4): t17: i16 = XORI t4, TargetConstant:i16<6>


Examining Available:
Height 4: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


*** Scheduling [4]: SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7


Examining Available:
Height 5: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6


*** Scheduling [5]: SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

*** Final schedule ***
SU(3): t2: i16,ch = CopyFromReg t0, Register:i16 %6

SU(5): t4: i16,ch = CopyFromReg t2:1, Register:i16 %7

SU(4): t17: i16 = XORI t4, TargetConstant:i16<6>

SU(2): t18: i16 = ORR t17, t2

SU(1): t22: ch = JEI BasicBlock:ch< 0x16b382876c0>, t0, t20:1

    t20: i16,glue = CMPI t18, TargetConstant:i16<0>

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b38282460>, t22


Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = sra t5, t7
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.7 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t8: i32 = zero_extend t7
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
        t9: i32 = sra t5, t7
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9

Combining: t9: i32 = sra t5, t7
Creating new node: t16: i32 = srl t5, t7
 ... into: t16: i32 = srl t5, t7

Combining: t16: i32 = srl t5, t7

Combining: t10: i16 = truncate t16

Combining: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t6: i16 = FrameIndex<3>

Combining: t5: i32 = zero_extend t4
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), zext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t5: i32 = zero_extend t4

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), zext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), zext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t16: i32 = srl t17, t7

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.7 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), zext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t17:1, t7:1
        t16: i32 = srl t17, t7
      t10: i16 = truncate t16
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), zext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), zext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating constant: t19: i16 = Constant<0>

Legalizing node: t16: i32 = srl t17, t7
Analyzing result type: i32
Expand integer result: t16: i32 = srl t17, t7
Creating new node: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7

Legalizing node: t10: i16 = truncate t16
Analyzing result type: i16
Legal result type
Analyzing operand: t16: i32 = srl t17, t7
Expand integer operand: t10: i16 = truncate t16

Legalizing node: t19: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t19: i16 = Constant<0>

Legalizing node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t18:1, t7:1
Analyzing result type: ch
Legal result type
Analyzing operand: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t18:1, t7:1

Legalizing node: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7
Analyzing result type: i16
Legal result type
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t19: i16 = Constant<0>
Legal operand
Analyzing operand: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t18:1, t7:1
Legal operand
Analyzing operand: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.7 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
      t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7
    t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7

Combining: t19: i16 = Constant<0>

Combining: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t18:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.7 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
      t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7
    t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t20, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t18:1, t7:1
Legal node: nothing to do

Legalizing: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7
Trying custom legalization
Creating constant: t21: i16 = Constant<16>
Creating new node: t22: i16 = sub Constant:i16<16>, t7
Creating new node: t23: i16 = srl t18, t7
Creating new node: t24: i16 = sub t7, Constant:i16<16>
Creating new node: t25: glue = SymphonyISD::CMP t24, Constant:i16<0>
Creating constant: t26: i8 = TargetConstant<12>
Creating new node: t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
Creating new node: t28: glue = SymphonyISD::CMP t24, Constant:i16<0>
Creating new node: t29: i16 = SymphonyISD::CMOV Constant:i16<0>, Constant:i16<0>, TargetConstant:i8<12>, t28
Creating new node: t30: i16,i16 = merge_values t27, t29
Successfully custom legalized node
 ... replacing: t20: i16,i16 = srl_parts t18, Constant:i16<0>, t7
     with:      t30: i16,i16 = merge_values t27, t29
      and:      t30: i16,i16 = merge_values t27, t29

Legalizing: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t19: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t30: i16,i16 = merge_values t27, t29
Trying to expand node
Successfully expanded node
 ... replacing: t30: i16,i16 = merge_values t27, t29
     with:      t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
      and:      t29: i16 = SymphonyISD::CMOV Constant:i16<0>, Constant:i16<0>, TargetConstant:i8<12>, t28

Legalizing: t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
Legal node: nothing to do

Legalizing: t26: i8 = TargetConstant<12>

Legalizing: t25: glue = SymphonyISD::CMP t24, Constant:i16<0>
Legal node: nothing to do

Legalizing: t24: i16 = sub t7, Constant:i16<16>
Legal node: nothing to do

Legalizing: t23: i16 = srl t18, t7
Legal node: nothing to do

Legalizing: t21: i16 = Constant<16>
Legal node: nothing to do

Legalized selection DAG: %bb.7 'do_calc:'
SelectionDAG has 18 nodes:
  t0: ch,glue = EntryToken
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
        t23: i16 = srl t18, t7
          t24: i16 = sub t7, Constant:i16<16>
        t25: glue = SymphonyISD::CMP t24, Constant:i16<0>
      t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
    t13: ch = store<(store (s16) into %ir.4)> t12, t27, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
Legal node: nothing to do

Combining: t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25

Legalizing: t26: i8 = TargetConstant<12>

Combining: t26: i8 = TargetConstant<12>

Legalizing: t25: glue = SymphonyISD::CMP t24, Constant:i16<0>
Legal node: nothing to do

Combining: t25: glue = SymphonyISD::CMP t24, Constant:i16<0>

Legalizing: t24: i16 = sub t7, Constant:i16<16>
Legal node: nothing to do

Combining: t24: i16 = sub t7, Constant:i16<16>
Creating constant: t31: i16 = Constant<-16>
Creating new node: t32: i16 = add t7, Constant:i16<-16>
 ... into: t32: i16 = add t7, Constant:i16<-16>

Legalizing: t32: i16 = add t7, Constant:i16<-16>
Legal node: nothing to do

Combining: t32: i16 = add t7, Constant:i16<-16>

Legalizing: t31: i16 = Constant<-16>
Legal node: nothing to do

Combining: t31: i16 = Constant<-16>

Legalizing: t25: glue = SymphonyISD::CMP t32, Constant:i16<0>
Legal node: nothing to do

Combining: t25: glue = SymphonyISD::CMP t32, Constant:i16<0>

Legalizing: t23: i16 = srl t18, t7
Legal node: nothing to do

Combining: t23: i16 = srl t18, t7

Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t27, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t27, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t18:1, t7:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t18:1, t7:1

Legalizing: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t19: i16 = Constant<0>
Legal node: nothing to do

Combining: t19: i16 = Constant<0>

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.7 'do_calc:'
SelectionDAG has 18 nodes:
  t0: ch,glue = EntryToken
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
        t23: i16 = srl t18, t7
          t32: i16 = add t7, Constant:i16<-16>
        t25: glue = SymphonyISD::CMP t32, Constant:i16<0>
      t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
    t13: ch = store<(store (s16) into %ir.4)> t12, t27, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.7 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t27, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t27, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t27, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25
Selecting: t27: i16 = SymphonyISD::CMOV t23, Constant:i16<0>, TargetConstant:i8<12>, t25

ISEL: Starting pattern match
  Initial Opcode index to 113
  Match failed at index 118
  Continuing at 140
Creating constant: t33: i16 = TargetConstant<0>
  Morphed node: t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25
ISEL: Match complete!

ISEL: Starting selection on root node: t25: glue = SymphonyISD::CMP t32, Constant:i16<0>
Selecting: t25: glue = SymphonyISD::CMP t32, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
  Morphed node: t25: i16,glue = CMPI t32, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t18:1, t7:1
Selecting: t12: ch = TokenFactor t18:1, t7:1


ISEL: Starting selection on root node: t23: i16 = srl t18, t7
Selecting: t23: i16 = srl t18, t7

ISEL: Starting pattern match
  Initial Opcode index to 676
  Match failed at index 681
  Continuing at 694
  Morphed node: t23: i16 = LSRR t18, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i16 = add t7, Constant:i16<-16>
Selecting: t32: i16 = add t7, Constant:i16<-16>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t34: i16 = TargetConstant<-16>
  Morphed node: t32: i16 = ADDI t7, TargetConstant:i16<-16>
ISEL: Match complete!

ISEL: Starting selection on root node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i8 = TargetConstant<12>
Selecting: t26: i8 = TargetConstant<12>


ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.7 'do_calc:'
SelectionDAG has 20 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
        t23: i16 = LSRR t18, t7
          t32: i16 = ADDI t7, TargetConstant:i16<-16>
        t25: i16,glue = CMPI t32, TargetConstant:i16<0>
      t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1
      t12: ch = TokenFactor t18:1, t7:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t27, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.7 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t27, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(10): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t18:1, t7:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(8): Data Latency=1
    SU(9): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(3): Data Latency=1
SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(9): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1
SU(7): t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1

    t25: i16,glue = CMPI t32, TargetConstant:i16<0>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t32: i16 = ADDI t7, TargetConstant:i16<-16>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(9): t23: i16 = LSRR t18, t7

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t27, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t27, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t18:1, t7:1

Height 2: SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1

    t25: i16,glue = CMPI t32, TargetConstant:i16<0>


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t18:1, t7:1


Examining Available:
Height 2: SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1

    t25: i16,glue = CMPI t32, TargetConstant:i16<0>


*** Scheduling [3]: SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1

    t25: i16,glue = CMPI t32, TargetConstant:i16<0>


*** Scheduling [4]: SU(7): t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1

    t25: i16,glue = CMPI t32, TargetConstant:i16<0>


Examining Available:
Height 5: SU(8): t32: i16 = ADDI t7, TargetConstant:i16<-16>

Height 5: SU(9): t23: i16 = LSRR t18, t7


*** Scheduling [5]: SU(8): t32: i16 = ADDI t7, TargetConstant:i16<-16>


Examining Available:
Height 5: SU(9): t23: i16 = LSRR t18, t7


*** Scheduling [6]: SU(9): t23: i16 = LSRR t18, t7


Examining Available:
Height 7: SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 7: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 8: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 7: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [8]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 7: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [9]: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 10: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [10]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(9): t23: i16 = LSRR t18, t7

SU(8): t32: i16 = ADDI t7, TargetConstant:i16<-16>

SU(7): t27: i16 = CMOVPseudo t23, TargetConstant:i16<0>, TargetConstant:i8<12>, t25:1

    t25: i16,glue = CMPI t32, TargetConstant:i16<0>

SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t18:1, t7:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t27, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = shl t5, t7
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.6 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t8: i32 = zero_extend t7
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
        t9: i32 = shl t5, t7
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9
Creating new node: t16: i32 = any_extend t4

Replacing.2 t5: i32 = zero_extend t4

With: t16: i32 = any_extend t4


Combining: t16: i32 = any_extend t4
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t16: i32 = any_extend t4

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t10: i16 = truncate t9

Combining: t9: i32 = shl t17, t7

Combining: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.6 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t17:1, t7:1
        t9: i32 = shl t17, t7
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: i32 = shl t17, t7
Analyzing result type: i32
Expand integer result: t9: i32 = shl t17, t7
Creating new node: t19: i16,i16 = shl_parts t18, undef:i16, t7

Legalizing node: t10: i16 = truncate t9
Analyzing result type: i16
Legal result type
Analyzing operand: t9: i32 = shl t17, t7
Expand integer operand: t10: i16 = truncate t9

Legalizing node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t18:1, t7:1
Analyzing result type: ch
Legal result type
Analyzing operand: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t18:1, t7:1

Legalizing node: t19: i16,i16 = shl_parts t18, undef:i16, t7
Analyzing result type: i16
Legal result type
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Analyzing operand: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t19: i16,i16 = shl_parts t18, undef:i16, t7

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t18:1, t7:1
Legal operand
Analyzing operand: t19: i16,i16 = shl_parts t18, undef:i16, t7
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.6 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
      t19: i16,i16 = shl_parts t18, undef:i16, t7
    t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t19: i16,i16 = shl_parts t18, undef:i16, t7

Combining: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t18:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.6 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
      t19: i16,i16 = shl_parts t18, undef:i16, t7
    t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t19, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t18:1, t7:1
Legal node: nothing to do

Legalizing: t19: i16,i16 = shl_parts t18, undef:i16, t7
Trying custom legalization
Creating constant: t20: i16 = Constant<16>
Creating new node: t21: i16 = sub Constant:i16<16>, t7
Creating new node: t22: i16 = srl t18, t21
Creating constant: t23: i16 = Constant<0>
Creating new node: t24: i16 = sub t7, Constant:i16<16>
Creating new node: t25: i16 = shl t18, t24
Creating new node: t26: glue = SymphonyISD::CMP t24, Constant:i16<0>
Creating constant: t27: i8 = TargetConstant<12>
Creating new node: t28: i16 = SymphonyISD::CMOV t22, t25, TargetConstant:i8<12>, t26
Creating new node: t29: glue = SymphonyISD::CMP t24, Constant:i16<0>
Creating new node: t30: i16 = shl t18, t7
Creating constant: t31: i16 = TargetConstant<0>
Creating new node: t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
Creating new node: t33: i16,i16 = merge_values t32, t28
Successfully custom legalized node
 ... replacing: t19: i16,i16 = shl_parts t18, undef:i16, t7
     with:      t33: i16,i16 = merge_values t32, t28
      and:      t33: i16,i16 = merge_values t32, t28

Legalizing: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t33: i16,i16 = merge_values t32, t28
Trying to expand node
Successfully expanded node
 ... replacing: t33: i16,i16 = merge_values t32, t28
     with:      t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
      and:      t28: i16 = SymphonyISD::CMOV t22, t25, TargetConstant:i8<12>, t26

Legalizing: t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
Legal node: nothing to do

Legalizing: t31: i16 = TargetConstant<0>

Legalizing: t30: i16 = shl t18, t7
Legal node: nothing to do

Legalizing: t29: glue = SymphonyISD::CMP t24, Constant:i16<0>
Legal node: nothing to do

Legalizing: t27: i8 = TargetConstant<12>

Legalizing: t24: i16 = sub t7, Constant:i16<16>
Legal node: nothing to do

Legalizing: t23: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t20: i16 = Constant<16>
Legal node: nothing to do

Legalized selection DAG: %bb.6 'do_calc:'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
        t30: i16 = shl t18, t7
          t24: i16 = sub t7, Constant:i16<16>
        t29: glue = SymphonyISD::CMP t24, Constant:i16<0>
      t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
    t13: ch = store<(store (s16) into %ir.4)> t12, t32, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
Legal node: nothing to do

Combining: t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29

Legalizing: t31: i16 = TargetConstant<0>

Combining: t31: i16 = TargetConstant<0>

Legalizing: t30: i16 = shl t18, t7
Legal node: nothing to do

Combining: t30: i16 = shl t18, t7

Legalizing: t29: glue = SymphonyISD::CMP t24, Constant:i16<0>
Legal node: nothing to do

Combining: t29: glue = SymphonyISD::CMP t24, Constant:i16<0>

Legalizing: t27: i8 = TargetConstant<12>

Combining: t27: i8 = TargetConstant<12>

Legalizing: t24: i16 = sub t7, Constant:i16<16>
Legal node: nothing to do

Combining: t24: i16 = sub t7, Constant:i16<16>
Creating constant: t34: i16 = Constant<-16>
Creating new node: t35: i16 = add t7, Constant:i16<-16>
 ... into: t35: i16 = add t7, Constant:i16<-16>

Legalizing: t35: i16 = add t7, Constant:i16<-16>
Legal node: nothing to do

Combining: t35: i16 = add t7, Constant:i16<-16>

Legalizing: t34: i16 = Constant<-16>
Legal node: nothing to do

Combining: t34: i16 = Constant<-16>

Legalizing: t29: glue = SymphonyISD::CMP t35, Constant:i16<0>
Legal node: nothing to do

Combining: t29: glue = SymphonyISD::CMP t35, Constant:i16<0>

Legalizing: t23: i16 = Constant<0>
Legal node: nothing to do

Combining: t23: i16 = Constant<0>

Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t32, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t32, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t18:1, t7:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t18:1, t7:1

Legalizing: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.6 'do_calc:'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
  t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t18:1, t7:1
        t30: i16 = shl t18, t7
          t35: i16 = add t7, Constant:i16<-16>
        t29: glue = SymphonyISD::CMP t35, Constant:i16<0>
      t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
    t13: ch = store<(store (s16) into %ir.4)> t12, t32, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.6 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t32, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t32, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t32, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
Selecting: t32: i16 = SymphonyISD::CMOV t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29

ISEL: Starting pattern match
  Initial Opcode index to 113
  Match failed at index 118
  Continuing at 140
  Match failed at index 143
  Continuing at 158
  Match failed at index 160
  Continuing at 176
  Morphed node: t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29
ISEL: Match complete!

ISEL: Starting selection on root node: t29: glue = SymphonyISD::CMP t35, Constant:i16<0>
Selecting: t29: glue = SymphonyISD::CMP t35, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
  Morphed node: t29: i16,glue = CMPI t35, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t18:1, t7:1
Selecting: t12: ch = TokenFactor t18:1, t7:1


ISEL: Starting selection on root node: t30: i16 = shl t18, t7
Selecting: t30: i16 = shl t18, t7

ISEL: Starting pattern match
  Initial Opcode index to 646
  Match failed at index 651
  Continuing at 664
  Morphed node: t30: i16 = LSLR t18, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t35: i16 = add t7, Constant:i16<-16>
Selecting: t35: i16 = add t7, Constant:i16<-16>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t36: i16 = TargetConstant<-16>
  Morphed node: t35: i16 = ADDI t7, TargetConstant:i16<-16>
ISEL: Match complete!

ISEL: Starting selection on root node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t18: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i16 = TargetConstant<0>
Selecting: t31: i16 = TargetConstant<0>


ISEL: Starting selection on root node: t27: i8 = TargetConstant<12>
Selecting: t27: i8 = TargetConstant<12>


ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.6 'do_calc:'
SelectionDAG has 20 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
        t30: i16 = LSLR t18, t7
          t35: i16 = ADDI t7, TargetConstant:i16<-16>
        t29: i16,glue = CMPI t35, TargetConstant:i16<0>
      t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1
      t12: ch = TokenFactor t18:1, t7:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t32, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.6 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t32, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(10): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t18:1, t7:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(8): Data Latency=1
    SU(9): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(3): Data Latency=1
SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(9): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1
SU(7): t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1

    t29: i16,glue = CMPI t35, TargetConstant:i16<0>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t35: i16 = ADDI t7, TargetConstant:i16<-16>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(9): t30: i16 = LSLR t18, t7

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t32, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t32, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t18:1, t7:1

Height 2: SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1

    t29: i16,glue = CMPI t35, TargetConstant:i16<0>


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t18:1, t7:1


Examining Available:
Height 2: SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1

    t29: i16,glue = CMPI t35, TargetConstant:i16<0>


*** Scheduling [3]: SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1

    t29: i16,glue = CMPI t35, TargetConstant:i16<0>


*** Scheduling [4]: SU(7): t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1

    t29: i16,glue = CMPI t35, TargetConstant:i16<0>


Examining Available:
Height 5: SU(8): t35: i16 = ADDI t7, TargetConstant:i16<-16>

Height 5: SU(9): t30: i16 = LSLR t18, t7


*** Scheduling [5]: SU(8): t35: i16 = ADDI t7, TargetConstant:i16<-16>


Examining Available:
Height 5: SU(9): t30: i16 = LSLR t18, t7


*** Scheduling [6]: SU(9): t30: i16 = LSLR t18, t7


Examining Available:
Height 7: SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 7: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 8: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 7: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [8]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 7: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [9]: SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 10: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [10]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t18: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t7: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(9): t30: i16 = LSLR t18, t7

SU(8): t35: i16 = ADDI t7, TargetConstant:i16<-16>

SU(7): t32: i16 = CMOVPseudo t30, TargetConstant:i16<0>, TargetConstant:i8<12>, t29:1

    t29: i16,glue = CMPI t35, TargetConstant:i16<0>

SU(10): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t18:1, t7:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t32, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = xor t5, t8
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.5 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
          t8: i32 = zero_extend t7
        t9: i32 = xor t5, t8
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9
Creating new node: t16: i32 = any_extend t7

Replacing.2 t8: i32 = zero_extend t7

With: t16: i32 = any_extend t7


Combining: t16: i32 = any_extend t7
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t16: i32 = any_extend t7

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t10: i16 = truncate t9
Creating new node: t18: i32 = any_extend t4

Replacing.2 t5: i32 = zero_extend t4

With: t18: i32 = any_extend t4


Combining: t18: i32 = any_extend t4
Creating new node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t18: i32 = any_extend t4

With: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t10: i16 = truncate t9

Combining: t9: i32 = xor t19, t17

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.5 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
  t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t19:1, t17:1
        t9: i32 = xor t19, t17
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: i32 = xor t19, t17
Analyzing result type: i32
Expand integer result: t9: i32 = xor t19, t17
Creating new node: t22: i16 = xor t21, t20
Creating constant: t23: i16 = Constant<0>

Legalizing node: t10: i16 = truncate t9
Analyzing result type: i16
Legal result type
Analyzing operand: t9: i32 = xor t19, t17
Expand integer operand: t10: i16 = truncate t9

Legalizing node: t23: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t23: i16 = Constant<0>

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t21:1, t20:1
Analyzing result type: ch
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t21:1, t20:1

Legalizing node: t22: i16 = xor t21, t20
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t22: i16 = xor t21, t20

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t21:1, t20:1
Legal operand
Analyzing operand: t22: i16 = xor t21, t20
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.5 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = xor t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t22: i16 = xor t21, t20

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t21:1, t20:1

Combining: t11: i16 = FrameIndex<0>

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.5 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = xor t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Legalizing: t22: i16 = xor t21, t20
Legal node: nothing to do

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.5 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = xor t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t21:1, t20:1

Legalizing: t22: i16 = xor t21, t20
Legal node: nothing to do

Combining: t22: i16 = xor t21, t20

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.5 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = xor t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.5 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t22, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t21:1, t20:1
Selecting: t12: ch = TokenFactor t21:1, t20:1


ISEL: Starting selection on root node: t22: i16 = xor t21, t20
Selecting: t22: i16 = xor t21, t20

ISEL: Starting pattern match
  Initial Opcode index to 4
  Match failed at index 7
  Continuing at 81
  Match failed at index 87
  Continuing at 100
  Morphed node: t22: i16 = XORR t21, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t25: i16 = TargetConstant<0>
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.5 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t22: i16 = XORR t21, t20
      t12: ch = TokenFactor t21:1, t20:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.5 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t21:1, t20:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t22: i16 = XORR t21, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t21:1, t20:1

Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = XORR t21, t20


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t21:1, t20:1


Examining Available:
Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = XORR t21, t20


*** Scheduling [3]: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t22: i16 = XORR t21, t20


*** Scheduling [4]: SU(7): t22: i16 = XORR t21, t20


Examining Available:
Height 5: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [5]: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 6: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [6]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 8: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [8]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(7): t22: i16 = XORR t21, t20

SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t21:1, t20:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = and t5, t8
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.4 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
          t8: i32 = zero_extend t7
        t9: i32 = and t5, t8
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9
Creating new node: t16: i32 = any_extend t7

Replacing.2 t8: i32 = zero_extend t7

With: t16: i32 = any_extend t7


Combining: t16: i32 = any_extend t7
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t16: i32 = any_extend t7

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t10: i16 = truncate t9
Creating new node: t18: i32 = any_extend t4

Replacing.2 t5: i32 = zero_extend t4

With: t18: i32 = any_extend t4


Combining: t18: i32 = any_extend t4
Creating new node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t18: i32 = any_extend t4

With: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t10: i16 = truncate t9

Combining: t9: i32 = and t19, t17

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.4 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
  t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t19:1, t17:1
        t9: i32 = and t19, t17
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: i32 = and t19, t17
Analyzing result type: i32
Expand integer result: t9: i32 = and t19, t17
Creating new node: t22: i16 = and t21, t20
Creating constant: t23: i16 = Constant<0>

Legalizing node: t10: i16 = truncate t9
Analyzing result type: i16
Legal result type
Analyzing operand: t9: i32 = and t19, t17
Expand integer operand: t10: i16 = truncate t9

Legalizing node: t23: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t23: i16 = Constant<0>

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t21:1, t20:1
Analyzing result type: ch
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t21:1, t20:1

Legalizing node: t22: i16 = and t21, t20
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t22: i16 = and t21, t20

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t21:1, t20:1
Legal operand
Analyzing operand: t22: i16 = and t21, t20
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.4 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = and t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t22: i16 = and t21, t20

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t21:1, t20:1

Combining: t11: i16 = FrameIndex<0>

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.4 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = and t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Legalizing: t22: i16 = and t21, t20
Legal node: nothing to do

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.4 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = and t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t21:1, t20:1

Legalizing: t22: i16 = and t21, t20
Legal node: nothing to do

Combining: t22: i16 = and t21, t20

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.4 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = and t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.4 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t22, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t21:1, t20:1
Selecting: t12: ch = TokenFactor t21:1, t20:1


ISEL: Starting selection on root node: t22: i16 = and t21, t20
Selecting: t22: i16 = and t21, t20

ISEL: Starting pattern match
  Initial Opcode index to 556
  Match failed at index 561
  Continuing at 574
  Morphed node: t22: i16 = ANDR t21, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t25: i16 = TargetConstant<0>
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.4 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t22: i16 = ANDR t21, t20
      t12: ch = TokenFactor t21:1, t20:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.4 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t21:1, t20:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t22: i16 = ANDR t21, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t21:1, t20:1

Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = ANDR t21, t20


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t21:1, t20:1


Examining Available:
Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = ANDR t21, t20


*** Scheduling [3]: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t22: i16 = ANDR t21, t20


*** Scheduling [4]: SU(7): t22: i16 = ANDR t21, t20


Examining Available:
Height 5: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [5]: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 6: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [6]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 8: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [8]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(7): t22: i16 = ANDR t21, t20

SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t21:1, t20:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = or t5, t8
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.3 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
          t8: i32 = zero_extend t7
        t9: i32 = or t5, t8
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9
Creating new node: t16: i32 = any_extend t7

Replacing.2 t8: i32 = zero_extend t7

With: t16: i32 = any_extend t7


Combining: t16: i32 = any_extend t7
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t16: i32 = any_extend t7

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t10: i16 = truncate t9
Creating new node: t18: i32 = any_extend t4

Replacing.2 t5: i32 = zero_extend t4

With: t18: i32 = any_extend t4


Combining: t18: i32 = any_extend t4
Creating new node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t18: i32 = any_extend t4

With: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t10: i16 = truncate t9

Combining: t9: i32 = or t19, t17

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.3 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
  t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t19:1, t17:1
        t9: i32 = or t19, t17
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: i32 = or t19, t17
Analyzing result type: i32
Expand integer result: t9: i32 = or t19, t17
Creating new node: t22: i16 = or t21, t20
Creating constant: t23: i16 = Constant<-1>

Legalizing node: t10: i16 = truncate t9
Analyzing result type: i16
Legal result type
Analyzing operand: t9: i32 = or t19, t17
Expand integer operand: t10: i16 = truncate t9

Legalizing node: t23: i16 = Constant<-1>
Analyzing result type: i16
Legal result type
Legally typed node: t23: i16 = Constant<-1>

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t21:1, t20:1
Analyzing result type: ch
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t21:1, t20:1

Legalizing node: t22: i16 = or t21, t20
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t22: i16 = or t21, t20

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t21:1, t20:1
Legal operand
Analyzing operand: t22: i16 = or t21, t20
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.3 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = or t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t22: i16 = or t21, t20

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t21:1, t20:1

Combining: t11: i16 = FrameIndex<0>

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.3 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = or t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Legalizing: t22: i16 = or t21, t20
Legal node: nothing to do

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.3 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = or t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t21:1, t20:1

Legalizing: t22: i16 = or t21, t20
Legal node: nothing to do

Combining: t22: i16 = or t21, t20

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.3 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = or t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.3 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t22, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t21:1, t20:1
Selecting: t12: ch = TokenFactor t21:1, t20:1


ISEL: Starting selection on root node: t22: i16 = or t21, t20
Selecting: t22: i16 = or t21, t20

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t22: i16 = ORR t21, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t25: i16 = TargetConstant<0>
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.3 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t22: i16 = ORR t21, t20
      t12: ch = TokenFactor t21:1, t20:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.3 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t21:1, t20:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t22: i16 = ORR t21, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t21:1, t20:1

Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = ORR t21, t20


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t21:1, t20:1


Examining Available:
Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = ORR t21, t20


*** Scheduling [3]: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t22: i16 = ORR t21, t20


*** Scheduling [4]: SU(7): t22: i16 = ORR t21, t20


Examining Available:
Height 5: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [5]: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 6: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [6]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 8: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [8]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(7): t22: i16 = ORR t21, t20

SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t21:1, t20:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = sub nsw t5, t8
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.2 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
          t8: i32 = zero_extend t7
        t9: i32 = sub nsw t5, t8
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9
Creating new node: t16: i32 = any_extend t7

Replacing.2 t8: i32 = zero_extend t7

With: t16: i32 = any_extend t7


Combining: t16: i32 = any_extend t7
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t16: i32 = any_extend t7

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t10: i16 = truncate t9
Creating new node: t18: i32 = any_extend t4

Replacing.2 t5: i32 = zero_extend t4

With: t18: i32 = any_extend t4


Combining: t18: i32 = any_extend t4
Creating new node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t18: i32 = any_extend t4

With: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t10: i16 = truncate t9

Combining: t9: i32 = sub t19, t17

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.2 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
  t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t19:1, t17:1
        t9: i32 = sub t19, t17
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: i32 = sub t19, t17
Analyzing result type: i32
Expand integer result: t9: i32 = sub t19, t17
Creating new node: t22: i16 = sub t21, t20
Creating new node: t24: i16 = setcc t21, t20, setult:ch
Creating constant: t25: i16 = Constant<0>
Creating constant: t26: i16 = Constant<1>
Creating new node: t27: i16 = select t24, Constant:i16<1>, Constant:i16<0>

Legalizing node: t10: i16 = truncate t9
Analyzing result type: i16
Legal result type
Analyzing operand: t9: i32 = sub t19, t17
Expand integer operand: t10: i16 = truncate t9

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t21:1, t20:1
Analyzing result type: ch
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t21:1, t20:1

Legalizing node: t22: i16 = sub t21, t20
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t22: i16 = sub t21, t20

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t21:1, t20:1
Legal operand
Analyzing operand: t22: i16 = sub t21, t20
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.2 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = sub t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t22: i16 = sub t21, t20

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t21:1, t20:1

Combining: t11: i16 = FrameIndex<0>

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.2 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = sub t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Legalizing: t22: i16 = sub t21, t20
Legal node: nothing to do

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.2 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = sub t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t21:1, t20:1

Legalizing: t22: i16 = sub t21, t20
Legal node: nothing to do

Combining: t22: i16 = sub t21, t20

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.2 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = sub t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.2 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t22, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t21:1, t20:1
Selecting: t12: ch = TokenFactor t21:1, t20:1


ISEL: Starting selection on root node: t22: i16 = sub t21, t20
Selecting: t22: i16 = sub t21, t20

ISEL: Starting pattern match
  Initial Opcode index to 616
  Match failed at index 621
  Continuing at 634
  Morphed node: t22: i16 = SUBR t21, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t29: i16 = TargetConstant<0>
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.2 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t22: i16 = SUBR t21, t20
      t12: ch = TokenFactor t21:1, t20:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.2 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t21:1, t20:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t22: i16 = SUBR t21, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t21:1, t20:1

Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = SUBR t21, t20


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t21:1, t20:1


Examining Available:
Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = SUBR t21, t20


*** Scheduling [3]: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t22: i16 = SUBR t21, t20


*** Scheduling [4]: SU(7): t22: i16 = SUBR t21, t20


Examining Available:
Height 5: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [5]: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 6: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [6]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 8: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [8]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(7): t22: i16 = SUBR t21, t20

SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t21:1, t20:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating new node: t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: i32 = zero_extend t7
Creating new node: t9: i32 = add nsw t5, t8
Creating new node: t10: i16 = truncate t9
Creating new node: t12: ch = TokenFactor t4:1, t7:1
Creating new node: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
Creating new node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.1 'do_calc:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t7: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t4:1, t7:1
          t5: i32 = zero_extend t4
          t8: i32 = zero_extend t7
        t9: i32 = add nsw t5, t8
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t4:1, t7:1

Combining: t11: i16 = FrameIndex<0>

Combining: t10: i16 = truncate t9
Creating new node: t16: i32 = any_extend t7

Replacing.2 t8: i32 = zero_extend t7

With: t16: i32 = any_extend t7


Combining: t16: i32 = any_extend t7
Creating new node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t16: i32 = any_extend t7

With: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t10: i16 = truncate t9
Creating new node: t18: i32 = any_extend t4

Replacing.2 t5: i32 = zero_extend t4

With: t18: i32 = any_extend t4


Combining: t18: i32 = any_extend t4
Creating new node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t18: i32 = any_extend t4

With: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values

Combining: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16

Combining: t10: i16 = truncate t9

Combining: t9: i32 = add t19, t17

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.1 'do_calc:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
  t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t19:1, t17:1
        t9: i32 = add t19, t17
      t10: i16 = truncate t9
    t13: ch = store<(store (s16) into %ir.4)> t12, t10, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t14: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t11: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = FrameIndex<0>

Legalizing node: t6: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<3>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t17: i32,ch = load<(dereferenceable load (s16) from %ir.7), anyext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t6: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i32
Expand integer result: t19: i32,ch = load<(dereferenceable load (s16) from %ir.6), anyext from i16> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: i32 = add t19, t17
Analyzing result type: i32
Expand integer result: t9: i32 = add t19, t17
Creating new node: t22: i16 = add t21, t20
Creating new node: t24: i16 = setcc t22, t21, setult:ch
Creating constant: t25: i16 = Constant<0>
Creating constant: t26: i16 = Constant<1>
Creating new node: t27: i16 = select t24, Constant:i16<1>, Constant:i16<0>

Legalizing node: t10: i16 = truncate t9
Analyzing result type: i16
Legal result type
Analyzing operand: t9: i32 = add t19, t17
Expand integer operand: t10: i16 = truncate t9

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = TokenFactor t21:1, t20:1
Analyzing result type: ch
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t21:1, t20:1

Legalizing node: t22: i16 = add t21, t20
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t22: i16 = add t21, t20

Legalizing node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t21:1, t20:1
Legal operand
Analyzing operand: t22: i16 = add t21, t20
Legal operand
Analyzing operand: t11: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t14: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.1 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = add t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Combining: t22: i16 = add t21, t20

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Combining: t12: ch = TokenFactor t21:1, t20:1

Combining: t11: i16 = FrameIndex<0>

Combining: t6: i16 = FrameIndex<3>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.1 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = add t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Legalizing: t22: i16 = add t21, t20
Legal node: nothing to do

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.1 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = add t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>



Legalizing: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

Legalizing: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

Legalizing: t12: ch = TokenFactor t21:1, t20:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t21:1, t20:1

Legalizing: t22: i16 = add t21, t20
Legal node: nothing to do

Combining: t22: i16 = add t21, t20

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t14: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t14: ch = BasicBlock< 0x16b382825a8>

Legalizing: t11: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t11: i16 = FrameIndex<0>

Legalizing: t6: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<3>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.1 'do_calc:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
      t12: ch = TokenFactor t21:1, t20:1
      t22: i16 = add t21, t20
    t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
  t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.1 ''

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>
Selecting: t15: ch = br t13, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.4)> t12, t22, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, t22, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t21:1, t20:1
Selecting: t12: ch = TokenFactor t21:1, t20:1


ISEL: Starting selection on root node: t22: i16 = add t21, t20
Selecting: t22: i16 = add t21, t20

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t22: i16 = ADDR t21, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t20: i16,ch = load<(dereferenceable load (s16) from %ir.7)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = BasicBlock< 0x16b382825a8>
Selecting: t14: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t11: i16 = FrameIndex<0>
Selecting: t11: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t29: i16 = TargetConstant<0>
  Morphed node: t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<3>
Selecting: t6: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.1 'do_calc:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
  t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0
    t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0
      t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t22: i16 = ADDR t21, t20
      t12: ch = TokenFactor t21:1, t20:1
    t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12
  t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


********** List Scheduling %bb.1 '' **********
SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t12: ch = TokenFactor t21:1, t20:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t22: i16 = ADDR t21, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


*** Scheduling [0]: SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Examining Available:
Height 1: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


*** Scheduling [1]: SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12


Examining Available:
Height 1: SU(2): t12: ch = TokenFactor t21:1, t20:1

Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = ADDR t21, t20


*** Scheduling [2]: SU(2): t12: ch = TokenFactor t21:1, t20:1


Examining Available:
Height 2: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(7): t22: i16 = ADDR t21, t20


*** Scheduling [3]: SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(7): t22: i16 = ADDR t21, t20


*** Scheduling [4]: SU(7): t22: i16 = ADDR t21, t20


Examining Available:
Height 5: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [5]: SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0


Examining Available:
Height 6: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [6]: SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


*** Scheduling [7]: SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0


Examining Available:
Height 8: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [8]: SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(6): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(5): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t1, t0

SU(4): t6: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.7)> t6, t0

SU(7): t22: i16 = ADDR t21, t20

SU(8): t11: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(2): t12: ch = TokenFactor t21:1, t20:1

SU(1): t13: ch = STORE16R<Mem:(store (s16) into %ir.4)> t11, t22, t12

SU(0): t15: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t13


Total amount of phi nodes to update: 0
Creating constant: t1: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Creating new node: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>

Initial selection DAG: %bb.8 'do_calc:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>



Combining: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>

Combining: t5: ch = BasicBlock< 0x16b382825a8>

Combining: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Combining: t3: i16 = undef

Combining: t2: i16 = FrameIndex<0>

Combining: t1: i16 = Constant<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.8 'do_calc:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>



Legalizing node: t5: ch = BasicBlock< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Legally typed node: t5: ch = BasicBlock< 0x16b382825a8>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t2: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<0>

Legalizing node: t1: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = Constant<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing node: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t5: ch = BasicBlock< 0x16b382825a8>
Legal operand
Legally typed node: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>

Legalizing node: t65535: ch = handlenode t6
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>
Legal operand
Legally typed node: t65535: ch = handlenode t6

Type-legalized selection DAG: %bb.8 'do_calc:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>



Legalizing: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t5: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t1: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.8 'do_calc:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>



Legalizing: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>
Legal node: nothing to do

Combining: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>

Legalizing: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing: t5: ch = BasicBlock< 0x16b382825a8>
Legal node: nothing to do

Combining: t5: ch = BasicBlock< 0x16b382825a8>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<0>

Legalizing: t1: i16 = Constant<0>
Legal node: nothing to do

Combining: t1: i16 = Constant<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.8 'do_calc:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
  t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>


===== Instruction selection begins: %bb.8 ''

ISEL: Starting selection on root node: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>
Selecting: t6: ch = br t4, BasicBlock:ch< 0x16b382825a8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t6: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t4
ISEL: Match complete!

ISEL: Starting selection on root node: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Selecting: t4: ch = store<(store (s16) into %ir.4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t4: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<0>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: ch = BasicBlock< 0x16b382825a8>
Selecting: t5: ch = BasicBlock< 0x16b382825a8>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<0>
Selecting: t2: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t8: i16 = TargetConstant<0>
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i16 = Constant<0>
Selecting: t1: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
  Morphed node: t1: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.8 'do_calc:'
SelectionDAG has 8 nodes:
      t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
      t1: i16 = MOVI TargetConstant:i16<0>
      t0: ch,glue = EntryToken
    t4: ch = STORE16R<Mem:(store (s16) into %ir.4)> t2, t1, t0
  t6: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t4


********** List Scheduling %bb.8 '' **********
SU(0): t6: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t4

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t4: ch = STORE16R<Mem:(store (s16) into %ir.4)> t2, t1, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t1: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t6: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t4


*** Scheduling [0]: SU(0): t6: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t4


Examining Available:
Height 1: SU(1): t4: ch = STORE16R<Mem:(store (s16) into %ir.4)> t2, t1, t0


*** Scheduling [1]: SU(1): t4: ch = STORE16R<Mem:(store (s16) into %ir.4)> t2, t1, t0


Examining Available:
Height 2: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 2: SU(2): t1: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [2]: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t1: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [3]: SU(2): t1: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(2): t1: i16 = MOVI TargetConstant:i16<0>

SU(3): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(1): t4: ch = STORE16R<Mem:(store (s16) into %ir.4)> t2, t1, t0

SU(0): t6: ch = JMPI BasicBlock:ch< 0x16b382825a8>, t4


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
Creating new node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Creating new node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Initial selection DAG: %bb.9 'do_calc:'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Combining: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Combining: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

Combining: t5: i16 = Register $r1

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.9 'do_calc:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Legalizing node: t5: i16 = Register $r1
Ignoring node results
Legally typed node: t5: i16 = Register $r1

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16

Legalizing node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

Legalizing node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal operand
Legally typed node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.9 'do_calc:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Legalizing: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal node: nothing to do

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
Legalizing non-extending load operation

Legalizing: t5: i16 = Register $r1

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.9 'do_calc:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1



Legalizing: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Legal node: nothing to do

Combining: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16

Legalizing: t5: i16 = Register $r1

Combining: t5: i16 = Register $r1

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.9 'do_calc:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
    t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1


===== Instruction selection begins: %bb.9 ''

ISEL: Starting selection on root node: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1
Selecting: t7: ch = SymphonyISD::RET_GLUE t6, Register:i16 $r1, t6:1

ISEL: Starting pattern match
  Initial Opcode index to 902
  Morphed node: t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
Selecting: t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i16 = Register $r1
Selecting: t5: i16 = Register $r1


ISEL: Starting selection on root node: t1: i16 = FrameIndex<0>
Selecting: t1: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t9: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.9 'do_calc:'
SelectionDAG has 8 nodes:
  t0: ch,glue = EntryToken
      t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
    t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
  t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4
  t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1


********** List Scheduling %bb.9 '' **********
SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


*** Scheduling [0]: SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


Examining Available:
Height 1: SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [1]: SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 2: SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


*** Scheduling [2]: SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

*** Final schedule ***
SU(2): t1: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(1): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(0): t7: i16,ch = SymphonyRet Register:i16 $r1, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i16 $r1, t4


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function do_calc: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2, align=2, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=2, align=2, at location [SP]
  fi#3: size=2, align=2, at location [SP]
Function Live Ins: $r1 in %0, $r2 in %1, $r3 in %2, $r4 in %3

bb.0 (%ir-block.3):
  successors: %bb.1, %bb.10
  liveins: $r1, $r2, $r3, $r4
  %3:gpr = COPY $r4
  %2:gpr = COPY $r3
  %1:gpr = COPY $r2
  %0:gpr = COPY $r1
  %5:gpr = COPY %1:gpr
  %4:gpr = COPY %0:gpr
  %8:gpr = ADDI %stack.1, 0
  STORE16R %8:gpr, %0:gpr :: (store (s16) into %ir.5, align 4)
  %9:gpr = disjoint ORI %8:gpr, 2
  STORE16R %9:gpr, %1:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  %10:gpr = ADDI %stack.2, 0
  STORE16R killed %10:gpr, %2:gpr :: (store (s16) into %ir.6)
  %11:gpr = ADDI %stack.3, 0
  STORE16R killed %11:gpr, %3:gpr :: (store (s16) into %ir.7)
  %6:gpr = LOAD16R %8:gpr :: (dereferenceable load (s16) from %ir.5, align 4)
  %7:gpr = LOAD16R %9:gpr :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
  %12:gpr = ORR %7:gpr, %6:gpr
  CMPI killed %12:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.10, implicit $flags

bb.10 (%ir-block.3):
; predecessors: %bb.0
  successors: %bb.2, %bb.11

  %13:gpr = XORI %7:gpr, 1
  %14:gpr = ORR killed %13:gpr, %6:gpr
  CMPI killed %14:gpr, 0, implicit-def $flags
  JEI %bb.2, implicit $flags
  JMPI %bb.11, implicit $flags

bb.11 (%ir-block.3):
; predecessors: %bb.10
  successors: %bb.3, %bb.12

  %15:gpr = XORI %7:gpr, 2
  %16:gpr = ORR killed %15:gpr, %6:gpr
  CMPI killed %16:gpr, 0, implicit-def $flags
  JEI %bb.3, implicit $flags
  JMPI %bb.12, implicit $flags

bb.12 (%ir-block.3):
; predecessors: %bb.11
  successors: %bb.4, %bb.13

  %17:gpr = XORI %7:gpr, 3
  %18:gpr = ORR killed %17:gpr, %6:gpr
  CMPI killed %18:gpr, 0, implicit-def $flags
  JEI %bb.4, implicit $flags
  JMPI %bb.13, implicit $flags

bb.13 (%ir-block.3):
; predecessors: %bb.12
  successors: %bb.5, %bb.14

  %19:gpr = XORI %7:gpr, 4
  %20:gpr = ORR killed %19:gpr, %6:gpr
  CMPI killed %20:gpr, 0, implicit-def $flags
  JEI %bb.5, implicit $flags
  JMPI %bb.14, implicit $flags

bb.14 (%ir-block.3):
; predecessors: %bb.13
  successors: %bb.6, %bb.15

  %21:gpr = XORI %7:gpr, 5
  %22:gpr = ORR killed %21:gpr, %6:gpr
  CMPI killed %22:gpr, 0, implicit-def $flags
  JEI %bb.6, implicit $flags
  JMPI %bb.15, implicit $flags

bb.15 (%ir-block.3):
; predecessors: %bb.14
  successors: %bb.7, %bb.8

  %23:gpr = XORI %7:gpr, 6
  %24:gpr = ORR killed %23:gpr, %6:gpr
  CMPI killed %24:gpr, 0, implicit-def $flags
  JEI %bb.7, implicit $flags
  JMPI %bb.8, implicit $flags

bb.1 (%ir-block.9):
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %65:gpr = ADDI %stack.2, 0
  %66:gpr = LOAD16R killed %65:gpr :: (dereferenceable load (s16) from %ir.6)
  %67:gpr = ADDI %stack.3, 0
  %68:gpr = LOAD16R killed %67:gpr :: (dereferenceable load (s16) from %ir.7)
  %69:gpr = ADDR killed %66:gpr, killed %68:gpr
  %70:gpr = ADDI %stack.0, 0
  STORE16R killed %70:gpr, killed %69:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.2 (%ir-block.16):
; predecessors: %bb.10
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %59:gpr = ADDI %stack.2, 0
  %60:gpr = LOAD16R killed %59:gpr :: (dereferenceable load (s16) from %ir.6)
  %61:gpr = ADDI %stack.3, 0
  %62:gpr = LOAD16R killed %61:gpr :: (dereferenceable load (s16) from %ir.7)
  %63:gpr = SUBR killed %60:gpr, killed %62:gpr
  %64:gpr = ADDI %stack.0, 0
  STORE16R killed %64:gpr, killed %63:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.3 (%ir-block.23):
; predecessors: %bb.11
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %53:gpr = ADDI %stack.2, 0
  %54:gpr = LOAD16R killed %53:gpr :: (dereferenceable load (s16) from %ir.6)
  %55:gpr = ADDI %stack.3, 0
  %56:gpr = LOAD16R killed %55:gpr :: (dereferenceable load (s16) from %ir.7)
  %57:gpr = ORR killed %54:gpr, killed %56:gpr
  %58:gpr = ADDI %stack.0, 0
  STORE16R killed %58:gpr, killed %57:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.4 (%ir-block.30):
; predecessors: %bb.12
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %47:gpr = ADDI %stack.2, 0
  %48:gpr = LOAD16R killed %47:gpr :: (dereferenceable load (s16) from %ir.6)
  %49:gpr = ADDI %stack.3, 0
  %50:gpr = LOAD16R killed %49:gpr :: (dereferenceable load (s16) from %ir.7)
  %51:gpr = ANDR killed %48:gpr, killed %50:gpr
  %52:gpr = ADDI %stack.0, 0
  STORE16R killed %52:gpr, killed %51:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.5 (%ir-block.37):
; predecessors: %bb.13
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %41:gpr = ADDI %stack.2, 0
  %42:gpr = LOAD16R killed %41:gpr :: (dereferenceable load (s16) from %ir.6)
  %43:gpr = ADDI %stack.3, 0
  %44:gpr = LOAD16R killed %43:gpr :: (dereferenceable load (s16) from %ir.7)
  %45:gpr = XORR killed %42:gpr, killed %44:gpr
  %46:gpr = ADDI %stack.0, 0
  STORE16R killed %46:gpr, killed %45:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.6 (%ir-block.44):
; predecessors: %bb.14
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %33:gpr = ADDI %stack.2, 0
  %34:gpr = LOAD16R killed %33:gpr :: (dereferenceable load (s16) from %ir.6)
  %35:gpr = ADDI %stack.3, 0
  %36:gpr = LOAD16R killed %35:gpr :: (dereferenceable load (s16) from %ir.7)
  %37:gpr = LSLR killed %34:gpr, %36:gpr
  %38:gpr = ADDI %36:gpr, -16
  CMPI killed %38:gpr, 0, implicit-def dead $flags
  %39:gpr = CMOVPseudo killed %37:gpr, 0, 12
  %40:gpr = ADDI %stack.0, 0
  STORE16R killed %40:gpr, killed %39:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.7 (%ir-block.51):
; predecessors: %bb.15
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %25:gpr = ADDI %stack.2, 0
  %26:gpr = LOAD16R killed %25:gpr :: (dereferenceable load (s16) from %ir.6)
  %27:gpr = ADDI %stack.3, 0
  %28:gpr = LOAD16R killed %27:gpr :: (dereferenceable load (s16) from %ir.7)
  %29:gpr = LSRR killed %26:gpr, %28:gpr
  %30:gpr = ADDI %28:gpr, -16
  CMPI killed %30:gpr, 0, implicit-def dead $flags
  %31:gpr = CMOVPseudo killed %29:gpr, 0, 12
  %32:gpr = ADDI %stack.0, 0
  STORE16R killed %32:gpr, killed %31:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.8 (%ir-block.58):
; predecessors: %bb.15
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %71:gpr = MOVI 0, implicit $flags
  %72:gpr = ADDI %stack.0, 0
  STORE16R killed %72:gpr, killed %71:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

bb.9 (%ir-block.59):
; predecessors: %bb.7, %bb.6, %bb.5, %bb.4, %bb.3, %bb.2, %bb.1, %bb.8

  %73:gpr = ADDI %stack.0, 0
  %74:gpr = LOAD16R killed %73:gpr :: (dereferenceable load (s16) from %ir.4)
  $r1 = COPY %74:gpr
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1

# End machine code for function do_calc.

Skipping pass 'Two-Address instruction pass' on function do_calc
********** REWRITING TWO-ADDR INSTRS **********
********** Function: do_calc
********** FAST REGISTER ALLOCATION **********
********** Function: do_calc

Allocating bb.0 (%ir-block.3):
  successors: %bb.1, %bb.10
  liveins: $r1, $r2, $r3, $r4
  %3:gpr = COPY $r4
  %2:gpr = COPY $r3
  %1:gpr = COPY $r2
  %0:gpr = COPY $r1
  %5:gpr = COPY %1:gpr
  %4:gpr = COPY %0:gpr
  %8:gpr = ADDI %stack.1, 0
  STORE16R %8:gpr, %0:gpr :: (store (s16) into %ir.5, align 4)
  %9:gpr = disjoint ORI %8:gpr, 2
  STORE16R %9:gpr, %1:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  %10:gpr = ADDI %stack.2, 0
  STORE16R killed %10:gpr, %2:gpr :: (store (s16) into %ir.6)
  %11:gpr = ADDI %stack.3, 0
  STORE16R killed %11:gpr, %3:gpr :: (store (s16) into %ir.7)
  %6:gpr = LOAD16R %8:gpr :: (dereferenceable load (s16) from %ir.5, align 4)
  %7:gpr = LOAD16R %9:gpr :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
  %12:gpr = ORR %7:gpr, %6:gpr
  CMPI killed %12:gpr, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.10, implicit $flags

>> JMPI %bb.10, implicit $flags
Regs:
<< JMPI %bb.10, implicit $flags

>> JEI %bb.1, implicit $flags
Regs:
<< JEI %bb.1, implicit $flags

>> CMPI killed %12:gpr, 0, implicit-def $flags
Regs:
Search register for %12 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %12 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %12:gpr = ORR %7:gpr, %6:gpr
Regs: R1=%12
In def of %12 use existing assignment to $r1
Freeing $r1: %12
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR $r1, $r2

>> %7:gpr = LOAD16R %9:gpr :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
Regs: R1=%7[O] R2=%6[O]
In def of %7 use existing assignment to $r1
Spill Reason: LO: 1 RL: 0
Spilling %7 in $r1 to stack slot #4
Freeing $r1: %7
Search register for %9 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %9 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)

>> %6:gpr = LOAD16R %8:gpr :: (dereferenceable load (s16) from %ir.5, align 4)
Regs: R1=%9 R2=%6[O]
In def of %6 use existing assignment to $r2
Spill Reason: LO: 1 RL: 0
Spilling %6 in $r2 to stack slot #5
Freeing $r2: %6
Search register for %8 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %8 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.5, align 4)

>> STORE16R killed %11:gpr, %3:gpr :: (store (s16) into %ir.7)
Regs: R1=%9 R2=%8
Search register for %11 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 0 BestCost: 100
Assigning %11 to $r3
Search register for %3 in class GPR with hint $noreg
	Preferred Register 0: $r4
Assigning %3 to $r4
<< STORE16R killed $r3, killed $r4 :: (store (s16) into %ir.7)

>> %11:gpr = ADDI %stack.3, 0
Regs: R1=%9 R2=%8 R3=%11 R4=%3
In def of %11 use existing assignment to $r3
Freeing $r3: %11
<< $r3 = ADDI %stack.3, 0

>> STORE16R killed %10:gpr, %2:gpr :: (store (s16) into %ir.6)
Regs: R1=%9 R2=%8 R4=%3
Search register for %10 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 0 BestCost: 100
Assigning %10 to $r3
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 already used in instr.
	Register: $r4 Cost: 100 BestCost: 100
	Register: $r5 Cost: 0 BestCost: 100
Assigning %2 to $r5
<< STORE16R killed $r3, killed $r5 :: (store (s16) into %ir.6)

>> %10:gpr = ADDI %stack.2, 0
Regs: R1=%9 R2=%8 R3=%10 R4=%3 R5=%2
In def of %10 use existing assignment to $r3
Freeing $r3: %10
<< $r3 = ADDI %stack.2, 0

>> STORE16R %9:gpr, %1:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs: R1=%9 R2=%8 R4=%3 R5=%2
Search register for %1 in class GPR with hint $noreg
	Preferred Register 1: $r2 occupied
	Register: $r1 already used in instr.
	Register: $r2 Cost: 100 BestCost: 4294967295
	Register: $r3 Cost: 0 BestCost: 80
Assigning %1 to $r3
<< STORE16R $r1, killed $r3 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %9:gpr = disjoint ORI %8:gpr, 2
Regs: R1=%9 R2=%8 R3=%1 R4=%3 R5=%2
In def of %9 use existing assignment to $r1
Freeing $r1: %9
<< $r1 = disjoint ORI $r2, 2

>> STORE16R %8:gpr, %0:gpr :: (store (s16) into %ir.5, align 4)
Regs: R2=%8 R3=%1 R4=%3 R5=%2
Search register for %0 in class GPR with hint $noreg
	Preferred Register 0: $r1
Assigning %0 to $r1
<< STORE16R $r2, killed $r1 :: (store (s16) into %ir.5, align 4)

>> %8:gpr = ADDI %stack.1, 0
Regs: R1=%0 R2=%8 R3=%1 R4=%3 R5=%2
In def of %8 use existing assignment to $r2
Freeing $r2: %8
<< $r2 = ADDI %stack.1, 0

>> %4:gpr = COPY %0:gpr
Regs: R1=%0 R3=%1 R4=%3 R5=%2
Search register for %4 in class GPR with hint $noreg
	Preferred Register 1: $r1 occupied
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 80
Assigning %4 to $r2
Freeing $r2: %4
<< dead $r2 = COPY $r1

>> %5:gpr = COPY %1:gpr
Regs: R1=%0 R3=%1 R4=%3 R5=%2
Search register for %5 in class GPR with hint $noreg
	Preferred Register 0: $r2
Assigning %5 to $r2
Freeing $r2: %5
<< dead $r2 = COPY $r3

>> %0:gpr = COPY $r1
Regs: R1=%0 R3=%1 R4=%3 R5=%2
In def of %0 use existing assignment to $r1
Freeing $r1: %0
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %1:gpr = COPY $r2
Regs: R1[P] R3=%1 R4=%3 R5=%2
In def of %1 use existing assignment to $r3
Freeing $r3: %1
<< $r3 = COPY killed $r2

>> %2:gpr = COPY $r3
Regs: R1[P] R2[P] R4=%3 R5=%2
In def of %2 use existing assignment to $r5
Freeing $r5: %2
<< $r5 = COPY killed $r3

>> %3:gpr = COPY $r4
Regs: R1[P] R2[P] R3[P] R4=%3
In def of %3 use existing assignment to $r4
Freeing $r4: %3
<< $r4 = COPY killed $r4
Mark identity copy for removal
Begin Regs: R1[P] R2[P] R3[P] R4[P]
Loading live registers at begin of block.
bb.0 (%ir-block.3):
  successors: %bb.1, %bb.10
  liveins: $r1, $r2, $r3, $r4
  $r5 = COPY killed $r3
  $r3 = COPY killed $r2
  dead $r2 = COPY $r3
  dead $r2 = COPY $r1
  $r2 = ADDI %stack.1, 0
  STORE16R $r2, killed $r1 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI $r2, 2
  STORE16R $r1, killed $r3 :: (store (s16) into %ir.5 + 2, basealign 4)
  $r3 = ADDI %stack.2, 0
  STORE16R killed $r3, killed $r5 :: (store (s16) into %ir.6)
  $r3 = ADDI %stack.3, 0
  STORE16R killed $r3, killed $r4 :: (store (s16) into %ir.7)
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.5, align 4)
  $r13 = frameptrget %stack.5, implicit-def $r13
  STORE16R killed $r13, $r2
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
  $r13 = frameptrget %stack.4, implicit-def $r13
  STORE16R killed $r13, $r1
  $r1 = ORR $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.1, implicit $flags
  JMPI %bb.10, implicit $flags

Allocating bb.10 (%ir-block.3):
; predecessors: %bb.0
  successors: %bb.2, %bb.11

  %13:gpr = XORI %7:gpr, 1
  %14:gpr = ORR killed %13:gpr, %6:gpr
  CMPI killed %14:gpr, 0, implicit-def $flags
  JEI %bb.2, implicit $flags
  JMPI %bb.11, implicit $flags

>> JMPI %bb.11, implicit $flags
Regs:
<< JMPI %bb.11, implicit $flags

>> JEI %bb.2, implicit $flags
Regs:
<< JEI %bb.2, implicit $flags

>> CMPI killed %14:gpr, 0, implicit-def $flags
Regs:
Search register for %14 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %14 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %14:gpr = ORR killed %13:gpr, %6:gpr
Regs: R1=%14
In def of %14 use existing assignment to $r1
Freeing $r1: %14
Search register for %13 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %13 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR killed $r1, $r2

>> %13:gpr = XORI %7:gpr, 1
Regs: R1=%13 R2=%6[O]
In def of %13 use existing assignment to $r1
Freeing $r1: %13
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = XORI $r1, 1
Begin Regs: R1=%7[O] R2=%6[O]
Loading live registers at begin of block.
Reloading %6 into $r2
Reloading %7 into $r1
bb.10 (%ir-block.3):
; predecessors: %bb.0
  successors: %bb.2, %bb.11

  $r13 = frameptrget %stack.5, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.4, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 1
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.2, implicit $flags
  JMPI %bb.11, implicit $flags

Allocating bb.11 (%ir-block.3):
; predecessors: %bb.10
  successors: %bb.3, %bb.12

  %15:gpr = XORI %7:gpr, 2
  %16:gpr = ORR killed %15:gpr, %6:gpr
  CMPI killed %16:gpr, 0, implicit-def $flags
  JEI %bb.3, implicit $flags
  JMPI %bb.12, implicit $flags

>> JMPI %bb.12, implicit $flags
Regs:
<< JMPI %bb.12, implicit $flags

>> JEI %bb.3, implicit $flags
Regs:
<< JEI %bb.3, implicit $flags

>> CMPI killed %16:gpr, 0, implicit-def $flags
Regs:
Search register for %16 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %16 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %16:gpr = ORR killed %15:gpr, %6:gpr
Regs: R1=%16
In def of %16 use existing assignment to $r1
Freeing $r1: %16
Search register for %15 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %15 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR killed $r1, $r2

>> %15:gpr = XORI %7:gpr, 2
Regs: R1=%15 R2=%6[O]
In def of %15 use existing assignment to $r1
Freeing $r1: %15
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = XORI $r1, 2
Begin Regs: R1=%7[O] R2=%6[O]
Loading live registers at begin of block.
Reloading %6 into $r2
Reloading %7 into $r1
bb.11 (%ir-block.3):
; predecessors: %bb.10
  successors: %bb.3, %bb.12

  $r13 = frameptrget %stack.5, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.4, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 2
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.3, implicit $flags
  JMPI %bb.12, implicit $flags

Allocating bb.12 (%ir-block.3):
; predecessors: %bb.11
  successors: %bb.4, %bb.13

  %17:gpr = XORI %7:gpr, 3
  %18:gpr = ORR killed %17:gpr, %6:gpr
  CMPI killed %18:gpr, 0, implicit-def $flags
  JEI %bb.4, implicit $flags
  JMPI %bb.13, implicit $flags

>> JMPI %bb.13, implicit $flags
Regs:
<< JMPI %bb.13, implicit $flags

>> JEI %bb.4, implicit $flags
Regs:
<< JEI %bb.4, implicit $flags

>> CMPI killed %18:gpr, 0, implicit-def $flags
Regs:
Search register for %18 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %18 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %18:gpr = ORR killed %17:gpr, %6:gpr
Regs: R1=%18
In def of %18 use existing assignment to $r1
Freeing $r1: %18
Search register for %17 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %17 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR killed $r1, $r2

>> %17:gpr = XORI %7:gpr, 3
Regs: R1=%17 R2=%6[O]
In def of %17 use existing assignment to $r1
Freeing $r1: %17
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = XORI $r1, 3
Begin Regs: R1=%7[O] R2=%6[O]
Loading live registers at begin of block.
Reloading %6 into $r2
Reloading %7 into $r1
bb.12 (%ir-block.3):
; predecessors: %bb.11
  successors: %bb.4, %bb.13

  $r13 = frameptrget %stack.5, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.4, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 3
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.4, implicit $flags
  JMPI %bb.13, implicit $flags

Allocating bb.13 (%ir-block.3):
; predecessors: %bb.12
  successors: %bb.5, %bb.14

  %19:gpr = XORI %7:gpr, 4
  %20:gpr = ORR killed %19:gpr, %6:gpr
  CMPI killed %20:gpr, 0, implicit-def $flags
  JEI %bb.5, implicit $flags
  JMPI %bb.14, implicit $flags

>> JMPI %bb.14, implicit $flags
Regs:
<< JMPI %bb.14, implicit $flags

>> JEI %bb.5, implicit $flags
Regs:
<< JEI %bb.5, implicit $flags

>> CMPI killed %20:gpr, 0, implicit-def $flags
Regs:
Search register for %20 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %20 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %20:gpr = ORR killed %19:gpr, %6:gpr
Regs: R1=%20
In def of %20 use existing assignment to $r1
Freeing $r1: %20
Search register for %19 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %19 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR killed $r1, $r2

>> %19:gpr = XORI %7:gpr, 4
Regs: R1=%19 R2=%6[O]
In def of %19 use existing assignment to $r1
Freeing $r1: %19
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = XORI $r1, 4
Begin Regs: R1=%7[O] R2=%6[O]
Loading live registers at begin of block.
Reloading %6 into $r2
Reloading %7 into $r1
bb.13 (%ir-block.3):
; predecessors: %bb.12
  successors: %bb.5, %bb.14

  $r13 = frameptrget %stack.5, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.4, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 4
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.5, implicit $flags
  JMPI %bb.14, implicit $flags

Allocating bb.14 (%ir-block.3):
; predecessors: %bb.13
  successors: %bb.6, %bb.15

  %21:gpr = XORI %7:gpr, 5
  %22:gpr = ORR killed %21:gpr, %6:gpr
  CMPI killed %22:gpr, 0, implicit-def $flags
  JEI %bb.6, implicit $flags
  JMPI %bb.15, implicit $flags

>> JMPI %bb.15, implicit $flags
Regs:
<< JMPI %bb.15, implicit $flags

>> JEI %bb.6, implicit $flags
Regs:
<< JEI %bb.6, implicit $flags

>> CMPI killed %22:gpr, 0, implicit-def $flags
Regs:
Search register for %22 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %22 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %22:gpr = ORR killed %21:gpr, %6:gpr
Regs: R1=%22
In def of %22 use existing assignment to $r1
Freeing $r1: %22
Search register for %21 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %21 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR killed $r1, $r2

>> %21:gpr = XORI %7:gpr, 5
Regs: R1=%21 R2=%6[O]
In def of %21 use existing assignment to $r1
Freeing $r1: %21
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = XORI $r1, 5
Begin Regs: R1=%7[O] R2=%6[O]
Loading live registers at begin of block.
Reloading %6 into $r2
Reloading %7 into $r1
bb.14 (%ir-block.3):
; predecessors: %bb.13
  successors: %bb.6, %bb.15

  $r13 = frameptrget %stack.5, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.4, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 5
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.6, implicit $flags
  JMPI %bb.15, implicit $flags

Allocating bb.15 (%ir-block.3):
; predecessors: %bb.14
  successors: %bb.7, %bb.8

  %23:gpr = XORI %7:gpr, 6
  %24:gpr = ORR killed %23:gpr, %6:gpr
  CMPI killed %24:gpr, 0, implicit-def $flags
  JEI %bb.7, implicit $flags
  JMPI %bb.8, implicit $flags

>> JMPI %bb.8, implicit $flags
Regs:
<< JMPI %bb.8, implicit $flags

>> JEI %bb.7, implicit $flags
Regs:
<< JEI %bb.7, implicit $flags

>> CMPI killed %24:gpr, 0, implicit-def $flags
Regs:
Search register for %24 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %24 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %24:gpr = ORR killed %23:gpr, %6:gpr
Regs: R1=%24
In def of %24 use existing assignment to $r1
Freeing $r1: %24
Search register for %23 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %23 to $r1
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< $r1 = ORR killed $r1, $r2

>> %23:gpr = XORI %7:gpr, 6
Regs: R1=%23 R2=%6[O]
In def of %23 use existing assignment to $r1
Freeing $r1: %23
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = XORI $r1, 6
Begin Regs: R1=%7[O] R2=%6[O]
Loading live registers at begin of block.
Reloading %6 into $r2
Reloading %7 into $r1
bb.15 (%ir-block.3):
; predecessors: %bb.14
  successors: %bb.7, %bb.8

  $r13 = frameptrget %stack.5, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.4, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r1 = XORI $r1, 6
  $r1 = ORR killed $r1, $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.7, implicit $flags
  JMPI %bb.8, implicit $flags

Allocating bb.1 (%ir-block.9):
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %65:gpr = ADDI %stack.2, 0
  %66:gpr = LOAD16R killed %65:gpr :: (dereferenceable load (s16) from %ir.6)
  %67:gpr = ADDI %stack.3, 0
  %68:gpr = LOAD16R killed %67:gpr :: (dereferenceable load (s16) from %ir.7)
  %69:gpr = ADDR killed %66:gpr, killed %68:gpr
  %70:gpr = ADDI %stack.0, 0
  STORE16R killed %70:gpr, killed %69:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %70:gpr, killed %69:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %70 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %70 to $r1
Search register for %69 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %69 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %70:gpr = ADDI %stack.0, 0
Regs: R1=%70 R2=%69
In def of %70 use existing assignment to $r1
Freeing $r1: %70
<< $r1 = ADDI %stack.0, 0

>> %69:gpr = ADDR killed %66:gpr, killed %68:gpr
Regs: R2=%69
In def of %69 use existing assignment to $r2
Freeing $r2: %69
Search register for %66 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %66 to $r1
Search register for %68 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %68 to $r2
<< $r2 = ADDR killed $r1, killed $r2

>> %68:gpr = LOAD16R killed %67:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%66 R2=%68
In def of %68 use existing assignment to $r2
Freeing $r2: %68
Search register for %67 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %67 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %67:gpr = ADDI %stack.3, 0
Regs: R1=%66 R2=%67
In def of %67 use existing assignment to $r2
Freeing $r2: %67
<< $r2 = ADDI %stack.3, 0

>> %66:gpr = LOAD16R killed %65:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%66
In def of %66 use existing assignment to $r1
Freeing $r1: %66
Search register for %65 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %65 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %65:gpr = ADDI %stack.2, 0
Regs: R1=%65
In def of %65 use existing assignment to $r1
Freeing $r1: %65
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.1 (%ir-block.9):
; predecessors: %bb.0
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r2 = ADDR killed $r1, killed $r2
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.2 (%ir-block.16):
; predecessors: %bb.10
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %59:gpr = ADDI %stack.2, 0
  %60:gpr = LOAD16R killed %59:gpr :: (dereferenceable load (s16) from %ir.6)
  %61:gpr = ADDI %stack.3, 0
  %62:gpr = LOAD16R killed %61:gpr :: (dereferenceable load (s16) from %ir.7)
  %63:gpr = SUBR killed %60:gpr, killed %62:gpr
  %64:gpr = ADDI %stack.0, 0
  STORE16R killed %64:gpr, killed %63:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %64:gpr, killed %63:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %64 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %64 to $r1
Search register for %63 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %63 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %64:gpr = ADDI %stack.0, 0
Regs: R1=%64 R2=%63
In def of %64 use existing assignment to $r1
Freeing $r1: %64
<< $r1 = ADDI %stack.0, 0

>> %63:gpr = SUBR killed %60:gpr, killed %62:gpr
Regs: R2=%63
In def of %63 use existing assignment to $r2
Freeing $r2: %63
Search register for %60 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %60 to $r1
Search register for %62 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %62 to $r2
<< $r2 = SUBR killed $r1, killed $r2

>> %62:gpr = LOAD16R killed %61:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%60 R2=%62
In def of %62 use existing assignment to $r2
Freeing $r2: %62
Search register for %61 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %61 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %61:gpr = ADDI %stack.3, 0
Regs: R1=%60 R2=%61
In def of %61 use existing assignment to $r2
Freeing $r2: %61
<< $r2 = ADDI %stack.3, 0

>> %60:gpr = LOAD16R killed %59:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%60
In def of %60 use existing assignment to $r1
Freeing $r1: %60
Search register for %59 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %59 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %59:gpr = ADDI %stack.2, 0
Regs: R1=%59
In def of %59 use existing assignment to $r1
Freeing $r1: %59
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.2 (%ir-block.16):
; predecessors: %bb.10
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r2 = SUBR killed $r1, killed $r2
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.3 (%ir-block.23):
; predecessors: %bb.11
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %53:gpr = ADDI %stack.2, 0
  %54:gpr = LOAD16R killed %53:gpr :: (dereferenceable load (s16) from %ir.6)
  %55:gpr = ADDI %stack.3, 0
  %56:gpr = LOAD16R killed %55:gpr :: (dereferenceable load (s16) from %ir.7)
  %57:gpr = ORR killed %54:gpr, killed %56:gpr
  %58:gpr = ADDI %stack.0, 0
  STORE16R killed %58:gpr, killed %57:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %58:gpr, killed %57:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %58 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %58 to $r1
Search register for %57 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %57 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %58:gpr = ADDI %stack.0, 0
Regs: R1=%58 R2=%57
In def of %58 use existing assignment to $r1
Freeing $r1: %58
<< $r1 = ADDI %stack.0, 0

>> %57:gpr = ORR killed %54:gpr, killed %56:gpr
Regs: R2=%57
In def of %57 use existing assignment to $r2
Freeing $r2: %57
Search register for %54 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %54 to $r1
Search register for %56 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %56 to $r2
<< $r2 = ORR killed $r1, killed $r2

>> %56:gpr = LOAD16R killed %55:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%54 R2=%56
In def of %56 use existing assignment to $r2
Freeing $r2: %56
Search register for %55 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %55 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %55:gpr = ADDI %stack.3, 0
Regs: R1=%54 R2=%55
In def of %55 use existing assignment to $r2
Freeing $r2: %55
<< $r2 = ADDI %stack.3, 0

>> %54:gpr = LOAD16R killed %53:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%54
In def of %54 use existing assignment to $r1
Freeing $r1: %54
Search register for %53 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %53 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %53:gpr = ADDI %stack.2, 0
Regs: R1=%53
In def of %53 use existing assignment to $r1
Freeing $r1: %53
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.3 (%ir-block.23):
; predecessors: %bb.11
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r2 = ORR killed $r1, killed $r2
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.4 (%ir-block.30):
; predecessors: %bb.12
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %47:gpr = ADDI %stack.2, 0
  %48:gpr = LOAD16R killed %47:gpr :: (dereferenceable load (s16) from %ir.6)
  %49:gpr = ADDI %stack.3, 0
  %50:gpr = LOAD16R killed %49:gpr :: (dereferenceable load (s16) from %ir.7)
  %51:gpr = ANDR killed %48:gpr, killed %50:gpr
  %52:gpr = ADDI %stack.0, 0
  STORE16R killed %52:gpr, killed %51:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %52:gpr, killed %51:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %52 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %52 to $r1
Search register for %51 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %51 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %52:gpr = ADDI %stack.0, 0
Regs: R1=%52 R2=%51
In def of %52 use existing assignment to $r1
Freeing $r1: %52
<< $r1 = ADDI %stack.0, 0

>> %51:gpr = ANDR killed %48:gpr, killed %50:gpr
Regs: R2=%51
In def of %51 use existing assignment to $r2
Freeing $r2: %51
Search register for %48 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %48 to $r1
Search register for %50 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %50 to $r2
<< $r2 = ANDR killed $r1, killed $r2

>> %50:gpr = LOAD16R killed %49:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%48 R2=%50
In def of %50 use existing assignment to $r2
Freeing $r2: %50
Search register for %49 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %49 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %49:gpr = ADDI %stack.3, 0
Regs: R1=%48 R2=%49
In def of %49 use existing assignment to $r2
Freeing $r2: %49
<< $r2 = ADDI %stack.3, 0

>> %48:gpr = LOAD16R killed %47:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%48
In def of %48 use existing assignment to $r1
Freeing $r1: %48
Search register for %47 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %47 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %47:gpr = ADDI %stack.2, 0
Regs: R1=%47
In def of %47 use existing assignment to $r1
Freeing $r1: %47
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.4 (%ir-block.30):
; predecessors: %bb.12
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r2 = ANDR killed $r1, killed $r2
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.5 (%ir-block.37):
; predecessors: %bb.13
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %41:gpr = ADDI %stack.2, 0
  %42:gpr = LOAD16R killed %41:gpr :: (dereferenceable load (s16) from %ir.6)
  %43:gpr = ADDI %stack.3, 0
  %44:gpr = LOAD16R killed %43:gpr :: (dereferenceable load (s16) from %ir.7)
  %45:gpr = XORR killed %42:gpr, killed %44:gpr
  %46:gpr = ADDI %stack.0, 0
  STORE16R killed %46:gpr, killed %45:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %46:gpr, killed %45:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %46 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %46 to $r1
Search register for %45 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %45 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %46:gpr = ADDI %stack.0, 0
Regs: R1=%46 R2=%45
In def of %46 use existing assignment to $r1
Freeing $r1: %46
<< $r1 = ADDI %stack.0, 0

>> %45:gpr = XORR killed %42:gpr, killed %44:gpr
Regs: R2=%45
In def of %45 use existing assignment to $r2
Freeing $r2: %45
Search register for %42 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %42 to $r1
Search register for %44 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %44 to $r2
<< $r2 = XORR killed $r1, killed $r2

>> %44:gpr = LOAD16R killed %43:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%42 R2=%44
In def of %44 use existing assignment to $r2
Freeing $r2: %44
Search register for %43 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %43 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %43:gpr = ADDI %stack.3, 0
Regs: R1=%42 R2=%43
In def of %43 use existing assignment to $r2
Freeing $r2: %43
<< $r2 = ADDI %stack.3, 0

>> %42:gpr = LOAD16R killed %41:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%42
In def of %42 use existing assignment to $r1
Freeing $r1: %42
Search register for %41 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %41 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %41:gpr = ADDI %stack.2, 0
Regs: R1=%41
In def of %41 use existing assignment to $r1
Freeing $r1: %41
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.5 (%ir-block.37):
; predecessors: %bb.13
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r2 = XORR killed $r1, killed $r2
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.6 (%ir-block.44):
; predecessors: %bb.14
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %33:gpr = ADDI %stack.2, 0
  %34:gpr = LOAD16R killed %33:gpr :: (dereferenceable load (s16) from %ir.6)
  %35:gpr = ADDI %stack.3, 0
  %36:gpr = LOAD16R killed %35:gpr :: (dereferenceable load (s16) from %ir.7)
  %37:gpr = LSLR killed %34:gpr, %36:gpr
  %38:gpr = ADDI %36:gpr, -16
  CMPI killed %38:gpr, 0, implicit-def dead $flags
  %39:gpr = CMOVPseudo killed %37:gpr, 0, 12
  %40:gpr = ADDI %stack.0, 0
  STORE16R killed %40:gpr, killed %39:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %40:gpr, killed %39:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %40 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %40 to $r1
Search register for %39 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %39 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %40:gpr = ADDI %stack.0, 0
Regs: R1=%40 R2=%39
In def of %40 use existing assignment to $r1
Freeing $r1: %40
<< $r1 = ADDI %stack.0, 0

>> %39:gpr = CMOVPseudo killed %37:gpr, 0, 12
Regs: R2=%39
In def of %39 use existing assignment to $r2
Freeing $r2: %39
Search register for %37 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %37 to $r1
<< $r2 = CMOVPseudo killed $r1, 0, 12

>> CMPI killed %38:gpr, 0, implicit-def dead $flags
Regs: R1=%37
Search register for %38 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %38 to $r2
<< CMPI killed $r2, 0, implicit-def dead $flags

>> %38:gpr = ADDI %36:gpr, -16
Regs: R1=%37 R2=%38
In def of %38 use existing assignment to $r2
Freeing $r2: %38
Search register for %36 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %36 to $r2
<< $r2 = ADDI killed $r2, -16

>> %37:gpr = LSLR killed %34:gpr, %36:gpr
Regs: R1=%37 R2=%36
In def of %37 use existing assignment to $r1
Freeing $r1: %37
Search register for %34 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %34 to $r1
<< $r1 = LSLR killed $r1, $r2

>> %36:gpr = LOAD16R killed %35:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%34 R2=%36
In def of %36 use existing assignment to $r2
Freeing $r2: %36
Search register for %35 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %35 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %35:gpr = ADDI %stack.3, 0
Regs: R1=%34 R2=%35
In def of %35 use existing assignment to $r2
Freeing $r2: %35
<< $r2 = ADDI %stack.3, 0

>> %34:gpr = LOAD16R killed %33:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%34
In def of %34 use existing assignment to $r1
Freeing $r1: %34
Search register for %33 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %33 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %33:gpr = ADDI %stack.2, 0
Regs: R1=%33
In def of %33 use existing assignment to $r1
Freeing $r1: %33
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.6 (%ir-block.44):
; predecessors: %bb.14
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r1 = LSLR killed $r1, $r2
  $r2 = ADDI killed $r2, -16
  CMPI killed $r2, 0, implicit-def dead $flags
  $r2 = CMOVPseudo killed $r1, 0, 12
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.7 (%ir-block.51):
; predecessors: %bb.15
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %25:gpr = ADDI %stack.2, 0
  %26:gpr = LOAD16R killed %25:gpr :: (dereferenceable load (s16) from %ir.6)
  %27:gpr = ADDI %stack.3, 0
  %28:gpr = LOAD16R killed %27:gpr :: (dereferenceable load (s16) from %ir.7)
  %29:gpr = LSRR killed %26:gpr, %28:gpr
  %30:gpr = ADDI %28:gpr, -16
  CMPI killed %30:gpr, 0, implicit-def dead $flags
  %31:gpr = CMOVPseudo killed %29:gpr, 0, 12
  %32:gpr = ADDI %stack.0, 0
  STORE16R killed %32:gpr, killed %31:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %32:gpr, killed %31:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %32 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %32 to $r1
Search register for %31 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %31 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %32:gpr = ADDI %stack.0, 0
Regs: R1=%32 R2=%31
In def of %32 use existing assignment to $r1
Freeing $r1: %32
<< $r1 = ADDI %stack.0, 0

>> %31:gpr = CMOVPseudo killed %29:gpr, 0, 12
Regs: R2=%31
In def of %31 use existing assignment to $r2
Freeing $r2: %31
Search register for %29 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %29 to $r1
<< $r2 = CMOVPseudo killed $r1, 0, 12

>> CMPI killed %30:gpr, 0, implicit-def dead $flags
Regs: R1=%29
Search register for %30 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %30 to $r2
<< CMPI killed $r2, 0, implicit-def dead $flags

>> %30:gpr = ADDI %28:gpr, -16
Regs: R1=%29 R2=%30
In def of %30 use existing assignment to $r2
Freeing $r2: %30
Search register for %28 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %28 to $r2
<< $r2 = ADDI killed $r2, -16

>> %29:gpr = LSRR killed %26:gpr, %28:gpr
Regs: R1=%29 R2=%28
In def of %29 use existing assignment to $r1
Freeing $r1: %29
Search register for %26 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %26 to $r1
<< $r1 = LSRR killed $r1, $r2

>> %28:gpr = LOAD16R killed %27:gpr :: (dereferenceable load (s16) from %ir.7)
Regs: R1=%26 R2=%28
In def of %28 use existing assignment to $r2
Freeing $r2: %28
Search register for %27 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %27 to $r2
<< $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)

>> %27:gpr = ADDI %stack.3, 0
Regs: R1=%26 R2=%27
In def of %27 use existing assignment to $r2
Freeing $r2: %27
<< $r2 = ADDI %stack.3, 0

>> %26:gpr = LOAD16R killed %25:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%26
In def of %26 use existing assignment to $r1
Freeing $r1: %26
Search register for %25 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %25 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)

>> %25:gpr = ADDI %stack.2, 0
Regs: R1=%25
In def of %25 use existing assignment to $r1
Freeing $r1: %25
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.7 (%ir-block.51):
; predecessors: %bb.15
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.6)
  $r2 = ADDI %stack.3, 0
  $r2 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.7)
  $r1 = LSRR killed $r1, $r2
  $r2 = ADDI killed $r2, -16
  CMPI killed $r2, 0, implicit-def dead $flags
  $r2 = CMOVPseudo killed $r1, 0, 12
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.8 (%ir-block.58):
; predecessors: %bb.15
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %71:gpr = MOVI 0, implicit $flags
  %72:gpr = ADDI %stack.0, 0
  STORE16R killed %72:gpr, killed %71:gpr :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

>> JMPI %bb.9, implicit $flags
Regs:
<< JMPI %bb.9, implicit $flags

>> STORE16R killed %72:gpr, killed %71:gpr :: (store (s16) into %ir.4)
Regs:
Search register for %72 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %72 to $r1
Search register for %71 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %71 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)

>> %72:gpr = ADDI %stack.0, 0
Regs: R1=%72 R2=%71
In def of %72 use existing assignment to $r1
Freeing $r1: %72
<< $r1 = ADDI %stack.0, 0

>> %71:gpr = MOVI 0, implicit $flags
Regs: R2=%71
In def of %71 use existing assignment to $r2
Freeing $r2: %71
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.8 (%ir-block.58):
; predecessors: %bb.15
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.0, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.4)
  JMPI %bb.9, implicit $flags

Allocating bb.9 (%ir-block.59):
; predecessors: %bb.7, %bb.6, %bb.5, %bb.4, %bb.3, %bb.2, %bb.1, %bb.8

  %73:gpr = ADDI %stack.0, 0
  %74:gpr = LOAD16R killed %73:gpr :: (dereferenceable load (s16) from %ir.4)
  $r1 = COPY %74:gpr
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1

>> SymphonyRet implicit-def dead $sp, implicit $flags, implicit $r1
Regs:
<< SymphonyRet implicit-def dead $sp, implicit $flags, implicit killed $r1

>> $r1 = COPY %74:gpr
Regs: R1[P]
Freeing $r1:
Search register for %74 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %74 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %74:gpr = LOAD16R killed %73:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%74
In def of %74 use existing assignment to $r1
Freeing $r1: %74
Search register for %73 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %73 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %73:gpr = ADDI %stack.0, 0
Regs: R1=%73
In def of %73 use existing assignment to $r1
Freeing $r1: %73
<< $r1 = ADDI %stack.0, 0
Begin Regs:
Loading live registers at begin of block.
bb.9 (%ir-block.59):
; predecessors: %bb.7, %bb.6, %bb.5, %bb.4, %bb.3, %bb.2, %bb.1, %bb.8

  $r1 = ADDI %stack.0, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  SymphonyRet implicit-def dead $sp, implicit $flags, implicit killed $r1
Skipping pass 'Fixup Statepoint Caller Saved' on function do_calc
alloc FI(0) at SP[-2]
alloc FI(1) at SP[-8]
alloc FI(2) at SP[-10]
alloc FI(3) at SP[-12]
alloc FI(4) at SP[-14]
alloc FI(5) at SP[-16]
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r3 = ADDI %stack.3, 0
$r3 = ADDI %stack.2, 0
$r2 = ADDI %stack.1, 0
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r13 = frameptrget %stack.4, implicit-def $r13
$r13 = frameptrget %stack.5, implicit-def $r13
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r2 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.0, 0
$r1 = ADDI %stack.0, 0
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: do_calc
Skipping pass 'Remove Loads Into Fake Uses' on function do_calc

Debug Range Extension: do_calc
[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
Skipping pass 'Symphony DAG->DAG Pattern Instruction Selection' on function main
	FastISel is enabled



=== main
Enabling fast-isel
Creating constant: t1: i32 = Constant<0>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<0>, FrameIndex:i16<0>, undef:i16
Creating new node: t7: ch = store<(store (s16) into %ir.2)> t5, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Creating constant: t8: i8 = Constant<1>
Creating new node: t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
Creating new node: t12: ch = br t10, BasicBlock:ch< 0x16b382819c0>

Initial selection DAG: %bb.0 'main:'
SelectionDAG has 13 nodes:
          t0: ch,glue = EntryToken
        t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<0>, FrameIndex:i16<0>, undef:i16
      t7: ch = store<(store (s16) into %ir.2)> t5, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
    t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
  t12: ch = br t10, BasicBlock:ch< 0x16b382819c0>



Combining: t12: ch = br t10, BasicBlock:ch< 0x16b382819c0>

Combining: t11: ch = BasicBlock< 0x16b382819c0>

Combining: t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16

Combining: t9: i16 = FrameIndex<2>

Combining: t8: i8 = Constant<1>

Combining: t7: ch = store<(store (s16) into %ir.2)> t5, Constant:i16<0>, FrameIndex:i16<1>, undef:i16

Combining: t6: i16 = FrameIndex<1>

Combining: t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<0>, FrameIndex:i16<0>, undef:i16

Combining: t4: i16 = undef

Combining: t3: i16 = Constant<0>

Combining: t2: i16 = FrameIndex<0>

Combining: t1: i32 = Constant<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.0 'main:'
SelectionDAG has 13 nodes:
          t0: ch,glue = EntryToken
        t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<0>, FrameIndex:i16<0>, undef:i16
      t7: ch = store<(store (s16) into %ir.2)> t5, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
    t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
  t12: ch = br t10, BasicBlock:ch< 0x16b382819c0>



Legalizing node: t11: ch = BasicBlock< 0x16b382819c0>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b382819c0>

Legalizing node: t9: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t9: i16 = FrameIndex<2>

Legalizing node: t8: i8 = Constant<1>
Analyzing result type: i8
Promote integer result: t8: i8 = Constant<1>
Creating constant: t13: i16 = Constant<1>

Legalizing node: t13: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t13: i16 = Constant<1>

Legalizing node: t6: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = FrameIndex<1>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t3: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = Constant<0>

Legalizing node: t2: i16 = FrameIndex<0>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<0>

Legalizing node: t1: i32 = Constant<0>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<0>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<0>
Expand integer operand: t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<0>, FrameIndex:i16<0>, undef:i16
Creating new node: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Creating constant: t15: i16 = Constant<2>
Creating new node: t16: i16 = add nuw FrameIndex:i16<0>, Constant:i16<2>
Creating new node: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t16, undef:i16
Creating new node: t18: ch = TokenFactor t14, t17

Legalizing node: t15: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t15: i16 = Constant<2>

Legalizing node: t16: i16 = add nuw FrameIndex:i16<0>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t15: i16 = Constant<2>
Legal operand
Legally typed node: t16: i16 = add nuw FrameIndex:i16<0>, Constant:i16<2>

Legalizing node: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t16, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t3: i16 = Constant<0>
Legal operand
Analyzing operand: t16: i16 = add nuw FrameIndex:i16<0>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t16, undef:i16

Legalizing node: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t3: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<0>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing node: t18: ch = TokenFactor t14, t17
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legal operand
Analyzing operand: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t16, undef:i16
Legal operand
Legally typed node: t18: ch = TokenFactor t14, t17

Legalizing node: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t18: ch = TokenFactor t14, t17
Legal operand
Analyzing operand: t3: i16 = Constant<0>
Legal operand
Analyzing operand: t6: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16

Legalizing node: t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i8 = Constant<1>
Promote integer operand: t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
Creating new node: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Replacing: t10: ch = store<(store (s8) into %ir.3)> t7, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
     with: t19: ch = store<(store (s8) into %ir.<badref>), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Legalizing node: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t13: i16 = Constant<1>
Legal operand
Analyzing operand: t9: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Legalizing node: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b382819c0>
Legal operand
Legally typed node: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.0 'main:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
          t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
            t16: i16 = add nuw FrameIndex:i16<0>, Constant:i16<2>
          t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t16, undef:i16
        t18: ch = TokenFactor t14, t17
      t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
    t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>



Combining: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Combining: t18: ch = TokenFactor t14, t17

Combining: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t16, undef:i16

Combining: t16: i16 = add nuw FrameIndex:i16<0>, Constant:i16<2>
Creating new node: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
 ... into: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>

Combining: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>

Combining: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16

Combining: t15: i16 = Constant<2>

Combining: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Combining: t13: i16 = Constant<1>

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>

Combining: t11: ch = BasicBlock< 0x16b382819c0>

Combining: t9: i16 = FrameIndex<2>

Combining: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16

Combining: t6: i16 = FrameIndex<1>

Combining: t4: i16 = undef

Combining: t3: i16 = Constant<0>

Combining: t2: i16 = FrameIndex<0>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.0 'main:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
          t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
            t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
          t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16
        t18: ch = TokenFactor t14, t17
      t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
    t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>
Legal node: nothing to do

Legalizing: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Legalizing truncating store operations

Legalizing: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t18: ch = TokenFactor t14, t17
Legal node: nothing to do

Legalizing: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t13: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b382819c0>
Legal node: nothing to do

Legalizing: t9: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t6: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t3: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.0 'main:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
          t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
            t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
          t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16
        t18: ch = TokenFactor t14, t17
      t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
    t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>



Legalizing: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>
Legal node: nothing to do

Combining: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>

Legalizing: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Legalizing truncating store operations

Combining: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Legalizing: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16

Legalizing: t18: ch = TokenFactor t14, t17
Legal node: nothing to do

Combining: t18: ch = TokenFactor t14, t17

Legalizing: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16

Legalizing: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
Legal node: nothing to do

Combining: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>

Legalizing: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

Legalizing: t15: i16 = Constant<2>
Legal node: nothing to do

Combining: t15: i16 = Constant<2>

Legalizing: t13: i16 = Constant<1>
Legal node: nothing to do

Combining: t13: i16 = Constant<1>

Legalizing: t11: ch = BasicBlock< 0x16b382819c0>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b382819c0>

Legalizing: t9: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t9: i16 = FrameIndex<2>

Legalizing: t6: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t6: i16 = FrameIndex<1>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t3: i16 = Constant<0>
Legal node: nothing to do

Combining: t3: i16 = Constant<0>

Legalizing: t2: i16 = FrameIndex<0>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.0 'main:'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
          t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
            t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
          t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16
        t18: ch = TokenFactor t14, t17
      t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
    t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>
Selecting: t12: ch = br t19, BasicBlock:ch< 0x16b382819c0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t12: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Selecting: t19: ch = store<(store (s8) into %ir.3), trunc to i8> t7, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t19: ch = STORE8R<Mem:(store (s8) into %ir.3)> FrameIndex:i16<2>, Constant:i16<1>, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16
Selecting: t7: ch = store<(store (s16) into %ir.2)> t18, Constant:i16<0>, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> FrameIndex:i16<1>, Constant:i16<0>, t18
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = TokenFactor t14, t17
Selecting: t18: ch = TokenFactor t14, t17


ISEL: Starting selection on root node: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16
Selecting: t17: ch = store<(store (s16) into %ir.1 + 2, basealign 4)> t0, Constant:i16<0>, t20, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>
Selecting: t20: i16 = or disjoint FrameIndex:i16<0>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t21: i16 = TargetConstant<2>
  Morphed node: t20: i16 = ORI disjoint FrameIndex:i16<0>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16
Selecting: t14: ch = store<(store (s16) into %ir.1, align 4)> t0, Constant:i16<0>, FrameIndex:i16<0>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> FrameIndex:i16<0>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: i16 = Constant<1>
Selecting: t13: i16 = Constant<1>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t22: i16 = TargetConstant<1>
  Morphed node: t13: i16 = MOVI TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b382819c0>
Selecting: t11: ch = BasicBlock< 0x16b382819c0>


ISEL: Starting selection on root node: t9: i16 = FrameIndex<2>
Selecting: t9: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t24: i16 = TargetConstant<0>
  Morphed node: t9: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = FrameIndex<1>
Selecting: t6: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t3: i16 = Constant<0>
Selecting: t3: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
  Morphed node: t3: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i16 = FrameIndex<0>
Selecting: t2: i16 = FrameIndex<0>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.0 'main:'
SelectionDAG has 20 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>
  t3: i16 = MOVI TargetConstant:i16<0>
      t9: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
      t13: i16 = MOVI TargetConstant:i16<1>
        t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
          t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0
            t20: i16 = ORI disjoint t2, TargetConstant:i16<2>
          t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, t3, t0
        t18: ch = TokenFactor t14, t17
      t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18
    t19: ch = STORE8R<Mem:(store (s8) into %ir.3)> t9, t13, t7
  t12: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t19


********** List Scheduling %bb.0 '' **********
SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t19

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t19: ch = STORE8R<Mem:(store (s8) into %ir.3)> t9, t13, t7

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(11): Data Latency=1
    SU(10): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
    SU(3): Ord  Latency=0 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t18: ch = TokenFactor t14, t17

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=0 Barrier
SU(4): t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, t3, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(5): t20: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(8): t3: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
    SU(4): Data Latency=1
    SU(7): Data Latency=1
SU(9): t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(10): t13: i16 = MOVI TargetConstant:i16<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(11): t9: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t19


*** Scheduling [0]: SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t19


Examining Available:
Height 1: SU(1): t19: ch = STORE8R<Mem:(store (s8) into %ir.3)> t9, t13, t7


*** Scheduling [1]: SU(1): t19: ch = STORE8R<Mem:(store (s8) into %ir.3)> t9, t13, t7


Examining Available:
Height 2: SU(11): t9: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

Height 2: SU(10): t13: i16 = MOVI TargetConstant:i16<1>

Height 2: SU(2): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18


*** Scheduling [2]: SU(11): t9: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(10): t13: i16 = MOVI TargetConstant:i16<1>

Height 2: SU(2): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18


*** Scheduling [3]: SU(10): t13: i16 = MOVI TargetConstant:i16<1>


Examining Available:
Height 2: SU(2): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18


*** Scheduling [4]: SU(2): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18


Examining Available:
Height 4: SU(3): t18: ch = TokenFactor t14, t17

Height 5: SU(9): t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


*** Scheduling [5]: SU(3): t18: ch = TokenFactor t14, t17


Examining Available:
Height 5: SU(9): t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  Comparing latency of SU (4) depth 2 vs SU (7) depth 1
Height 6: SU(4): t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, t3, t0

Height 6: SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0


*** Scheduling [6]: SU(9): t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
  Comparing latency of SU (4) depth 2 vs SU (7) depth 1
Height 6: SU(4): t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, t3, t0

Height 6: SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0

  Comparing latency of SU (4) depth 2 vs SU (7) depth 1

*** Scheduling [7]: SU(4): t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, t3, t0


Examining Available:
Height 8: SU(5): t20: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 6: SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0


*** Scheduling [8]: SU(5): t20: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 6: SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0


*** Scheduling [9]: SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0


Examining Available:
Height 10: SU(6): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

Height 10: SU(8): t3: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [10]: SU(6): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>


Examining Available:
Height 10: SU(8): t3: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [11]: SU(8): t3: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(8): t3: i16 = MOVI TargetConstant:i16<0>

SU(6): t2: i16 = ADDI TargetFrameIndex:i16<0>, TargetConstant:i16<0>

SU(7): t14: ch = STORE16R<Mem:(store (s16) into %ir.1, align 4)> t2, t3, t0

SU(5): t20: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(4): t17: ch = STORE16R<Mem:(store (s16) into %ir.1 + 2, basealign 4)> t20, t3, t0

SU(9): t6: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(3): t18: ch = TokenFactor t14, t17

SU(2): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t6, t3, t18

SU(10): t13: i16 = MOVI TargetConstant:i16<1>

SU(11): t9: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(1): t19: ch = STORE8R<Mem:(store (s8) into %ir.3)> t9, t13, t7

SU(0): t12: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t19


Total amount of phi nodes to update: 0
Creating new node: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Creating new node: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Creating constant: t8: i16 = Constant<0>
Creating new node: t9: i16 = undef
Creating new node: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Creating new node: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
Creating new node: t12: i32 = zero_extend t11
Creating constant: t13: i32 = Constant<32>
Creating new node: t15: i1 = setcc t12, Constant:i32<32>, setne:ch
Creating constant: t16: i1 = Constant<-1>
Creating new node: t17: i1 = xor t15, Constant:i1<-1>
Creating new node: t19: ch = brcond t10, t17, BasicBlock:ch< 0x16b38288fe0>
Creating new node: t21: ch = br t19, BasicBlock:ch< 0x16b38281b08>

Initial selection DAG: %bb.1 'main:'
SelectionDAG has 22 nodes:
  t1: i16 = GlobalAddress<ptr @input> 0
    t0: ch,glue = EntryToken
  t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
  t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
  t8: i16 = Constant<0>
  t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
            t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
          t12: i32 = zero_extend t11
        t15: i1 = setcc t12, Constant:i32<32>, setne:ch
      t17: i1 = xor t15, Constant:i1<-1>
    t19: ch = brcond t10, t17, BasicBlock:ch< 0x16b38288fe0>
  t21: ch = br t19, BasicBlock:ch< 0x16b38281b08>



Combining: t21: ch = br t19, BasicBlock:ch< 0x16b38281b08>

Combining: t20: ch = BasicBlock< 0x16b38281b08>

Combining: t19: ch = brcond t10, t17, BasicBlock:ch< 0x16b38288fe0>
Creating new node: t23: i1 = setcc t12, Constant:i32<32>, seteq:ch
Creating new node: t24: ch = brcond t10, t23, BasicBlock:ch< 0x16b38288fe0>
 ... into: t24: ch = brcond t10, t23, BasicBlock:ch< 0x16b38288fe0>

Combining: t24: ch = brcond t10, t23, BasicBlock:ch< 0x16b38288fe0>

Combining: t23: i1 = setcc t12, Constant:i32<32>, seteq:ch
Creating constant: t25: i16 = Constant<32>
Creating new node: t26: i1 = setcc t11, Constant:i16<32>, seteq:ch
 ... into: t26: i1 = setcc t11, Constant:i16<32>, seteq:ch

Combining: t26: i1 = setcc t11, Constant:i16<32>, seteq:ch

Combining: t25: i16 = Constant<32>

Combining: t24: ch = brcond t10, t26, BasicBlock:ch< 0x16b38288fe0>
Creating new node: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
 ... into: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>

Combining: t25: i16 = Constant<32>

Combining: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>

Combining: t22: ch = seteq

Combining: t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>

Combining: t18: ch = BasicBlock< 0x16b38288fe0>

Combining: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16

Combining: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16

Combining: t9: i16 = undef

Combining: t7: i16 = FrameIndex<3>

Combining: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

Combining: t5: i16 = Register $r1

Combining: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Combining: t3: Untyped = RegisterMask

Combining: t2: i16 = TargetGlobalAddress<ptr @input> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.1 'main:'
SelectionDAG has 16 nodes:
    t0: ch,glue = EntryToken
  t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
  t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
  t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
      t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
    t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
  t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>



Legalizing node: t25: i16 = Constant<32>
Analyzing result type: i16
Legal result type
Legally typed node: t25: i16 = Constant<32>

Legalizing node: t22: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t22: ch = seteq

Legalizing node: t20: ch = BasicBlock< 0x16b38281b08>
Analyzing result type: ch
Legal result type
Legally typed node: t20: ch = BasicBlock< 0x16b38281b08>

Legalizing node: t18: ch = BasicBlock< 0x16b38288fe0>
Analyzing result type: ch
Legal result type
Legally typed node: t18: ch = BasicBlock< 0x16b38288fe0>

Legalizing node: t9: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t9: i16 = undef

Legalizing node: t7: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t7: i16 = FrameIndex<3>

Legalizing node: t5: i16 = Register $r1
Ignoring node results
Legally typed node: t5: i16 = Register $r1

Legalizing node: t3: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t3: Untyped = RegisterMask

Legalizing node: t2: i16 = TargetGlobalAddress<ptr @input> 0
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = TargetGlobalAddress<ptr @input> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t2: i16 = TargetGlobalAddress<ptr @input> 0
Legal operand
Analyzing operand: t3: Untyped = RegisterMask
Legal operand
Legally typed node: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Legalizing node: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

Legalizing node: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Legal operand
Analyzing operand: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Legal operand
Analyzing operand: t7: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t9: i16 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16

Legalizing node: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t7: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t9: i16 = undef
Legal operand
Legally typed node: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16

Legalizing node: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t22: ch = seteq
Legal operand
Analyzing operand: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t25: i16 = Constant<32>
Legal operand
Analyzing operand: t18: ch = BasicBlock< 0x16b38288fe0>
Legal operand
Legally typed node: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>

Legalizing node: t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
Legal operand
Analyzing operand: t20: ch = BasicBlock< 0x16b38281b08>
Legal operand
Legally typed node: t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>

Legalizing node: t65535: ch = handlenode t21
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>
Legal operand
Legally typed node: t65535: ch = handlenode t21

Type-legalized selection DAG: %bb.1 'main:'
SelectionDAG has 16 nodes:
    t0: ch,glue = EntryToken
  t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
  t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
  t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
      t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
    t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
  t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>



Legalizing: t21: ch = br t27, BasicBlock:ch< 0x16b38281b08>
Legal node: nothing to do

Legalizing: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
Trying custom legalization
Creating new node: t28: glue = SymphonyISD::CMP t11, Constant:i16<32>
Creating constant: t29: i16 = Constant<1>
Creating new node: t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28
Successfully custom legalized node
 ... replacing: t27: ch = br_cc t10, seteq:ch, t11, Constant:i16<32>, BasicBlock:ch< 0x16b38288fe0>
     with:      t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28

Legalizing: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Legal node: nothing to do

Legalizing: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t25: i16 = Constant<32>
Legal node: nothing to do

Legalizing: t20: ch = BasicBlock< 0x16b38281b08>
Legal node: nothing to do

Legalizing: t18: ch = BasicBlock< 0x16b38288fe0>
Legal node: nothing to do

Legalizing: t9: i16 = undef
Legal node: nothing to do

Legalizing: t7: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t5: i16 = Register $r1

Legalizing: t3: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t2: i16 = TargetGlobalAddress<ptr @input> 0
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28
Legal node: nothing to do

Legalizing: t29: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t28: glue = SymphonyISD::CMP t11, Constant:i16<32>
Legal node: nothing to do

Legalized selection DAG: %bb.1 'main:'
SelectionDAG has 17 nodes:
    t0: ch,glue = EntryToken
  t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
  t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
  t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
        t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
      t28: glue = SymphonyISD::CMP t11, Constant:i16<32>
    t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28
  t21: ch = br t30, BasicBlock:ch< 0x16b38281b08>



Legalizing: t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28
Legal node: nothing to do

Combining: t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28

Legalizing: t29: i16 = Constant<1>
Legal node: nothing to do

Combining: t29: i16 = Constant<1>

Legalizing: t28: glue = SymphonyISD::CMP t11, Constant:i16<32>
Legal node: nothing to do

Combining: t28: glue = SymphonyISD::CMP t11, Constant:i16<32>

Legalizing: t21: ch = br t30, BasicBlock:ch< 0x16b38281b08>
Legal node: nothing to do

Combining: t21: ch = br t30, BasicBlock:ch< 0x16b38281b08>

Legalizing: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16

Legalizing: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16

Legalizing: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Legal node: nothing to do

Combining: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

Legalizing: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Legalizing: t25: i16 = Constant<32>
Legal node: nothing to do

Combining: t25: i16 = Constant<32>

Legalizing: t20: ch = BasicBlock< 0x16b38281b08>
Legal node: nothing to do

Combining: t20: ch = BasicBlock< 0x16b38281b08>

Legalizing: t18: ch = BasicBlock< 0x16b38288fe0>
Legal node: nothing to do

Combining: t18: ch = BasicBlock< 0x16b38288fe0>

Legalizing: t9: i16 = undef
Legal node: nothing to do

Combining: t9: i16 = undef

Legalizing: t7: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t7: i16 = FrameIndex<3>

Legalizing: t5: i16 = Register $r1

Combining: t5: i16 = Register $r1

Legalizing: t3: Untyped = RegisterMask
Legal node: nothing to do

Combining: t3: Untyped = RegisterMask

Legalizing: t2: i16 = TargetGlobalAddress<ptr @input> 0
Legal node: nothing to do

Combining: t2: i16 = TargetGlobalAddress<ptr @input> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.1 'main:'
SelectionDAG has 17 nodes:
    t0: ch,glue = EntryToken
  t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
  t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
  t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
        t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
      t28: glue = SymphonyISD::CMP t11, Constant:i16<32>
    t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28
  t21: ch = br t30, BasicBlock:ch< 0x16b38281b08>


===== Instruction selection begins: %bb.1 ''

ISEL: Starting selection on root node: t21: ch = br t30, BasicBlock:ch< 0x16b38281b08>
Selecting: t21: ch = br t30, BasicBlock:ch< 0x16b38281b08>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t21: ch = JMPI BasicBlock:ch< 0x16b38281b08>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28
Selecting: t30: ch = SymphonyISD::BR_CC t10, BasicBlock:ch< 0x16b38288fe0>, Constant:i16<1>, t28

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t30: ch = JEI BasicBlock:ch< 0x16b38288fe0>, t10, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t28: glue = SymphonyISD::CMP t11, Constant:i16<32>
Selecting: t28: glue = SymphonyISD::CMP t11, Constant:i16<32>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t31: i16 = TargetConstant<32>
  Morphed node: t28: i16,glue = CMPI t11, TargetConstant:i16<32>
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16
Selecting: t11: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t10, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t11: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16
Selecting: t10: ch = store<(store (s16) into %ir.4)> t6:1, t6, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t10: ch = STORE16R<Mem:(store (s16) into %ir.4)> FrameIndex:i16<3>, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
Selecting: t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1


ISEL: Starting selection on root node: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Selecting: t4: ch,glue = SymphonyISD::Call t0, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

ISEL: Starting pattern match
  Initial Opcode index to 859
  Morphed node: t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = BasicBlock< 0x16b38281b08>
Selecting: t20: ch = BasicBlock< 0x16b38281b08>


ISEL: Starting selection on root node: t18: ch = BasicBlock< 0x16b38288fe0>
Selecting: t18: ch = BasicBlock< 0x16b38288fe0>


ISEL: Starting selection on root node: t7: i16 = FrameIndex<3>
Selecting: t7: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t33: i16 = TargetConstant<0>
  Morphed node: t7: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i16 = Register $r1
Selecting: t5: i16 = Register $r1


ISEL: Starting selection on root node: t3: Untyped = RegisterMask
Selecting: t3: Untyped = RegisterMask


ISEL: Starting selection on root node: t2: i16 = TargetGlobalAddress<ptr @input> 0
Selecting: t2: i16 = TargetGlobalAddress<ptr @input> 0


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.1 'main:'
SelectionDAG has 17 nodes:
  t7: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
    t0: ch,glue = EntryToken
  t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0
  t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1
  t10: ch = STORE16R<Mem:(store (s16) into %ir.4)> t7, t6, t6:1
        t11: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t7, t10
      t28: i16,glue = CMPI t11, TargetConstant:i16<32>
    t30: ch = JEI BasicBlock:ch< 0x16b38288fe0>, t10, t28:1
  t21: ch = JMPI BasicBlock:ch< 0x16b38281b08>, t30


********** List Scheduling %bb.1 '' **********
SU(0): t21: ch = JMPI BasicBlock:ch< 0x16b38281b08>, t30

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t30: ch = JEI BasicBlock:ch< 0x16b38288fe0>, t10, t28:1

    t28: i16,glue = CMPI t11, TargetConstant:i16<32>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t11: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t7, t10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
SU(3): t7: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
    SU(4): Data Latency=1
SU(4): t10: ch = STORE16R<Mem:(store (s16) into %ir.4)> t7, t6, t6:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
    SU(5): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
SU(5): t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

    t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(4): Data Latency=1
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t21: ch = JMPI BasicBlock:ch< 0x16b38281b08>, t30


*** Scheduling [0]: SU(0): t21: ch = JMPI BasicBlock:ch< 0x16b38281b08>, t30


Examining Available:
Height 1: SU(1): t30: ch = JEI BasicBlock:ch< 0x16b38288fe0>, t10, t28:1

    t28: i16,glue = CMPI t11, TargetConstant:i16<32>


*** Scheduling [1]: SU(1): t30: ch = JEI BasicBlock:ch< 0x16b38288fe0>, t10, t28:1

    t28: i16,glue = CMPI t11, TargetConstant:i16<32>


Examining Available:
Height 2: SU(2): t11: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t7, t10


*** Scheduling [2]: SU(2): t11: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t7, t10


Examining Available:
Height 3: SU(4): t10: ch = STORE16R<Mem:(store (s16) into %ir.4)> t7, t6, t6:1


*** Scheduling [3]: SU(4): t10: ch = STORE16R<Mem:(store (s16) into %ir.4)> t7, t6, t6:1


Examining Available:
Height 4: SU(3): t7: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 4: SU(5): t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

    t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0


*** Scheduling [4]: SU(3): t7: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 4: SU(5): t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

    t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0


*** Scheduling [5]: SU(5): t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

    t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0

*** Final schedule ***
SU(5): t6: i16,ch,glue = CopyFromReg t4, Register:i16 $r1, t4:1

    t4: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t0

SU(3): t7: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(4): t10: ch = STORE16R<Mem:(store (s16) into %ir.4)> t7, t6, t6:1

SU(2): t11: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t7, t10

SU(1): t30: ch = JEI BasicBlock:ch< 0x16b38288fe0>, t10, t28:1

    t28: i16,glue = CMPI t11, TargetConstant:i16<32>

SU(0): t21: ch = JMPI BasicBlock:ch< 0x16b38281b08>, t30


Total amount of phi nodes to update: 0
Creating constant: t1: i8 = Constant<1>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38289128>

Initial selection DAG: %bb.36 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38289128>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38289128>

Combining: t6: ch = BasicBlock< 0x16b38289128>

Combining: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<2>

Combining: t1: i8 = Constant<1>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.36 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38289128>



Legalizing node: t6: ch = BasicBlock< 0x16b38289128>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38289128>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<2>

Legalizing node: t1: i8 = Constant<1>
Analyzing result type: i8
Promote integer result: t1: i8 = Constant<1>
Creating constant: t8: i16 = Constant<1>

Legalizing node: t8: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i8 = Constant<1>
Promote integer operand: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
Creating new node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Replacing: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<1>, FrameIndex:i16<2>, undef:i16
     with: t9: ch = store<(store (s8) into %ir.<badref>), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<1>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Legalizing node: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38289128>
Legal operand
Legally typed node: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.36 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>



Combining: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Combining: t8: i16 = Constant<1>

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

Combining: t6: ch = BasicBlock< 0x16b38289128>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.36 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Legal node: nothing to do

Legalizing: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Legalizing truncating store operations

Legalizing: t8: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38289128>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.36 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Legal node: nothing to do

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

Legalizing: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Legalizing truncating store operations

Combining: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

Legalizing: t8: i16 = Constant<1>
Legal node: nothing to do

Combining: t8: i16 = Constant<1>

Legalizing: t6: ch = BasicBlock< 0x16b38289128>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38289128>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.36 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>


===== Instruction selection begins: %bb.36 ''

ISEL: Starting selection on root node: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Selecting: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16
Selecting: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<1>, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> FrameIndex:i16<2>, Constant:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<1>
Selecting: t8: i16 = Constant<1>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t10: i16 = TargetConstant<1>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38289128>
Selecting: t6: ch = BasicBlock< 0x16b38289128>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<2>
Selecting: t2: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t12: i16 = TargetConstant<0>
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.36 'main:'
SelectionDAG has 9 nodes:
      t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
      t8: i16 = MOVI TargetConstant:i16<1>
      t0: ch,glue = EntryToken
    t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0
  t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


********** List Scheduling %bb.36 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t8: i16 = MOVI TargetConstant:i16<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


Examining Available:
Height 1: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0


*** Scheduling [1]: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0


Examining Available:
Height 2: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<1>


*** Scheduling [2]: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<1>


*** Scheduling [3]: SU(2): t8: i16 = MOVI TargetConstant:i16<1>

*** Final schedule ***
SU(2): t8: i16 = MOVI TargetConstant:i16<1>

SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16
Creating constant: t5: i8 = Constant<0>
Creating new node: t7: i1 = setcc t4, Constant:i8<0>, setne:ch
Creating constant: t8: i1 = Constant<-1>
Creating new node: t9: i1 = xor t7, Constant:i1<-1>
Creating new node: t11: ch = brcond t0, t9, BasicBlock:ch< 0x16b38288e98>
Creating new node: t13: ch = br t11, BasicBlock:ch< 0x16b38281c50>

Initial selection DAG: %bb.2 'main:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
          t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16
        t7: i1 = setcc t4, Constant:i8<0>, setne:ch
      t9: i1 = xor t7, Constant:i1<-1>
    t11: ch = brcond t0, t9, BasicBlock:ch< 0x16b38288e98>
  t13: ch = br t11, BasicBlock:ch< 0x16b38281c50>



Combining: t13: ch = br t11, BasicBlock:ch< 0x16b38281c50>

Combining: t12: ch = BasicBlock< 0x16b38281c50>

Combining: t11: ch = brcond t0, t9, BasicBlock:ch< 0x16b38288e98>
Creating new node: t15: i1 = setcc t4, Constant:i8<0>, seteq:ch
Creating new node: t16: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288e98>
 ... into: t16: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288e98>

Combining: t16: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288e98>

Combining: t15: i1 = setcc t4, Constant:i8<0>, seteq:ch

Combining: t14: ch = seteq

Combining: t13: ch = br t16, BasicBlock:ch< 0x16b38281c50>

Combining: t10: ch = BasicBlock< 0x16b38288e98>

Combining: t5: i8 = Constant<0>

Combining: t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.2 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16
      t15: i1 = setcc t4, Constant:i8<0>, seteq:ch
    t16: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288e98>
  t13: ch = br t16, BasicBlock:ch< 0x16b38281c50>



Legalizing node: t14: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = seteq

Legalizing node: t12: ch = BasicBlock< 0x16b38281c50>
Analyzing result type: ch
Legal result type
Legally typed node: t12: ch = BasicBlock< 0x16b38281c50>

Legalizing node: t10: ch = BasicBlock< 0x16b38288e98>
Analyzing result type: ch
Legal result type
Legally typed node: t10: ch = BasicBlock< 0x16b38288e98>

Legalizing node: t5: i8 = Constant<0>
Analyzing result type: i8
Promote integer result: t5: i8 = Constant<0>
Creating constant: t17: i16 = Constant<0>

Legalizing node: t17: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t17: i16 = Constant<0>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i8
Promote integer result: t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16
Creating new node: t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t15: i1 = setcc t4, Constant:i8<0>, seteq:ch
Analyzing result type: i1
Promote integer result: t15: i1 = setcc t4, Constant:i8<0>, seteq:ch
Creating new node: t19: i16 = setcc t4, Constant:i8<0>, seteq:ch

Legalizing node: t16: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288e98>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i1 = setcc t4, Constant:i8<0>, seteq:ch
Promote integer operand: t16: ch = brcond t0, t15, BasicBlock:ch< 0x16b38288e98>
Creating new node: t20: i16 = any_extend t15

Legalizing node: t20: i16 = any_extend t15
Analyzing result type: i16
Legal result type
Analyzing operand: t15: i1 = setcc t4, Constant:i8<0>, seteq:ch
Promote integer operand: t20: i16 = any_extend t15
Replacing: t20: i16 = any_extend t15
     with: t19: i16 = setcc t4, Constant:i8<0>, seteq:ch

Legalizing node: t19: i16 = setcc t4, Constant:i8<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i8,ch = load<(dereferenceable load (s8) from %ir.3)> t0, FrameIndex:i16<2>, undef:i16
Promote integer operand: t19: i16 = setcc t4, Constant:i8<0>, seteq:ch
Creating constant: t21: i16 = Constant<255>
Creating new node: t22: i16 = and t18, Constant:i16<255>

Legalizing node: t21: i16 = Constant<255>
Analyzing result type: i16
Legal result type
Legally typed node: t21: i16 = Constant<255>

Legalizing node: t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16

Legalizing node: t22: i16 = and t18, Constant:i16<255>
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t21: i16 = Constant<255>
Legal operand
Legally typed node: t22: i16 = and t18, Constant:i16<255>

Legalizing node: t19: i16 = setcc t22, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t22: i16 = and t18, Constant:i16<255>
Legal operand
Analyzing operand: t17: i16 = Constant<0>
Legal operand
Analyzing operand: t14: ch = seteq
Legal operand
Legally typed node: t19: i16 = setcc t22, Constant:i16<0>, seteq:ch

Legalizing node: t16: ch = brcond t0, t19, BasicBlock:ch< 0x16b38288e98>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t19: i16 = setcc t22, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t10: ch = BasicBlock< 0x16b38288e98>
Legal operand
Legally typed node: t16: ch = brcond t0, t19, BasicBlock:ch< 0x16b38288e98>

Legalizing node: t13: ch = br t16, BasicBlock:ch< 0x16b38281c50>
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = brcond t0, t19, BasicBlock:ch< 0x16b38288e98>
Legal operand
Analyzing operand: t12: ch = BasicBlock< 0x16b38281c50>
Legal operand
Legally typed node: t13: ch = br t16, BasicBlock:ch< 0x16b38281c50>

Legalizing node: t65535: ch = handlenode t13
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = br t16, BasicBlock:ch< 0x16b38281c50>
Legal operand
Legally typed node: t65535: ch = handlenode t13

Type-legalized selection DAG: %bb.2 'main:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
          t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16
        t22: i16 = and t18, Constant:i16<255>
      t19: i16 = setcc t22, Constant:i16<0>, seteq:ch
    t16: ch = brcond t0, t19, BasicBlock:ch< 0x16b38288e98>
  t13: ch = br t16, BasicBlock:ch< 0x16b38281c50>



Combining: t22: i16 = and t18, Constant:i16<255>

Replacing.1 t22: i16 = and t18, Constant:i16<255>

With: t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16
 and 0 other values
Creating new node: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16

Replacing.1 t18: i16,ch = load<(dereferenceable load (s8) from %ir.3), anyext from i8> t0, FrameIndex:i16<2>, undef:i16

With: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
 and 1 other values

Combining: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16

Combining: t19: i16 = setcc t23, Constant:i16<0>, seteq:ch

Combining: t17: i16 = Constant<0>

Combining: t16: ch = brcond t0, t19, BasicBlock:ch< 0x16b38288e98>
Creating new node: t24: ch = br_cc t0, seteq:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288e98>
 ... into: t24: ch = br_cc t0, seteq:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288e98>

Combining: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16

Combining: t17: i16 = Constant<0>

Combining: t24: ch = br_cc t0, seteq:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288e98>

Combining: t14: ch = seteq

Combining: t13: ch = br t24, BasicBlock:ch< 0x16b38281c50>

Combining: t12: ch = BasicBlock< 0x16b38281c50>

Combining: t10: ch = BasicBlock< 0x16b38288e98>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.2 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
    t24: ch = br_cc t0, seteq:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288e98>
  t13: ch = br t24, BasicBlock:ch< 0x16b38281c50>



Legalizing: t13: ch = br t24, BasicBlock:ch< 0x16b38281c50>
Legal node: nothing to do

Legalizing: t24: ch = br_cc t0, seteq:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288e98>
Trying custom legalization
Creating new node: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Creating constant: t26: i16 = Constant<1>
Creating new node: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25
Successfully custom legalized node
 ... replacing: t24: ch = br_cc t0, seteq:ch, t23, Constant:i16<0>, BasicBlock:ch< 0x16b38288e98>
     with:      t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25

Legalizing: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
Legalizing extending load operation

Legalizing: t17: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t12: ch = BasicBlock< 0x16b38281c50>
Legal node: nothing to do

Legalizing: t10: ch = BasicBlock< 0x16b38288e98>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25
Legal node: nothing to do

Legalizing: t26: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.2 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
      t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
    t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25
  t13: ch = br t27, BasicBlock:ch< 0x16b38281c50>



Legalizing: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25
Legal node: nothing to do

Combining: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25

Legalizing: t26: i16 = Constant<1>
Legal node: nothing to do

Combining: t26: i16 = Constant<1>

Legalizing: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Legal node: nothing to do

Combining: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>

Legalizing: t13: ch = br t27, BasicBlock:ch< 0x16b38281c50>
Legal node: nothing to do

Combining: t13: ch = br t27, BasicBlock:ch< 0x16b38281c50>

Legalizing: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
Legalizing extending load operation

Combining: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16

Legalizing: t17: i16 = Constant<0>
Legal node: nothing to do

Combining: t17: i16 = Constant<0>

Legalizing: t12: ch = BasicBlock< 0x16b38281c50>
Legal node: nothing to do

Combining: t12: ch = BasicBlock< 0x16b38281c50>

Legalizing: t10: ch = BasicBlock< 0x16b38288e98>
Legal node: nothing to do

Combining: t10: ch = BasicBlock< 0x16b38288e98>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.2 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
      t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
    t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25
  t13: ch = br t27, BasicBlock:ch< 0x16b38281c50>


===== Instruction selection begins: %bb.2 ''

ISEL: Starting selection on root node: t13: ch = br t27, BasicBlock:ch< 0x16b38281c50>
Selecting: t13: ch = br t27, BasicBlock:ch< 0x16b38281c50>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t13: ch = JMPI BasicBlock:ch< 0x16b38281c50>, t27
ISEL: Match complete!

ISEL: Starting selection on root node: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25
Selecting: t27: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38288e98>, Constant:i16<1>, t25

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t27: ch = JEI BasicBlock:ch< 0x16b38288e98>, t0, t25
ISEL: Match complete!

ISEL: Starting selection on root node: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>
Selecting: t25: glue = SymphonyISD::CMP t23, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t28: i16 = TargetConstant<0>
  Morphed node: t25: i16,glue = CMPI t23, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16
Selecting: t23: i16,ch = load<(dereferenceable load (s8) from %ir.3), zext from i8> t0, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Skipped scope entry (due to false predicate) at index 302, continuing at 311
Creating new machine node: t29: i16,ch = LOAD8R FrameIndex:i16<2>, t0
  Created node: t29: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.3)> FrameIndex:i16<2>, t0
Creating constant: t30: i16 = TargetConstant<255>
Creating new machine node: t31: i16 = ANDI t29, TargetConstant:i16<255>
  Dropping mem operands
  Created node: t31: i16 = ANDI t29, TargetConstant:i16<255>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = BasicBlock< 0x16b38281c50>
Selecting: t12: ch = BasicBlock< 0x16b38281c50>


ISEL: Starting selection on root node: t10: ch = BasicBlock< 0x16b38288e98>
Selecting: t10: ch = BasicBlock< 0x16b38288e98>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<2>
Selecting: t1: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.2 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
            t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
          t29: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.3)> t1, t0
        t31: i16 = ANDI t29, TargetConstant:i16<255>
      t25: i16,glue = CMPI t31, TargetConstant:i16<0>
    t27: ch = JEI BasicBlock:ch< 0x16b38288e98>, t0, t25:1
  t13: ch = JMPI BasicBlock:ch< 0x16b38281c50>, t27


********** List Scheduling %bb.2 '' **********
SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38281c50>, t27

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t27: ch = JEI BasicBlock:ch< 0x16b38288e98>, t0, t25:1

    t25: i16,glue = CMPI t31, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t31: i16 = ANDI t29, TargetConstant:i16<255>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t29: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.3)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38281c50>, t27


*** Scheduling [0]: SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38281c50>, t27


Examining Available:
Height 1: SU(1): t27: ch = JEI BasicBlock:ch< 0x16b38288e98>, t0, t25:1

    t25: i16,glue = CMPI t31, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t27: ch = JEI BasicBlock:ch< 0x16b38288e98>, t0, t25:1

    t25: i16,glue = CMPI t31, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t31: i16 = ANDI t29, TargetConstant:i16<255>


*** Scheduling [2]: SU(2): t31: i16 = ANDI t29, TargetConstant:i16<255>


Examining Available:
Height 3: SU(3): t29: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.3)> t1, t0


*** Scheduling [3]: SU(3): t29: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.3)> t1, t0


Examining Available:
Height 4: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


*** Scheduling [4]: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

*** Final schedule ***
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(3): t29: i16,ch = LOAD8R<Mem:(dereferenceable load (s8) from %ir.3)> t1, t0

SU(2): t31: i16 = ANDI t29, TargetConstant:i16<255>

SU(1): t27: ch = JEI BasicBlock:ch< 0x16b38288e98>, t0, t25:1

    t25: i16,glue = CMPI t31, TargetConstant:i16<0>

SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38281c50>, t27


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<48>
Creating new node: t8: i1 = setcc Constant:i32<48>, t5, setle:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38282028>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38281d98>

Initial selection DAG: %bb.3 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc Constant:i32<48>, t5, setle:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t12, BasicBlock:ch< 0x16b38281d98>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38281d98>

Combining: t13: ch = BasicBlock< 0x16b38281d98>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38282028>
Creating new node: t16: i1 = setcc Constant:i32<48>, t5, setgt:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>

Combining: t16: i1 = setcc Constant:i32<48>, t5, setgt:ch
Creating new node: t19: i1 = setcc t5, Constant:i32<48>, setlt:ch
 ... into: t19: i1 = setcc t5, Constant:i32<48>, setlt:ch

Combining: t19: i1 = setcc t5, Constant:i32<48>, setlt:ch

Combining: t18: ch = setlt

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38282028>

Combining: t14: ch = br t17, BasicBlock:ch< 0x16b38281d98>

Combining: t11: ch = BasicBlock< 0x16b38282028>

Combining: t6: i32 = Constant<48>

Combining: t5: i32 = zero_extend t4
Creating new node: t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t5: i32 = zero_extend t4

With: t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t19: i1 = setcc t20, Constant:i32<48>, setlt:ch

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.3 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
      t19: i1 = setcc t20, Constant:i32<48>, setlt:ch
    t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t17, BasicBlock:ch< 0x16b38281d98>



Legalizing node: t18: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t18: ch = setlt

Legalizing node: t13: ch = BasicBlock< 0x16b38281d98>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38281d98>

Legalizing node: t11: ch = BasicBlock< 0x16b38282028>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282028>

Legalizing node: t6: i32 = Constant<48>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<48>
Creating constant: t21: i16 = Constant<48>
Creating constant: t22: i16 = Constant<0>

Legalizing node: t22: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t22: i16 = Constant<0>

Legalizing node: t21: i16 = Constant<48>
Analyzing result type: i16
Legal result type
Legally typed node: t21: i16 = Constant<48>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t19: i1 = setcc t20, Constant:i32<48>, setlt:ch
Analyzing result type: i1
Promote integer result: t19: i1 = setcc t20, Constant:i32<48>, setlt:ch
Creating new node: t24: i16 = setcc t20, Constant:i32<48>, setlt:ch

Legalizing node: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38282028>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t19: i1 = setcc t20, Constant:i32<48>, setlt:ch
Promote integer operand: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38282028>
Creating new node: t25: i16 = any_extend t19

Legalizing node: t25: i16 = any_extend t19
Analyzing result type: i16
Legal result type
Analyzing operand: t19: i1 = setcc t20, Constant:i32<48>, setlt:ch
Promote integer operand: t25: i16 = any_extend t19
Replacing: t25: i16 = any_extend t19
     with: t24: i16 = setcc t20, Constant:i32<48>, setlt:ch

Legalizing node: t24: i16 = setcc t20, Constant:i32<48>, setlt:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t20: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
Expand integer operand: t24: i16 = setcc t20, Constant:i32<48>, setlt:ch
Creating new node: t27: i16 = setcc t23, Constant:i16<48>, setult:ch

Legalizing node: t26: ch = setult
Analyzing result type: ch
Legal result type
Legally typed node: t26: ch = setult

Legalizing node: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t27: i16 = setcc t23, Constant:i16<48>, setult:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t21: i16 = Constant<48>
Legal operand
Analyzing operand: t26: ch = setult
Legal operand
Legally typed node: t27: i16 = setcc t23, Constant:i16<48>, setult:ch

Legalizing node: t17: ch = brcond t0, t27, BasicBlock:ch< 0x16b38282028>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t27: i16 = setcc t23, Constant:i16<48>, setult:ch
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282028>
Legal operand
Legally typed node: t17: ch = brcond t0, t27, BasicBlock:ch< 0x16b38282028>

Legalizing node: t14: ch = br t17, BasicBlock:ch< 0x16b38281d98>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = brcond t0, t27, BasicBlock:ch< 0x16b38282028>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38281d98>
Legal operand
Legally typed node: t14: ch = br t17, BasicBlock:ch< 0x16b38281d98>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t17, BasicBlock:ch< 0x16b38281d98>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.3 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t27: i16 = setcc t23, Constant:i16<48>, setult:ch
    t17: ch = brcond t0, t27, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t17, BasicBlock:ch< 0x16b38281d98>



Combining: t27: i16 = setcc t23, Constant:i16<48>, setult:ch

Combining: t26: ch = setult

Combining: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t21: i16 = Constant<48>

Combining: t17: ch = brcond t0, t27, BasicBlock:ch< 0x16b38282028>
Creating new node: t28: ch = br_cc t0, setult:ch, t23, Constant:i16<48>, BasicBlock:ch< 0x16b38282028>
 ... into: t28: ch = br_cc t0, setult:ch, t23, Constant:i16<48>, BasicBlock:ch< 0x16b38282028>

Combining: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t21: i16 = Constant<48>

Combining: t26: ch = setult

Combining: t28: ch = br_cc t0, setult:ch, t23, Constant:i16<48>, BasicBlock:ch< 0x16b38282028>

Combining: t14: ch = br t28, BasicBlock:ch< 0x16b38281d98>

Combining: t13: ch = BasicBlock< 0x16b38281d98>

Combining: t11: ch = BasicBlock< 0x16b38282028>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.3 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t28: ch = br_cc t0, setult:ch, t23, Constant:i16<48>, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t28, BasicBlock:ch< 0x16b38281d98>



Legalizing: t14: ch = br t28, BasicBlock:ch< 0x16b38281d98>
Legal node: nothing to do

Legalizing: t28: ch = br_cc t0, setult:ch, t23, Constant:i16<48>, BasicBlock:ch< 0x16b38282028>
Trying custom legalization
Creating new node: t29: glue = SymphonyISD::CMP t23, Constant:i16<48>
Creating constant: t30: i16 = Constant<4>
Creating new node: t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29
Successfully custom legalized node
 ... replacing: t28: ch = br_cc t0, setult:ch, t23, Constant:i16<48>, BasicBlock:ch< 0x16b38282028>
     with:      t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29

Legalizing: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16 = Constant<48>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38281d98>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282028>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29
Legal node: nothing to do

Legalizing: t30: i16 = Constant<4>
Legal node: nothing to do

Legalizing: t29: glue = SymphonyISD::CMP t23, Constant:i16<48>
Legal node: nothing to do

Legalized selection DAG: %bb.3 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t29: glue = SymphonyISD::CMP t23, Constant:i16<48>
    t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29
  t14: ch = br t31, BasicBlock:ch< 0x16b38281d98>



Legalizing: t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29
Legal node: nothing to do

Combining: t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29

Legalizing: t30: i16 = Constant<4>
Legal node: nothing to do

Combining: t30: i16 = Constant<4>

Legalizing: t29: glue = SymphonyISD::CMP t23, Constant:i16<48>
Legal node: nothing to do

Combining: t29: glue = SymphonyISD::CMP t23, Constant:i16<48>

Legalizing: t14: ch = br t31, BasicBlock:ch< 0x16b38281d98>
Legal node: nothing to do

Combining: t14: ch = br t31, BasicBlock:ch< 0x16b38281d98>

Legalizing: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16 = Constant<48>
Legal node: nothing to do

Combining: t21: i16 = Constant<48>

Legalizing: t13: ch = BasicBlock< 0x16b38281d98>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38281d98>

Legalizing: t11: ch = BasicBlock< 0x16b38282028>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282028>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.3 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t29: glue = SymphonyISD::CMP t23, Constant:i16<48>
    t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29
  t14: ch = br t31, BasicBlock:ch< 0x16b38281d98>


===== Instruction selection begins: %bb.3 ''

ISEL: Starting selection on root node: t14: ch = br t31, BasicBlock:ch< 0x16b38281d98>
Selecting: t14: ch = br t31, BasicBlock:ch< 0x16b38281d98>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38281d98>, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29
Selecting: t31: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<4>, t29

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Skipped scope entry (due to false predicate) at index 433, continuing at 442
  Morphed node: t31: ch = JLI BasicBlock:ch< 0x16b38282028>, t0, t29
ISEL: Match complete!

ISEL: Starting selection on root node: t29: glue = SymphonyISD::CMP t23, Constant:i16<48>
Selecting: t29: glue = SymphonyISD::CMP t23, Constant:i16<48>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t32: i16 = TargetConstant<48>
  Morphed node: t29: i16,glue = CMPI t23, TargetConstant:i16<48>
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t23: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t23: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38281d98>
Selecting: t13: ch = BasicBlock< 0x16b38281d98>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282028>
Selecting: t11: ch = BasicBlock< 0x16b38282028>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t34: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.3 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t23: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t29: i16,glue = CMPI t23, TargetConstant:i16<48>
    t31: ch = JLI BasicBlock:ch< 0x16b38282028>, t0, t29:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38281d98>, t31


********** List Scheduling %bb.3 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281d98>, t31

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t31: ch = JLI BasicBlock:ch< 0x16b38282028>, t0, t29:1

    t29: i16,glue = CMPI t23, TargetConstant:i16<48>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t23: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281d98>, t31


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281d98>, t31


Examining Available:
Height 1: SU(1): t31: ch = JLI BasicBlock:ch< 0x16b38282028>, t0, t29:1

    t29: i16,glue = CMPI t23, TargetConstant:i16<48>


*** Scheduling [1]: SU(1): t31: ch = JLI BasicBlock:ch< 0x16b38282028>, t0, t29:1

    t29: i16,glue = CMPI t23, TargetConstant:i16<48>


Examining Available:
Height 2: SU(2): t23: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t23: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t23: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t31: ch = JLI BasicBlock:ch< 0x16b38282028>, t0, t29:1

    t29: i16,glue = CMPI t23, TargetConstant:i16<48>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281d98>, t31


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<57>
Creating new node: t8: i1 = setcc t5, Constant:i32<57>, setle:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38282028>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38281ee0>

Initial selection DAG: %bb.4 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<57>, setle:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t12, BasicBlock:ch< 0x16b38281ee0>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38281ee0>

Combining: t13: ch = BasicBlock< 0x16b38281ee0>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38282028>
Creating new node: t16: i1 = setcc t5, Constant:i32<57>, setgt:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>

Combining: t16: i1 = setcc t5, Constant:i32<57>, setgt:ch

Combining: t15: ch = setgt

Combining: t14: ch = br t17, BasicBlock:ch< 0x16b38281ee0>

Combining: t11: ch = BasicBlock< 0x16b38282028>

Combining: t6: i32 = Constant<57>

Combining: t5: i32 = zero_extend t4
Creating new node: t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16

Replacing.1 t5: i32 = zero_extend t4

With: t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16

Combining: t16: i1 = setcc t18, Constant:i32<57>, setgt:ch

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.4 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
      t16: i1 = setcc t18, Constant:i32<57>, setgt:ch
    t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t17, BasicBlock:ch< 0x16b38281ee0>



Legalizing node: t15: ch = setgt
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setgt

Legalizing node: t13: ch = BasicBlock< 0x16b38281ee0>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38281ee0>

Legalizing node: t11: ch = BasicBlock< 0x16b38282028>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38282028>

Legalizing node: t6: i32 = Constant<57>
Analyzing result type: i32
Expand integer result: t6: i32 = Constant<57>
Creating constant: t19: i16 = Constant<57>
Creating constant: t20: i16 = Constant<0>

Legalizing node: t20: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t20: i16 = Constant<0>

Legalizing node: t19: i16 = Constant<57>
Analyzing result type: i16
Legal result type
Legally typed node: t19: i16 = Constant<57>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i32
Expand integer result: t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t16: i1 = setcc t18, Constant:i32<57>, setgt:ch
Analyzing result type: i1
Promote integer result: t16: i1 = setcc t18, Constant:i32<57>, setgt:ch
Creating new node: t22: i16 = setcc t18, Constant:i32<57>, setgt:ch

Legalizing node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t16: i1 = setcc t18, Constant:i32<57>, setgt:ch
Promote integer operand: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38282028>
Creating new node: t23: i16 = any_extend t16

Legalizing node: t23: i16 = any_extend t16
Analyzing result type: i16
Legal result type
Analyzing operand: t16: i1 = setcc t18, Constant:i32<57>, setgt:ch
Promote integer operand: t23: i16 = any_extend t16
Replacing: t23: i16 = any_extend t16
     with: t22: i16 = setcc t18, Constant:i32<57>, setgt:ch

Legalizing node: t22: i16 = setcc t18, Constant:i32<57>, setgt:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t18: i32,ch = load<(dereferenceable load (s16) from %ir.4), zext from i16> t0, FrameIndex:i16<3>, undef:i16
Expand integer operand: t22: i16 = setcc t18, Constant:i32<57>, setgt:ch
Creating new node: t25: i16 = setcc t21, Constant:i16<57>, setugt:ch

Legalizing node: t24: ch = setugt
Analyzing result type: ch
Legal result type
Legally typed node: t24: ch = setugt

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t25: i16 = setcc t21, Constant:i16<57>, setugt:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t19: i16 = Constant<57>
Legal operand
Analyzing operand: t24: ch = setugt
Legal operand
Legally typed node: t25: i16 = setcc t21, Constant:i16<57>, setugt:ch

Legalizing node: t17: ch = brcond t0, t25, BasicBlock:ch< 0x16b38282028>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t25: i16 = setcc t21, Constant:i16<57>, setugt:ch
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38282028>
Legal operand
Legally typed node: t17: ch = brcond t0, t25, BasicBlock:ch< 0x16b38282028>

Legalizing node: t14: ch = br t17, BasicBlock:ch< 0x16b38281ee0>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = brcond t0, t25, BasicBlock:ch< 0x16b38282028>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38281ee0>
Legal operand
Legally typed node: t14: ch = br t17, BasicBlock:ch< 0x16b38281ee0>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t17, BasicBlock:ch< 0x16b38281ee0>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.4 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t25: i16 = setcc t21, Constant:i16<57>, setugt:ch
    t17: ch = brcond t0, t25, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t17, BasicBlock:ch< 0x16b38281ee0>



Combining: t25: i16 = setcc t21, Constant:i16<57>, setugt:ch

Combining: t24: ch = setugt

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t19: i16 = Constant<57>

Combining: t17: ch = brcond t0, t25, BasicBlock:ch< 0x16b38282028>
Creating new node: t26: ch = br_cc t0, setugt:ch, t21, Constant:i16<57>, BasicBlock:ch< 0x16b38282028>
 ... into: t26: ch = br_cc t0, setugt:ch, t21, Constant:i16<57>, BasicBlock:ch< 0x16b38282028>

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t19: i16 = Constant<57>

Combining: t24: ch = setugt

Combining: t26: ch = br_cc t0, setugt:ch, t21, Constant:i16<57>, BasicBlock:ch< 0x16b38282028>

Combining: t14: ch = br t26, BasicBlock:ch< 0x16b38281ee0>

Combining: t13: ch = BasicBlock< 0x16b38281ee0>

Combining: t11: ch = BasicBlock< 0x16b38282028>

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.4 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t26: ch = br_cc t0, setugt:ch, t21, Constant:i16<57>, BasicBlock:ch< 0x16b38282028>
  t14: ch = br t26, BasicBlock:ch< 0x16b38281ee0>



Legalizing: t14: ch = br t26, BasicBlock:ch< 0x16b38281ee0>
Legal node: nothing to do

Legalizing: t26: ch = br_cc t0, setugt:ch, t21, Constant:i16<57>, BasicBlock:ch< 0x16b38282028>
Trying custom legalization
Creating new node: t27: glue = SymphonyISD::CMP t21, Constant:i16<57>
Creating constant: t28: i16 = Constant<13>
Creating new node: t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27
Successfully custom legalized node
 ... replacing: t26: ch = br_cc t0, setugt:ch, t21, Constant:i16<57>, BasicBlock:ch< 0x16b38282028>
     with:      t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t19: i16 = Constant<57>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38281ee0>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38282028>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27
Legal node: nothing to do

Legalizing: t28: i16 = Constant<13>
Legal node: nothing to do

Legalizing: t27: glue = SymphonyISD::CMP t21, Constant:i16<57>
Legal node: nothing to do

Legalized selection DAG: %bb.4 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t27: glue = SymphonyISD::CMP t21, Constant:i16<57>
    t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27
  t14: ch = br t29, BasicBlock:ch< 0x16b38281ee0>



Legalizing: t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27
Legal node: nothing to do

Combining: t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27

Legalizing: t28: i16 = Constant<13>
Legal node: nothing to do

Combining: t28: i16 = Constant<13>

Legalizing: t27: glue = SymphonyISD::CMP t21, Constant:i16<57>
Legal node: nothing to do

Combining: t27: glue = SymphonyISD::CMP t21, Constant:i16<57>

Legalizing: t14: ch = br t29, BasicBlock:ch< 0x16b38281ee0>
Legal node: nothing to do

Combining: t14: ch = br t29, BasicBlock:ch< 0x16b38281ee0>

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t19: i16 = Constant<57>
Legal node: nothing to do

Combining: t19: i16 = Constant<57>

Legalizing: t13: ch = BasicBlock< 0x16b38281ee0>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38281ee0>

Legalizing: t11: ch = BasicBlock< 0x16b38282028>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38282028>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.4 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t27: glue = SymphonyISD::CMP t21, Constant:i16<57>
    t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27
  t14: ch = br t29, BasicBlock:ch< 0x16b38281ee0>


===== Instruction selection begins: %bb.4 ''

ISEL: Starting selection on root node: t14: ch = br t29, BasicBlock:ch< 0x16b38281ee0>
Selecting: t14: ch = br t29, BasicBlock:ch< 0x16b38281ee0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38281ee0>, t29
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27
Selecting: t29: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38282028>, Constant:i16<13>, t27

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Skipped scope entry (due to false predicate) at index 433, continuing at 442
  Skipped scope entry (due to false predicate) at index 443, continuing at 452
  Skipped scope entry (due to false predicate) at index 453, continuing at 462
  Skipped scope entry (due to false predicate) at index 463, continuing at 472
  Morphed node: t29: ch = JGI BasicBlock:ch< 0x16b38282028>, t0, t27
ISEL: Match complete!

ISEL: Starting selection on root node: t27: glue = SymphonyISD::CMP t21, Constant:i16<57>
Selecting: t27: glue = SymphonyISD::CMP t21, Constant:i16<57>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t30: i16 = TargetConstant<57>
  Morphed node: t27: i16,glue = CMPI t21, TargetConstant:i16<57>
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38281ee0>
Selecting: t13: ch = BasicBlock< 0x16b38281ee0>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38282028>
Selecting: t11: ch = BasicBlock< 0x16b38282028>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t32: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.4 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t27: i16,glue = CMPI t21, TargetConstant:i16<57>
    t29: ch = JGI BasicBlock:ch< 0x16b38282028>, t0, t27:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38281ee0>, t29


********** List Scheduling %bb.4 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281ee0>, t29

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t29: ch = JGI BasicBlock:ch< 0x16b38282028>, t0, t27:1

    t27: i16,glue = CMPI t21, TargetConstant:i16<57>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281ee0>, t29


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281ee0>, t29


Examining Available:
Height 1: SU(1): t29: ch = JGI BasicBlock:ch< 0x16b38282028>, t0, t27:1

    t27: i16,glue = CMPI t21, TargetConstant:i16<57>


*** Scheduling [1]: SU(1): t29: ch = JGI BasicBlock:ch< 0x16b38282028>, t0, t27:1

    t27: i16,glue = CMPI t21, TargetConstant:i16<57>


Examining Available:
Height 2: SU(2): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t29: ch = JGI BasicBlock:ch< 0x16b38282028>, t0, t27:1

    t27: i16,glue = CMPI t21, TargetConstant:i16<57>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38281ee0>, t29


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
Creating new node: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Creating new node: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Creating new node: t13: i16 = AssertSext t11, ValueType:ch:i8
Creating new node: t14: i8 = truncate t13
Creating constant: t15: i8 = Constant<0>
Creating new node: t17: i1 = setcc t14, Constant:i8<0>, setne:ch
Creating constant: t18: i1 = Constant<-1>
Creating new node: t19: i1 = xor t17, Constant:i1<-1>
Creating new node: t21: ch = brcond t11:1, t19, BasicBlock:ch< 0x16b38288c08>
Creating new node: t23: ch = br t21, BasicBlock:ch< 0x16b38282170>

Initial selection DAG: %bb.6 'main:'
SelectionDAG has 24 nodes:
  t2: i16 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
  t5: i16 = GlobalAddress<ptr @is_op> 0
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
            t13: i16 = AssertSext t11, ValueType:ch:i8
          t14: i8 = truncate t13
        t17: i1 = setcc t14, Constant:i8<0>, setne:ch
      t19: i1 = xor t17, Constant:i1<-1>
    t21: ch = brcond t11:1, t19, BasicBlock:ch< 0x16b38288c08>
  t23: ch = br t21, BasicBlock:ch< 0x16b38282170>



Combining: t23: ch = br t21, BasicBlock:ch< 0x16b38282170>

Combining: t22: ch = BasicBlock< 0x16b38282170>

Combining: t21: ch = brcond t11:1, t19, BasicBlock:ch< 0x16b38288c08>
Creating new node: t25: i1 = setcc t14, Constant:i8<0>, seteq:ch
Creating new node: t26: ch = brcond t11:1, t25, BasicBlock:ch< 0x16b38288c08>
 ... into: t26: ch = brcond t11:1, t25, BasicBlock:ch< 0x16b38288c08>

Combining: t26: ch = brcond t11:1, t25, BasicBlock:ch< 0x16b38288c08>

Combining: t25: i1 = setcc t14, Constant:i8<0>, seteq:ch

Combining: t24: ch = seteq

Combining: t23: ch = br t26, BasicBlock:ch< 0x16b38282170>

Combining: t20: ch = BasicBlock< 0x16b38288c08>

Combining: t15: i8 = Constant<0>

Combining: t14: i8 = truncate t13

Combining: t13: i16 = AssertSext t11, ValueType:ch:i8

Combining: t12: ch = ValueType:i8

Combining: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

Combining: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1

Combining: t9: Untyped = RegisterMask

Combining: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

Combining: t7: i16 = Register $r1

Combining: t6: i16 = TargetGlobalAddress<ptr @is_op> 0

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.6 'main:'
SelectionDAG has 20 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
          t13: i16 = AssertSext t11, ValueType:ch:i8
        t14: i8 = truncate t13
      t25: i1 = setcc t14, Constant:i8<0>, seteq:ch
    t26: ch = brcond t11:1, t25, BasicBlock:ch< 0x16b38288c08>
  t23: ch = br t26, BasicBlock:ch< 0x16b38282170>



Legalizing node: t24: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t24: ch = seteq

Legalizing node: t22: ch = BasicBlock< 0x16b38282170>
Analyzing result type: ch
Legal result type
Legally typed node: t22: ch = BasicBlock< 0x16b38282170>

Legalizing node: t20: ch = BasicBlock< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Legally typed node: t20: ch = BasicBlock< 0x16b38288c08>

Legalizing node: t15: i8 = Constant<0>
Analyzing result type: i8
Promote integer result: t15: i8 = Constant<0>
Creating constant: t27: i16 = Constant<0>

Legalizing node: t27: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t27: i16 = Constant<0>

Legalizing node: t12: ch = ValueType:i8
Analyzing result type: ch
Legal result type
Legally typed node: t12: ch = ValueType:i8

Legalizing node: t9: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t9: Untyped = RegisterMask

Legalizing node: t7: i16 = Register $r1
Ignoring node results
Legally typed node: t7: i16 = Register $r1

Legalizing node: t6: i16 = TargetGlobalAddress<ptr @is_op> 0
Analyzing result type: i16
Legal result type
Legally typed node: t6: i16 = TargetGlobalAddress<ptr @is_op> 0

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Legally typed node: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

Legalizing node: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t6: i16 = TargetGlobalAddress<ptr @is_op> 0
Legal operand
Analyzing operand: t9: Untyped = RegisterMask
Legal operand
Analyzing operand: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
Legal operand
Legally typed node: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1

Legalizing node: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Legal operand
Analyzing operand: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Legal operand
Legally typed node: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

Legalizing node: t13: i16 = AssertSext t11, ValueType:ch:i8
Analyzing result type: i16
Legal result type
Analyzing operand: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Legal operand
Analyzing operand: t12: ch = ValueType:i8
Legal operand
Legally typed node: t13: i16 = AssertSext t11, ValueType:ch:i8

Legalizing node: t14: i8 = truncate t13
Analyzing result type: i8
Promote integer result: t14: i8 = truncate t13

Legalizing node: t25: i1 = setcc t14, Constant:i8<0>, seteq:ch
Analyzing result type: i1
Promote integer result: t25: i1 = setcc t14, Constant:i8<0>, seteq:ch
Creating new node: t28: i16 = setcc t14, Constant:i8<0>, seteq:ch

Legalizing node: t26: ch = brcond t11:1, t25, BasicBlock:ch< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Analyzing operand: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Legal operand
Analyzing operand: t25: i1 = setcc t14, Constant:i8<0>, seteq:ch
Promote integer operand: t26: ch = brcond t11:1, t25, BasicBlock:ch< 0x16b38288c08>
Creating new node: t29: i16 = any_extend t25

Legalizing node: t29: i16 = any_extend t25
Analyzing result type: i16
Legal result type
Analyzing operand: t25: i1 = setcc t14, Constant:i8<0>, seteq:ch
Promote integer operand: t29: i16 = any_extend t25
Replacing: t29: i16 = any_extend t25
     with: t28: i16 = setcc t14, Constant:i8<0>, seteq:ch

Legalizing node: t28: i16 = setcc t14, Constant:i8<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t14: i8 = truncate t13
Promote integer operand: t28: i16 = setcc t14, Constant:i8<0>, seteq:ch

Legalizing node: t28: i16 = setcc t13, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t13: i16 = AssertSext t11, ValueType:ch:i8
Legal operand
Analyzing operand: t27: i16 = Constant<0>
Legal operand
Analyzing operand: t24: ch = seteq
Legal operand
Legally typed node: t28: i16 = setcc t13, Constant:i16<0>, seteq:ch

Legalizing node: t26: ch = brcond t11:1, t28, BasicBlock:ch< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Analyzing operand: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Legal operand
Analyzing operand: t28: i16 = setcc t13, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t20: ch = BasicBlock< 0x16b38288c08>
Legal operand
Legally typed node: t26: ch = brcond t11:1, t28, BasicBlock:ch< 0x16b38288c08>

Legalizing node: t23: ch = br t26, BasicBlock:ch< 0x16b38282170>
Analyzing result type: ch
Legal result type
Analyzing operand: t26: ch = brcond t11:1, t28, BasicBlock:ch< 0x16b38288c08>
Legal operand
Analyzing operand: t22: ch = BasicBlock< 0x16b38282170>
Legal operand
Legally typed node: t23: ch = br t26, BasicBlock:ch< 0x16b38282170>

Legalizing node: t65535: ch = handlenode t23
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = br t26, BasicBlock:ch< 0x16b38282170>
Legal operand
Legally typed node: t65535: ch = handlenode t23

Type-legalized selection DAG: %bb.6 'main:'
SelectionDAG has 19 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
        t13: i16 = AssertSext t11, ValueType:ch:i8
      t28: i16 = setcc t13, Constant:i16<0>, seteq:ch
    t26: ch = brcond t11:1, t28, BasicBlock:ch< 0x16b38288c08>
  t23: ch = br t26, BasicBlock:ch< 0x16b38282170>



Combining: t28: i16 = setcc t13, Constant:i16<0>, seteq:ch

Combining: t27: i16 = Constant<0>

Combining: t26: ch = brcond t11:1, t28, BasicBlock:ch< 0x16b38288c08>
Creating new node: t30: ch = br_cc t11:1, seteq:ch, t13, Constant:i16<0>, BasicBlock:ch< 0x16b38288c08>
 ... into: t30: ch = br_cc t11:1, seteq:ch, t13, Constant:i16<0>, BasicBlock:ch< 0x16b38288c08>

Combining: t27: i16 = Constant<0>

Combining: t30: ch = br_cc t11:1, seteq:ch, t13, Constant:i16<0>, BasicBlock:ch< 0x16b38288c08>

Combining: t24: ch = seteq

Combining: t23: ch = br t30, BasicBlock:ch< 0x16b38282170>

Combining: t22: ch = BasicBlock< 0x16b38282170>

Combining: t20: ch = BasicBlock< 0x16b38288c08>

Combining: t13: i16 = AssertSext t11, ValueType:ch:i8

Combining: t12: ch = ValueType:i8

Combining: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

Combining: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1

Combining: t9: Untyped = RegisterMask

Combining: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

Combining: t7: i16 = Register $r1

Combining: t6: i16 = TargetGlobalAddress<ptr @is_op> 0

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.6 'main:'
SelectionDAG has 18 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
      t13: i16 = AssertSext t11, ValueType:ch:i8
    t30: ch = br_cc t11:1, seteq:ch, t13, Constant:i16<0>, BasicBlock:ch< 0x16b38288c08>
  t23: ch = br t30, BasicBlock:ch< 0x16b38282170>



Legalizing: t23: ch = br t30, BasicBlock:ch< 0x16b38282170>
Legal node: nothing to do

Legalizing: t30: ch = br_cc t11:1, seteq:ch, t13, Constant:i16<0>, BasicBlock:ch< 0x16b38288c08>
Trying custom legalization
Creating new node: t31: glue = SymphonyISD::CMP t13, Constant:i16<0>
Creating constant: t32: i16 = Constant<1>
Creating new node: t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31
Successfully custom legalized node
 ... replacing: t30: ch = br_cc t11:1, seteq:ch, t13, Constant:i16<0>, BasicBlock:ch< 0x16b38288c08>
     with:      t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31

Legalizing: t13: i16 = AssertSext t11, ValueType:ch:i8
Legal node: nothing to do

Legalizing: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Legal node: nothing to do

Legalizing: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
Legal node: nothing to do

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t27: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t22: ch = BasicBlock< 0x16b38282170>
Legal node: nothing to do

Legalizing: t20: ch = BasicBlock< 0x16b38288c08>
Legal node: nothing to do

Legalizing: t12: ch = ValueType:i8
Legal node: nothing to do

Legalizing: t9: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: i16 = Register $r1

Legalizing: t6: i16 = TargetGlobalAddress<ptr @is_op> 0
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31
Legal node: nothing to do

Legalizing: t32: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t31: glue = SymphonyISD::CMP t13, Constant:i16<0>
Legal node: nothing to do

Legalized selection DAG: %bb.6 'main:'
SelectionDAG has 19 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
        t13: i16 = AssertSext t11, ValueType:ch:i8
      t31: glue = SymphonyISD::CMP t13, Constant:i16<0>
    t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31
  t23: ch = br t33, BasicBlock:ch< 0x16b38282170>



Legalizing: t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31
Legal node: nothing to do

Combining: t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31

Legalizing: t32: i16 = Constant<1>
Legal node: nothing to do

Combining: t32: i16 = Constant<1>

Legalizing: t31: glue = SymphonyISD::CMP t13, Constant:i16<0>
Legal node: nothing to do

Combining: t31: glue = SymphonyISD::CMP t13, Constant:i16<0>

Legalizing: t23: ch = br t33, BasicBlock:ch< 0x16b38282170>
Legal node: nothing to do

Combining: t23: ch = br t33, BasicBlock:ch< 0x16b38282170>

Legalizing: t13: i16 = AssertSext t11, ValueType:ch:i8
Legal node: nothing to do

Combining: t13: i16 = AssertSext t11, ValueType:ch:i8

Legalizing: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Legal node: nothing to do

Combining: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

Legalizing: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Legal node: nothing to do

Combining: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1

Legalizing: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
Legal node: nothing to do

Combining: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t27: i16 = Constant<0>
Legal node: nothing to do

Combining: t27: i16 = Constant<0>

Legalizing: t22: ch = BasicBlock< 0x16b38282170>
Legal node: nothing to do

Combining: t22: ch = BasicBlock< 0x16b38282170>

Legalizing: t20: ch = BasicBlock< 0x16b38288c08>
Legal node: nothing to do

Combining: t20: ch = BasicBlock< 0x16b38288c08>

Legalizing: t12: ch = ValueType:i8
Legal node: nothing to do

Combining: t12: ch = ValueType:i8

Legalizing: t9: Untyped = RegisterMask
Legal node: nothing to do

Combining: t9: Untyped = RegisterMask

Legalizing: t7: i16 = Register $r1

Combining: t7: i16 = Register $r1

Legalizing: t6: i16 = TargetGlobalAddress<ptr @is_op> 0
Legal node: nothing to do

Combining: t6: i16 = TargetGlobalAddress<ptr @is_op> 0

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.6 'main:'
SelectionDAG has 19 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
        t13: i16 = AssertSext t11, ValueType:ch:i8
      t31: glue = SymphonyISD::CMP t13, Constant:i16<0>
    t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31
  t23: ch = br t33, BasicBlock:ch< 0x16b38282170>


===== Instruction selection begins: %bb.6 ''

ISEL: Starting selection on root node: t23: ch = br t33, BasicBlock:ch< 0x16b38282170>
Selecting: t23: ch = br t33, BasicBlock:ch< 0x16b38282170>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t23: ch = JMPI BasicBlock:ch< 0x16b38282170>, t33
ISEL: Match complete!

ISEL: Starting selection on root node: t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31
Selecting: t33: ch = SymphonyISD::BR_CC t11:1, BasicBlock:ch< 0x16b38288c08>, Constant:i16<1>, t31

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t33: ch = JEI BasicBlock:ch< 0x16b38288c08>, t11:1, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t31: glue = SymphonyISD::CMP t13, Constant:i16<0>
Selecting: t31: glue = SymphonyISD::CMP t13, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t34: i16 = TargetConstant<0>
  Morphed node: t31: i16,glue = CMPI t13, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t13: i16 = AssertSext t11, ValueType:ch:i8
Selecting: t13: i16 = AssertSext t11, ValueType:ch:i8


ISEL: Starting selection on root node: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
Selecting: t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1


ISEL: Starting selection on root node: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1
Selecting: t10: ch,glue = SymphonyISD::Call t4:1, TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t8:1

ISEL: Starting pattern match
  Initial Opcode index to 859
  Morphed node: t10: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t4:1, t8:1
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
Selecting: t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4


ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = BasicBlock< 0x16b38282170>
Selecting: t22: ch = BasicBlock< 0x16b38282170>


ISEL: Starting selection on root node: t20: ch = BasicBlock< 0x16b38288c08>
Selecting: t20: ch = BasicBlock< 0x16b38288c08>


ISEL: Starting selection on root node: t9: Untyped = RegisterMask
Selecting: t9: Untyped = RegisterMask


ISEL: Starting selection on root node: t7: i16 = Register $r1
Selecting: t7: i16 = Register $r1


ISEL: Starting selection on root node: t6: i16 = TargetGlobalAddress<ptr @is_op> 0
Selecting: t6: i16 = TargetGlobalAddress<ptr @is_op> 0


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.6 'main:'
SelectionDAG has 16 nodes:
    t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
    t0: ch,glue = EntryToken
  t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4
  t10: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t4:1, t8:1
  t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1
      t31: i16,glue = CMPI t11, TargetConstant:i16<0>
    t33: ch = JEI BasicBlock:ch< 0x16b38288c08>, t11:1, t31:1
  t23: ch = JMPI BasicBlock:ch< 0x16b38282170>, t33


********** List Scheduling %bb.6 '' **********
SU(0): t23: ch = JMPI BasicBlock:ch< 0x16b38282170>, t33

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t33: ch = JEI BasicBlock:ch< 0x16b38288c08>, t11:1, t31:1

    t31: i16,glue = CMPI t11, TargetConstant:i16<0>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(2): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

    t10: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t4:1, t8:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(1): Data Latency=1
SU(3): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t23: ch = JMPI BasicBlock:ch< 0x16b38282170>, t33


*** Scheduling [0]: SU(0): t23: ch = JMPI BasicBlock:ch< 0x16b38282170>, t33


Examining Available:
Height 1: SU(1): t33: ch = JEI BasicBlock:ch< 0x16b38288c08>, t11:1, t31:1

    t31: i16,glue = CMPI t11, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t33: ch = JEI BasicBlock:ch< 0x16b38288c08>, t11:1, t31:1

    t31: i16,glue = CMPI t11, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

    t10: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t4:1, t8:1


*** Scheduling [2]: SU(2): t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

    t10: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t4:1, t8:1


Examining Available:
Height 3: SU(3): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [3]: SU(3): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 4: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [4]: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(3): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(2): t11: i16,ch,glue = CopyFromReg t10, Register:i16 $r1, t10:1

    t8: ch,glue = CopyToReg t4:1, Register:i16 $r1, t4

    t10: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @is_op> 0, Register:i16 $r1, RegisterMask:Untyped, t4:1, t8:1

SU(1): t33: ch = JEI BasicBlock:ch< 0x16b38288c08>, t11:1, t31:1

    t31: i16,glue = CMPI t11, TargetConstant:i16<0>

SU(0): t23: ch = JMPI BasicBlock:ch< 0x16b38282170>, t33


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<43>
Creating new node: t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382869e8>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b382868a0>

Initial selection DAG: %bb.7 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<43>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382869e8>
  t14: ch = br t12, BasicBlock:ch< 0x16b382868a0>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b382868a0>

Combining: t13: ch = BasicBlock< 0x16b382868a0>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382869e8>
Creating new node: t16: i1 = setcc t5, Constant:i32<43>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382869e8>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382869e8>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382869e8>

Combining: t16: i1 = setcc t5, Constant:i32<43>, setne:ch
Creating constant: t18: i16 = Constant<43>
Creating new node: t19: i1 = setcc t4, Constant:i16<43>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<43>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<43>, setne:ch

Combining: t18: i16 = Constant<43>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b382869e8>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>

Combining: t18: i16 = Constant<43>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>

Combining: t11: ch = BasicBlock< 0x16b382869e8>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.7 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
  t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>



Legalizing node: t18: i16 = Constant<43>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<43>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b382868a0>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b382868a0>

Legalizing node: t11: ch = BasicBlock< 0x16b382869e8>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b382869e8>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<43>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b382869e8>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b382868a0>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.7 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
  t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b382868a0>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<43>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<43>, BasicBlock:ch< 0x16b382869e8>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<43>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b382868a0>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b382869e8>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<43>
Legal node: nothing to do

Legalized selection DAG: %bb.7 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<43>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b382868a0>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<43>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<43>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b382868a0>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b382868a0>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<43>
Legal node: nothing to do

Combining: t18: i16 = Constant<43>

Legalizing: t13: ch = BasicBlock< 0x16b382868a0>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b382868a0>

Legalizing: t11: ch = BasicBlock< 0x16b382869e8>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b382869e8>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.7 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<43>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b382868a0>


===== Instruction selection begins: %bb.7 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b382868a0>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b382868a0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b382868a0>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382869e8>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b382869e8>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<43>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<43>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<43>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<43>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b382868a0>
Selecting: t13: ch = BasicBlock< 0x16b382868a0>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b382869e8>
Selecting: t11: ch = BasicBlock< 0x16b382869e8>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.7 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<43>
    t23: ch = JNEI BasicBlock:ch< 0x16b382869e8>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b382868a0>, t23


********** List Scheduling %bb.7 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382868a0>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382869e8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<43>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382868a0>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382868a0>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382869e8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<43>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382869e8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<43>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382869e8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<43>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382868a0>, t23


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<45>
Creating new node: t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38286c78>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38286b30>

Initial selection DAG: %bb.9 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<45>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38286c78>
  t14: ch = br t12, BasicBlock:ch< 0x16b38286b30>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38286b30>

Combining: t13: ch = BasicBlock< 0x16b38286b30>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38286c78>
Creating new node: t16: i1 = setcc t5, Constant:i32<45>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38286c78>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38286c78>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38286c78>

Combining: t16: i1 = setcc t5, Constant:i32<45>, setne:ch
Creating constant: t18: i16 = Constant<45>
Creating new node: t19: i1 = setcc t4, Constant:i16<45>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<45>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<45>, setne:ch

Combining: t18: i16 = Constant<45>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38286c78>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>

Combining: t18: i16 = Constant<45>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>

Combining: t11: ch = BasicBlock< 0x16b38286c78>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.9 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
  t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>



Legalizing node: t18: i16 = Constant<45>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<45>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b38286b30>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38286b30>

Legalizing node: t11: ch = BasicBlock< 0x16b38286c78>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38286c78>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<45>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38286c78>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38286b30>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.9 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
  t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b38286b30>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<45>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<45>, BasicBlock:ch< 0x16b38286c78>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<45>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38286b30>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38286c78>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<45>
Legal node: nothing to do

Legalized selection DAG: %bb.9 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<45>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38286b30>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<45>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<45>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b38286b30>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b38286b30>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<45>
Legal node: nothing to do

Combining: t18: i16 = Constant<45>

Legalizing: t13: ch = BasicBlock< 0x16b38286b30>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38286b30>

Legalizing: t11: ch = BasicBlock< 0x16b38286c78>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38286c78>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.9 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<45>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38286b30>


===== Instruction selection begins: %bb.9 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b38286b30>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b38286b30>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38286b30>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286c78>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b38286c78>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<45>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<45>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<45>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<45>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38286b30>
Selecting: t13: ch = BasicBlock< 0x16b38286b30>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38286c78>
Selecting: t11: ch = BasicBlock< 0x16b38286c78>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.9 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<45>
    t23: ch = JNEI BasicBlock:ch< 0x16b38286c78>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38286b30>, t23


********** List Scheduling %bb.9 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286b30>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286c78>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<45>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286b30>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286b30>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286c78>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<45>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286c78>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<45>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286c78>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<45>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286b30>, t23


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<124>
Creating new node: t8: i1 = setcc t5, Constant:i32<124>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38286f08>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38286dc0>

Initial selection DAG: %bb.11 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<124>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38286f08>
  t14: ch = br t12, BasicBlock:ch< 0x16b38286dc0>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38286dc0>

Combining: t13: ch = BasicBlock< 0x16b38286dc0>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38286f08>
Creating new node: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38286f08>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38286f08>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38286f08>

Combining: t16: i1 = setcc t5, Constant:i32<124>, setne:ch
Creating constant: t18: i16 = Constant<124>
Creating new node: t19: i1 = setcc t4, Constant:i16<124>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<124>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<124>, setne:ch

Combining: t18: i16 = Constant<124>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38286f08>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>

Combining: t18: i16 = Constant<124>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>

Combining: t11: ch = BasicBlock< 0x16b38286f08>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.11 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
  t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>



Legalizing node: t18: i16 = Constant<124>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<124>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b38286dc0>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38286dc0>

Legalizing node: t11: ch = BasicBlock< 0x16b38286f08>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38286f08>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<124>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38286f08>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38286dc0>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.11 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
  t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b38286dc0>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<124>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<124>, BasicBlock:ch< 0x16b38286f08>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<124>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38286dc0>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38286f08>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<124>
Legal node: nothing to do

Legalized selection DAG: %bb.11 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<124>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38286dc0>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<124>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<124>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b38286dc0>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b38286dc0>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<124>
Legal node: nothing to do

Combining: t18: i16 = Constant<124>

Legalizing: t13: ch = BasicBlock< 0x16b38286dc0>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38286dc0>

Legalizing: t11: ch = BasicBlock< 0x16b38286f08>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38286f08>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.11 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<124>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38286dc0>


===== Instruction selection begins: %bb.11 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b38286dc0>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b38286dc0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38286dc0>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38286f08>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b38286f08>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<124>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<124>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<124>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<124>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38286dc0>
Selecting: t13: ch = BasicBlock< 0x16b38286dc0>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38286f08>
Selecting: t11: ch = BasicBlock< 0x16b38286f08>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.11 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<124>
    t23: ch = JNEI BasicBlock:ch< 0x16b38286f08>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38286dc0>, t23


********** List Scheduling %bb.11 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286dc0>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286f08>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<124>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286dc0>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286dc0>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286f08>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<124>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286f08>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<124>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38286f08>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<124>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38286dc0>, t23


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<38>
Creating new node: t8: i1 = setcc t5, Constant:i32<38>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38287198>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38287050>

Initial selection DAG: %bb.13 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<38>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38287198>
  t14: ch = br t12, BasicBlock:ch< 0x16b38287050>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38287050>

Combining: t13: ch = BasicBlock< 0x16b38287050>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38287198>
Creating new node: t16: i1 = setcc t5, Constant:i32<38>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38287198>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38287198>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38287198>

Combining: t16: i1 = setcc t5, Constant:i32<38>, setne:ch
Creating constant: t18: i16 = Constant<38>
Creating new node: t19: i1 = setcc t4, Constant:i16<38>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<38>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<38>, setne:ch

Combining: t18: i16 = Constant<38>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38287198>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>

Combining: t18: i16 = Constant<38>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b38287050>

Combining: t11: ch = BasicBlock< 0x16b38287198>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.13 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
  t14: ch = br t20, BasicBlock:ch< 0x16b38287050>



Legalizing node: t18: i16 = Constant<38>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<38>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b38287050>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38287050>

Legalizing node: t11: ch = BasicBlock< 0x16b38287198>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38287198>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<38>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38287198>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b38287050>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38287050>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b38287050>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b38287050>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.13 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
  t14: ch = br t20, BasicBlock:ch< 0x16b38287050>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b38287050>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<38>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<38>, BasicBlock:ch< 0x16b38287198>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<38>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38287050>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38287198>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<38>
Legal node: nothing to do

Legalized selection DAG: %bb.13 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<38>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38287050>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<38>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<38>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b38287050>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b38287050>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<38>
Legal node: nothing to do

Combining: t18: i16 = Constant<38>

Legalizing: t13: ch = BasicBlock< 0x16b38287050>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38287050>

Legalizing: t11: ch = BasicBlock< 0x16b38287198>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38287198>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.13 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<38>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38287050>


===== Instruction selection begins: %bb.13 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b38287050>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b38287050>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38287050>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287198>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b38287198>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<38>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<38>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<38>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<38>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38287050>
Selecting: t13: ch = BasicBlock< 0x16b38287050>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38287198>
Selecting: t11: ch = BasicBlock< 0x16b38287198>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.13 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<38>
    t23: ch = JNEI BasicBlock:ch< 0x16b38287198>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38287050>, t23


********** List Scheduling %bb.13 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287050>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287198>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<38>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287050>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287050>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287198>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<38>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287198>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<38>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287198>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<38>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287050>, t23


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<94>
Creating new node: t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38287428>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b382872e0>

Initial selection DAG: %bb.15 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<94>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38287428>
  t14: ch = br t12, BasicBlock:ch< 0x16b382872e0>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b382872e0>

Combining: t13: ch = BasicBlock< 0x16b382872e0>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b38287428>
Creating new node: t16: i1 = setcc t5, Constant:i32<94>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38287428>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38287428>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b38287428>

Combining: t16: i1 = setcc t5, Constant:i32<94>, setne:ch
Creating constant: t18: i16 = Constant<94>
Creating new node: t19: i1 = setcc t4, Constant:i16<94>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<94>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<94>, setne:ch

Combining: t18: i16 = Constant<94>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b38287428>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>

Combining: t18: i16 = Constant<94>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>

Combining: t11: ch = BasicBlock< 0x16b38287428>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.15 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
  t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>



Legalizing node: t18: i16 = Constant<94>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<94>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b382872e0>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b382872e0>

Legalizing node: t11: ch = BasicBlock< 0x16b38287428>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b38287428>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<94>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b38287428>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b382872e0>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.15 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
  t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b382872e0>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<94>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<94>, BasicBlock:ch< 0x16b38287428>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<94>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b382872e0>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b38287428>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<94>
Legal node: nothing to do

Legalized selection DAG: %bb.15 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<94>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b382872e0>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<94>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<94>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b382872e0>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b382872e0>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<94>
Legal node: nothing to do

Combining: t18: i16 = Constant<94>

Legalizing: t13: ch = BasicBlock< 0x16b382872e0>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b382872e0>

Legalizing: t11: ch = BasicBlock< 0x16b38287428>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b38287428>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.15 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<94>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b382872e0>


===== Instruction selection begins: %bb.15 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b382872e0>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b382872e0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b382872e0>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38287428>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b38287428>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<94>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<94>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<94>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<94>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b382872e0>
Selecting: t13: ch = BasicBlock< 0x16b382872e0>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b38287428>
Selecting: t11: ch = BasicBlock< 0x16b38287428>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.15 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<94>
    t23: ch = JNEI BasicBlock:ch< 0x16b38287428>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b382872e0>, t23


********** List Scheduling %bb.15 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382872e0>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287428>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<94>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382872e0>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382872e0>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287428>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<94>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287428>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<94>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b38287428>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<94>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b382872e0>, t23


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<60>
Creating new node: t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382876b8>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38287570>

Initial selection DAG: %bb.17 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<60>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382876b8>
  t14: ch = br t12, BasicBlock:ch< 0x16b38287570>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38287570>

Combining: t13: ch = BasicBlock< 0x16b38287570>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382876b8>
Creating new node: t16: i1 = setcc t5, Constant:i32<60>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382876b8>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382876b8>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382876b8>

Combining: t16: i1 = setcc t5, Constant:i32<60>, setne:ch
Creating constant: t18: i16 = Constant<60>
Creating new node: t19: i1 = setcc t4, Constant:i16<60>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<60>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<60>, setne:ch

Combining: t18: i16 = Constant<60>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b382876b8>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>

Combining: t18: i16 = Constant<60>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b38287570>

Combining: t11: ch = BasicBlock< 0x16b382876b8>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.17 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
  t14: ch = br t20, BasicBlock:ch< 0x16b38287570>



Legalizing node: t18: i16 = Constant<60>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<60>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b38287570>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38287570>

Legalizing node: t11: ch = BasicBlock< 0x16b382876b8>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b382876b8>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<60>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b382876b8>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b38287570>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38287570>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b38287570>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b38287570>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.17 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
  t14: ch = br t20, BasicBlock:ch< 0x16b38287570>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b38287570>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<60>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<60>, BasicBlock:ch< 0x16b382876b8>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<60>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38287570>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b382876b8>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<60>
Legal node: nothing to do

Legalized selection DAG: %bb.17 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<60>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38287570>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<60>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<60>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b38287570>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b38287570>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<60>
Legal node: nothing to do

Combining: t18: i16 = Constant<60>

Legalizing: t13: ch = BasicBlock< 0x16b38287570>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38287570>

Legalizing: t11: ch = BasicBlock< 0x16b382876b8>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b382876b8>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.17 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<60>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38287570>


===== Instruction selection begins: %bb.17 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b38287570>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b38287570>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38287570>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382876b8>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b382876b8>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<60>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<60>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<60>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<60>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38287570>
Selecting: t13: ch = BasicBlock< 0x16b38287570>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b382876b8>
Selecting: t11: ch = BasicBlock< 0x16b382876b8>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.17 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<60>
    t23: ch = JNEI BasicBlock:ch< 0x16b382876b8>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38287570>, t23


********** List Scheduling %bb.17 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287570>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382876b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<60>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287570>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287570>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382876b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<60>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382876b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<60>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382876b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<60>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38287570>, t23


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Creating new node: t5: i32 = zero_extend t4
Creating constant: t6: i32 = Constant<62>
Creating new node: t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382836b8>
Creating new node: t14: ch = br t12, BasicBlock:ch< 0x16b38283570>

Initial selection DAG: %bb.19 'main:'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
            t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
          t5: i32 = zero_extend t4
        t8: i1 = setcc t5, Constant:i32<62>, seteq:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382836b8>
  t14: ch = br t12, BasicBlock:ch< 0x16b38283570>



Combining: t14: ch = br t12, BasicBlock:ch< 0x16b38283570>

Combining: t13: ch = BasicBlock< 0x16b38283570>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch< 0x16b382836b8>
Creating new node: t16: i1 = setcc t5, Constant:i32<62>, setne:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382836b8>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382836b8>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch< 0x16b382836b8>

Combining: t16: i1 = setcc t5, Constant:i32<62>, setne:ch
Creating constant: t18: i16 = Constant<62>
Creating new node: t19: i1 = setcc t4, Constant:i16<62>, setne:ch
 ... into: t19: i1 = setcc t4, Constant:i16<62>, setne:ch

Combining: t19: i1 = setcc t4, Constant:i16<62>, setne:ch

Combining: t18: i16 = Constant<62>

Combining: t17: ch = brcond t0, t19, BasicBlock:ch< 0x16b382836b8>
Creating new node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
 ... into: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>

Combining: t18: i16 = Constant<62>

Combining: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>

Combining: t15: ch = setne

Combining: t14: ch = br t20, BasicBlock:ch< 0x16b38283570>

Combining: t11: ch = BasicBlock< 0x16b382836b8>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<3>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.19 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
  t14: ch = br t20, BasicBlock:ch< 0x16b38283570>



Legalizing node: t18: i16 = Constant<62>
Analyzing result type: i16
Legal result type
Legally typed node: t18: i16 = Constant<62>

Legalizing node: t15: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setne

Legalizing node: t13: ch = BasicBlock< 0x16b38283570>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock< 0x16b38283570>

Legalizing node: t11: ch = BasicBlock< 0x16b382836b8>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock< 0x16b382836b8>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<3>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: ch = setne
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t18: i16 = Constant<62>
Legal operand
Analyzing operand: t11: ch = BasicBlock< 0x16b382836b8>
Legal operand
Legally typed node: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>

Legalizing node: t14: ch = br t20, BasicBlock:ch< 0x16b38283570>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
Legal operand
Analyzing operand: t13: ch = BasicBlock< 0x16b38283570>
Legal operand
Legally typed node: t14: ch = br t20, BasicBlock:ch< 0x16b38283570>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t20, BasicBlock:ch< 0x16b38283570>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.19 'main:'
SelectionDAG has 10 nodes:
  t0: ch,glue = EntryToken
      t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
    t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
  t14: ch = br t20, BasicBlock:ch< 0x16b38283570>



Legalizing: t14: ch = br t20, BasicBlock:ch< 0x16b38283570>
Legal node: nothing to do

Legalizing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
Trying custom legalization
Creating new node: t21: glue = SymphonyISD::CMP t4, Constant:i16<62>
Creating constant: t22: i16 = Constant<9>
Creating new node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21
Successfully custom legalized node
 ... replacing: t20: ch = br_cc t0, setne:ch, t4, Constant:i16<62>, BasicBlock:ch< 0x16b382836b8>
     with:      t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t18: i16 = Constant<62>
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock< 0x16b38283570>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock< 0x16b382836b8>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21
Legal node: nothing to do

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<62>
Legal node: nothing to do

Legalized selection DAG: %bb.19 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<62>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38283570>



Legalizing: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21
Legal node: nothing to do

Combining: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21

Legalizing: t22: i16 = Constant<9>
Legal node: nothing to do

Combining: t22: i16 = Constant<9>

Legalizing: t21: glue = SymphonyISD::CMP t4, Constant:i16<62>
Legal node: nothing to do

Combining: t21: glue = SymphonyISD::CMP t4, Constant:i16<62>

Legalizing: t14: ch = br t23, BasicBlock:ch< 0x16b38283570>
Legal node: nothing to do

Combining: t14: ch = br t23, BasicBlock:ch< 0x16b38283570>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

Legalizing: t18: i16 = Constant<62>
Legal node: nothing to do

Combining: t18: i16 = Constant<62>

Legalizing: t13: ch = BasicBlock< 0x16b38283570>
Legal node: nothing to do

Combining: t13: ch = BasicBlock< 0x16b38283570>

Legalizing: t11: ch = BasicBlock< 0x16b382836b8>
Legal node: nothing to do

Combining: t11: ch = BasicBlock< 0x16b382836b8>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<3>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.19 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
        t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
      t21: glue = SymphonyISD::CMP t4, Constant:i16<62>
    t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21
  t14: ch = br t23, BasicBlock:ch< 0x16b38283570>


===== Instruction selection begins: %bb.19 ''

ISEL: Starting selection on root node: t14: ch = br t23, BasicBlock:ch< 0x16b38283570>
Selecting: t14: ch = br t23, BasicBlock:ch< 0x16b38283570>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t14: ch = JMPI BasicBlock:ch< 0x16b38283570>, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21
Selecting: t23: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b382836b8>, Constant:i16<9>, t21

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Morphed node: t23: ch = JNEI BasicBlock:ch< 0x16b382836b8>, t0, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: glue = SymphonyISD::CMP t4, Constant:i16<62>
Selecting: t21: glue = SymphonyISD::CMP t4, Constant:i16<62>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t24: i16 = TargetConstant<62>
  Morphed node: t21: i16,glue = CMPI t4, TargetConstant:i16<62>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t0, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock< 0x16b38283570>
Selecting: t13: ch = BasicBlock< 0x16b38283570>


ISEL: Starting selection on root node: t11: ch = BasicBlock< 0x16b382836b8>
Selecting: t11: ch = BasicBlock< 0x16b382836b8>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<3>
Selecting: t1: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t26: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.19 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
          t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
        t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0
      t21: i16,glue = CMPI t4, TargetConstant:i16<62>
    t23: ch = JNEI BasicBlock:ch< 0x16b382836b8>, t0, t21:1
  t14: ch = JMPI BasicBlock:ch< 0x16b38283570>, t23


********** List Scheduling %bb.19 '' **********
SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38283570>, t23

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382836b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<62>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38283570>, t23


*** Scheduling [0]: SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38283570>, t23


Examining Available:
Height 1: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382836b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<62>


*** Scheduling [1]: SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382836b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<62>


Examining Available:
Height 2: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


*** Scheduling [2]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0


Examining Available:
Height 3: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


*** Scheduling [3]: SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

*** Final schedule ***
SU(3): t1: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t1, t0

SU(1): t23: ch = JNEI BasicBlock:ch< 0x16b382836b8>, t0, t21:1

    t21: i16,glue = CMPI t4, TargetConstant:i16<62>

SU(0): t14: ch = JMPI BasicBlock:ch< 0x16b38283570>, t23


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<6>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<6>, FrameIndex:i16<4>, undef:i16
Creating new node: t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Creating new node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Creating new node: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>

Initial selection DAG: %bb.20 'main:'
SelectionDAG has 14 nodes:
  t3: i16 = Constant<0>
  t6: i16 = GlobalAddress<ptr @input> 0
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<6>, FrameIndex:i16<4>, undef:i16
  t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>



Combining: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>

Combining: t12: ch = BasicBlock< 0x16b382836b8>

Combining: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Combining: t10: i16 = Register $r1

Combining: t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Combining: t8: Untyped = RegisterMask

Combining: t7: i16 = TargetGlobalAddress<ptr @input> 0

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<6>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<6>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.20 'main:'
SelectionDAG has 12 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<6>, FrameIndex:i16<4>, undef:i16
  t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>



Legalizing node: t12: ch = BasicBlock< 0x16b382836b8>
Analyzing result type: ch
Legal result type
Legally typed node: t12: ch = BasicBlock< 0x16b382836b8>

Legalizing node: t10: i16 = Register $r1
Ignoring node results
Legally typed node: t10: i16 = Register $r1

Legalizing node: t8: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t8: Untyped = RegisterMask

Legalizing node: t7: i16 = TargetGlobalAddress<ptr @input> 0
Analyzing result type: i16
Legal result type
Legally typed node: t7: i16 = TargetGlobalAddress<ptr @input> 0

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<6>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<6>
Creating constant: t14: i16 = Constant<6>
Creating constant: t15: i16 = Constant<0>

Legalizing node: t15: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t15: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<6>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<6>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<6>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<6>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<6>, FrameIndex:i16<4>, undef:i16
Creating new node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating constant: t17: i16 = Constant<2>
Creating new node: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t18, undef:i16
Creating new node: t20: ch = TokenFactor t16, t19

Legalizing node: t17: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t17: i16 = Constant<2>

Legalizing node: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t17: i16 = Constant<2>
Legal operand
Legally typed node: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t18, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t14: i16 = Constant<6>
Legal operand
Analyzing operand: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t18, undef:i16

Legalizing node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t20: ch = TokenFactor t16, t19
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t18, undef:i16
Legal operand
Legally typed node: t20: ch = TokenFactor t16, t19

Legalizing node: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch = TokenFactor t16, t19
Legal operand
Analyzing operand: t7: i16 = TargetGlobalAddress<ptr @input> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Legally typed node: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Legalizing node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Legalizing node: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>
Analyzing result type: ch
Legal result type
Analyzing operand: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Legal operand
Analyzing operand: t12: ch = BasicBlock< 0x16b382836b8>
Legal operand
Legally typed node: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>

Legalizing node: t65535: ch = handlenode t13
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>
Legal operand
Legally typed node: t65535: ch = handlenode t13

Type-legalized selection DAG: %bb.20 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t18, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>



Combining: t20: ch = TokenFactor t16, t19

Combining: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t18, undef:i16

Combining: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16

Combining: t17: i16 = Constant<2>

Combining: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t15: i16 = Constant<0>

Combining: t14: i16 = Constant<6>

Combining: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>

Combining: t12: ch = BasicBlock< 0x16b382836b8>

Combining: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Combining: t10: i16 = Register $r1

Combining: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Combining: t8: Untyped = RegisterMask

Combining: t7: i16 = TargetGlobalAddress<ptr @input> 0

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.20 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>



Legalizing: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>
Legal node: nothing to do

Legalizing: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Legal node: nothing to do

Legalizing: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t20: ch = TokenFactor t16, t19
Legal node: nothing to do

Legalizing: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t17: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t15: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t14: i16 = Constant<6>
Legal node: nothing to do

Legalizing: t12: ch = BasicBlock< 0x16b382836b8>
Legal node: nothing to do

Legalizing: t10: i16 = Register $r1

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: i16 = TargetGlobalAddress<ptr @input> 0
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.20 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>



Legalizing: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>
Legal node: nothing to do

Combining: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>

Legalizing: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Legal node: nothing to do

Combining: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Legalizing: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Legalizing: t20: ch = TokenFactor t16, t19
Legal node: nothing to do

Combining: t20: ch = TokenFactor t16, t19

Legalizing: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16

Legalizing: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t17: i16 = Constant<2>
Legal node: nothing to do

Combining: t17: i16 = Constant<2>

Legalizing: t15: i16 = Constant<0>
Legal node: nothing to do

Combining: t15: i16 = Constant<0>

Legalizing: t14: i16 = Constant<6>
Legal node: nothing to do

Combining: t14: i16 = Constant<6>

Legalizing: t12: ch = BasicBlock< 0x16b382836b8>
Legal node: nothing to do

Combining: t12: ch = BasicBlock< 0x16b382836b8>

Legalizing: t10: i16 = Register $r1

Combining: t10: i16 = Register $r1

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Combining: t8: Untyped = RegisterMask

Legalizing: t7: i16 = TargetGlobalAddress<ptr @input> 0
Legal node: nothing to do

Combining: t7: i16 = TargetGlobalAddress<ptr @input> 0

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.20 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>


===== Instruction selection begins: %bb.20 ''

ISEL: Starting selection on root node: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>
Selecting: t13: ch = br t11:1, BasicBlock:ch< 0x16b382836b8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t13: ch = JMPI BasicBlock:ch< 0x16b382836b8>, t11:1
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Selecting: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1


ISEL: Starting selection on root node: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Selecting: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

ISEL: Starting pattern match
  Initial Opcode index to 859
  Morphed node: t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = TokenFactor t16, t19
Selecting: t20: ch = TokenFactor t16, t19


ISEL: Starting selection on root node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16
Selecting: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<6>, t21, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, Constant:i16<6>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t22: i16 = TargetConstant<2>
  Morphed node: t21: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t15: i16 = Constant<0>
Selecting: t15: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t15: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = Constant<6>
Selecting: t14: i16 = Constant<6>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t24: i16 = TargetConstant<6>
  Morphed node: t14: i16 = MOVI TargetConstant:i16<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = BasicBlock< 0x16b382836b8>
Selecting: t12: ch = BasicBlock< 0x16b382836b8>


ISEL: Starting selection on root node: t10: i16 = Register $r1
Selecting: t10: i16 = Register $r1


ISEL: Starting selection on root node: t8: Untyped = RegisterMask
Selecting: t8: Untyped = RegisterMask


ISEL: Starting selection on root node: t7: i16 = TargetGlobalAddress<ptr @input> 0
Selecting: t7: i16 = TargetGlobalAddress<ptr @input> 0


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.20 'main:'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
        t15: i16 = MOVI TargetConstant:i16<0>
      t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0
        t21: i16 = ORI disjoint t2, TargetConstant:i16<2>
        t14: i16 = MOVI TargetConstant:i16<6>
      t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = JMPI BasicBlock:ch< 0x16b382836b8>, t11:1


********** List Scheduling %bb.20 '' **********
SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b382836b8>, t11:1

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t20: ch = TokenFactor t16, t19

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t14: i16 = MOVI TargetConstant:i16<6>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(8): t15: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(7): Data Latency=1

Examining Available:
Height 0: SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b382836b8>, t11:1


*** Scheduling [0]: SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b382836b8>, t11:1


Examining Available:
Height 1: SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20


*** Scheduling [1]: SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20


Examining Available:
Height 1: SU(2): t20: ch = TokenFactor t16, t19


*** Scheduling [2]: SU(2): t20: ch = TokenFactor t16, t19


Examining Available:
  Comparing latency of SU (7) depth 1 vs SU (3) depth 2
Height 3: SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0

Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0

  Comparing latency of SU (7) depth 1 vs SU (3) depth 2

*** Scheduling [3]: SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0


Examining Available:
Height 4: SU(4): t14: i16 = MOVI TargetConstant:i16<6>

Height 4: SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


*** Scheduling [4]: SU(4): t14: i16 = MOVI TargetConstant:i16<6>


Examining Available:
Height 4: SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


*** Scheduling [5]: SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


*** Scheduling [6]: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


Examining Available:
Height 7: SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 7: SU(8): t15: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [7]: SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 7: SU(8): t15: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [8]: SU(8): t15: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(8): t15: i16 = MOVI TargetConstant:i16<0>

SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0

SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(4): t14: i16 = MOVI TargetConstant:i16<6>

SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0

SU(2): t20: ch = TokenFactor t16, t19

SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20

SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b382836b8>, t11:1


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>

Initial selection DAG: %bb.21 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283800>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>

Combining: t1: ch = BasicBlock< 0x16b38283800>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.21 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283800>



Legalizing node: t1: ch = BasicBlock< 0x16b38283800>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38283800>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38283800>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.21 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283800>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38283800>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.21 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283800>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>

Legalizing: t1: ch = BasicBlock< 0x16b38283800>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38283800>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.21 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283800>


===== Instruction selection begins: %bb.21 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38283800>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38283800>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38283800>
Selecting: t1: ch = BasicBlock< 0x16b38283800>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.21 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38283800>, t0


********** List Scheduling %bb.21 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283800>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283800>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283800>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283800>, t0


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<5>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<5>, FrameIndex:i16<4>, undef:i16
Creating new node: t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Creating new node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Creating new node: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>

Initial selection DAG: %bb.18 'main:'
SelectionDAG has 14 nodes:
  t3: i16 = Constant<0>
  t6: i16 = GlobalAddress<ptr @input> 0
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<5>, FrameIndex:i16<4>, undef:i16
  t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>



Combining: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>

Combining: t12: ch = BasicBlock< 0x16b38283800>

Combining: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Combining: t10: i16 = Register $r1

Combining: t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Combining: t8: Untyped = RegisterMask

Combining: t7: i16 = TargetGlobalAddress<ptr @input> 0

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<5>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<5>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.18 'main:'
SelectionDAG has 12 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<5>, FrameIndex:i16<4>, undef:i16
  t9: ch,glue = SymphonyISD::Call t5, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>



Legalizing node: t12: ch = BasicBlock< 0x16b38283800>
Analyzing result type: ch
Legal result type
Legally typed node: t12: ch = BasicBlock< 0x16b38283800>

Legalizing node: t10: i16 = Register $r1
Ignoring node results
Legally typed node: t10: i16 = Register $r1

Legalizing node: t8: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t8: Untyped = RegisterMask

Legalizing node: t7: i16 = TargetGlobalAddress<ptr @input> 0
Analyzing result type: i16
Legal result type
Legally typed node: t7: i16 = TargetGlobalAddress<ptr @input> 0

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<5>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<5>
Creating constant: t14: i16 = Constant<5>
Creating constant: t15: i16 = Constant<0>

Legalizing node: t15: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t15: i16 = Constant<0>

Legalizing node: t14: i16 = Constant<5>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = Constant<5>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<5>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<5>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<5>, FrameIndex:i16<4>, undef:i16
Creating new node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating constant: t17: i16 = Constant<2>
Creating new node: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t18, undef:i16
Creating new node: t20: ch = TokenFactor t16, t19

Legalizing node: t17: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t17: i16 = Constant<2>

Legalizing node: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t17: i16 = Constant<2>
Legal operand
Legally typed node: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t18, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t14: i16 = Constant<5>
Legal operand
Analyzing operand: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t18, undef:i16

Legalizing node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t15: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t20: ch = TokenFactor t16, t19
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t18, undef:i16
Legal operand
Legally typed node: t20: ch = TokenFactor t16, t19

Legalizing node: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch = TokenFactor t16, t19
Legal operand
Analyzing operand: t7: i16 = TargetGlobalAddress<ptr @input> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Legally typed node: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Legalizing node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Legalizing node: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>
Analyzing result type: ch
Legal result type
Analyzing operand: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Legal operand
Analyzing operand: t12: ch = BasicBlock< 0x16b38283800>
Legal operand
Legally typed node: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>

Legalizing node: t65535: ch = handlenode t13
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>
Legal operand
Legally typed node: t65535: ch = handlenode t13

Type-legalized selection DAG: %bb.18 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t18, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>



Combining: t20: ch = TokenFactor t16, t19

Combining: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t18, undef:i16

Combining: t18: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16

Combining: t17: i16 = Constant<2>

Combining: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t15: i16 = Constant<0>

Combining: t14: i16 = Constant<5>

Combining: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>

Combining: t12: ch = BasicBlock< 0x16b38283800>

Combining: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Combining: t10: i16 = Register $r1

Combining: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Combining: t8: Untyped = RegisterMask

Combining: t7: i16 = TargetGlobalAddress<ptr @input> 0

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.18 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>



Legalizing: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>
Legal node: nothing to do

Legalizing: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Legal node: nothing to do

Legalizing: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t20: ch = TokenFactor t16, t19
Legal node: nothing to do

Legalizing: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t17: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t15: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t14: i16 = Constant<5>
Legal node: nothing to do

Legalizing: t12: ch = BasicBlock< 0x16b38283800>
Legal node: nothing to do

Legalizing: t10: i16 = Register $r1

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: i16 = TargetGlobalAddress<ptr @input> 0
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.18 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>



Legalizing: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>
Legal node: nothing to do

Combining: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>

Legalizing: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Legal node: nothing to do

Combining: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

Legalizing: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

Legalizing: t20: ch = TokenFactor t16, t19
Legal node: nothing to do

Combining: t20: ch = TokenFactor t16, t19

Legalizing: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16

Legalizing: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t17: i16 = Constant<2>
Legal node: nothing to do

Combining: t17: i16 = Constant<2>

Legalizing: t15: i16 = Constant<0>
Legal node: nothing to do

Combining: t15: i16 = Constant<0>

Legalizing: t14: i16 = Constant<5>
Legal node: nothing to do

Combining: t14: i16 = Constant<5>

Legalizing: t12: ch = BasicBlock< 0x16b38283800>
Legal node: nothing to do

Combining: t12: ch = BasicBlock< 0x16b38283800>

Legalizing: t10: i16 = Register $r1

Combining: t10: i16 = Register $r1

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Combining: t8: Untyped = RegisterMask

Legalizing: t7: i16 = TargetGlobalAddress<ptr @input> 0
Legal node: nothing to do

Combining: t7: i16 = TargetGlobalAddress<ptr @input> 0

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.18 'main:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>


===== Instruction selection begins: %bb.18 ''

ISEL: Starting selection on root node: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>
Selecting: t13: ch = br t11:1, BasicBlock:ch< 0x16b38283800>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t13: ch = JMPI BasicBlock:ch< 0x16b38283800>, t11:1
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
Selecting: t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1


ISEL: Starting selection on root node: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped
Selecting: t9: ch,glue = SymphonyISD::Call t20, TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped

ISEL: Starting pattern match
  Initial Opcode index to 859
  Morphed node: t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = TokenFactor t16, t19
Selecting: t20: ch = TokenFactor t16, t19


ISEL: Starting selection on root node: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16
Selecting: t19: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<5>, t21, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, Constant:i16<5>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t21: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t22: i16 = TargetConstant<2>
  Morphed node: t21: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t16: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t15: i16 = Constant<0>
Selecting: t15: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t23: i16 = TargetConstant<0>
  Morphed node: t15: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = Constant<5>
Selecting: t14: i16 = Constant<5>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t24: i16 = TargetConstant<5>
  Morphed node: t14: i16 = MOVI TargetConstant:i16<5>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = BasicBlock< 0x16b38283800>
Selecting: t12: ch = BasicBlock< 0x16b38283800>


ISEL: Starting selection on root node: t10: i16 = Register $r1
Selecting: t10: i16 = Register $r1


ISEL: Starting selection on root node: t8: Untyped = RegisterMask
Selecting: t8: Untyped = RegisterMask


ISEL: Starting selection on root node: t7: i16 = TargetGlobalAddress<ptr @input> 0
Selecting: t7: i16 = TargetGlobalAddress<ptr @input> 0


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.18 'main:'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
        t15: i16 = MOVI TargetConstant:i16<0>
      t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0
        t21: i16 = ORI disjoint t2, TargetConstant:i16<2>
        t14: i16 = MOVI TargetConstant:i16<5>
      t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0
    t20: ch = TokenFactor t16, t19
  t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20
    t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1
  t13: ch = JMPI BasicBlock:ch< 0x16b38283800>, t11:1


********** List Scheduling %bb.18 '' **********
SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38283800>, t11:1

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t20: ch = TokenFactor t16, t19

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t14: i16 = MOVI TargetConstant:i16<5>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(8): t15: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(7): Data Latency=1

Examining Available:
Height 0: SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38283800>, t11:1


*** Scheduling [0]: SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38283800>, t11:1


Examining Available:
Height 1: SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20


*** Scheduling [1]: SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20


Examining Available:
Height 1: SU(2): t20: ch = TokenFactor t16, t19


*** Scheduling [2]: SU(2): t20: ch = TokenFactor t16, t19


Examining Available:
  Comparing latency of SU (7) depth 1 vs SU (3) depth 2
Height 3: SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0

Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0

  Comparing latency of SU (7) depth 1 vs SU (3) depth 2

*** Scheduling [3]: SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0


Examining Available:
Height 4: SU(4): t14: i16 = MOVI TargetConstant:i16<5>

Height 4: SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


*** Scheduling [4]: SU(4): t14: i16 = MOVI TargetConstant:i16<5>


Examining Available:
Height 4: SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


*** Scheduling [5]: SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 3: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


*** Scheduling [6]: SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0


Examining Available:
Height 7: SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 7: SU(8): t15: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [7]: SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 7: SU(8): t15: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [8]: SU(8): t15: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(8): t15: i16 = MOVI TargetConstant:i16<0>

SU(6): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(7): t16: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t15, t0

SU(5): t21: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(4): t14: i16 = MOVI TargetConstant:i16<5>

SU(3): t19: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t21, t14, t0

SU(2): t20: ch = TokenFactor t16, t19

SU(1): t11: i16,ch,glue = CopyFromReg t9, Register:i16 $r1, t9:1

    t9: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @input> 0, RegisterMask:Untyped, t20

SU(0): t13: ch = JMPI BasicBlock:ch< 0x16b38283800>, t11:1


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>

Initial selection DAG: %bb.22 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283948>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>

Combining: t1: ch = BasicBlock< 0x16b38283948>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.22 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283948>



Legalizing node: t1: ch = BasicBlock< 0x16b38283948>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38283948>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38283948>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.22 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283948>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38283948>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.22 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283948>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>

Legalizing: t1: ch = BasicBlock< 0x16b38283948>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38283948>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.22 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283948>


===== Instruction selection begins: %bb.22 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38283948>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38283948>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38283948>
Selecting: t1: ch = BasicBlock< 0x16b38283948>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.22 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38283948>, t0


********** List Scheduling %bb.22 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283948>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283948>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283948>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283948>, t0


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<4>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<4>, FrameIndex:i16<4>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38283948>

Initial selection DAG: %bb.16 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<4>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283948>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38283948>

Combining: t6: ch = BasicBlock< 0x16b38283948>

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<4>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<4>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.16 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<4>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283948>



Legalizing node: t6: ch = BasicBlock< 0x16b38283948>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38283948>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<4>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<4>
Creating constant: t8: i16 = Constant<4>
Creating constant: t9: i16 = Constant<0>

Legalizing node: t9: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t9: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<4>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<4>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<4>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<4>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<4>, FrameIndex:i16<4>, undef:i16
Creating new node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating constant: t11: i16 = Constant<2>
Creating new node: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t12, undef:i16
Creating new node: t14: ch = TokenFactor t10, t13

Legalizing node: t11: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = Constant<2>

Legalizing node: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t11: i16 = Constant<2>
Legal operand
Legally typed node: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t12, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<4>
Legal operand
Analyzing operand: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t12, undef:i16

Legalizing node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t14: ch = TokenFactor t10, t13
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t12, undef:i16
Legal operand
Legally typed node: t14: ch = TokenFactor t10, t13

Legalizing node: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = TokenFactor t10, t13
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38283948>
Legal operand
Legally typed node: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.16 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t12, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283948>



Combining: t14: ch = TokenFactor t10, t13

Combining: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t12, undef:i16

Combining: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16

Combining: t11: i16 = Constant<2>

Combining: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t9: i16 = Constant<0>

Combining: t8: i16 = Constant<4>

Combining: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>

Combining: t6: ch = BasicBlock< 0x16b38283948>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.16 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283948>



Legalizing: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>
Legal node: nothing to do

Legalizing: t14: ch = TokenFactor t10, t13
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t9: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<4>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38283948>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.16 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283948>



Legalizing: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>
Legal node: nothing to do

Combining: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>

Legalizing: t14: ch = TokenFactor t10, t13
Legal node: nothing to do

Combining: t14: ch = TokenFactor t10, t13

Legalizing: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16

Legalizing: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t11: i16 = Constant<2>
Legal node: nothing to do

Combining: t11: i16 = Constant<2>

Legalizing: t9: i16 = Constant<0>
Legal node: nothing to do

Combining: t9: i16 = Constant<0>

Legalizing: t8: i16 = Constant<4>
Legal node: nothing to do

Combining: t8: i16 = Constant<4>

Legalizing: t6: ch = BasicBlock< 0x16b38283948>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38283948>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.16 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283948>


===== Instruction selection begins: %bb.16 ''

ISEL: Starting selection on root node: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>
Selecting: t7: ch = br t14, BasicBlock:ch< 0x16b38283948>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38283948>, t14
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = TokenFactor t10, t13
Selecting: t14: ch = TokenFactor t10, t13


ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<4>, t15, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, Constant:i16<4>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t16: i16 = TargetConstant<2>
  Morphed node: t15: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i16 = Constant<0>
Selecting: t9: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t17: i16 = TargetConstant<0>
  Morphed node: t9: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<4>
Selecting: t8: i16 = Constant<4>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t18: i16 = TargetConstant<4>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38283948>
Selecting: t6: ch = BasicBlock< 0x16b38283948>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.16 'main:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
        t9: i16 = MOVI TargetConstant:i16<0>
      t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0
        t15: i16 = ORI disjoint t2, TargetConstant:i16<2>
        t8: i16 = MOVI TargetConstant:i16<4>
      t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0
    t14: ch = TokenFactor t10, t13
  t7: ch = JMPI BasicBlock:ch< 0x16b38283948>, t14


********** List Scheduling %bb.16 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283948>, t14

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t14: ch = TokenFactor t10, t13

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t8: i16 = MOVI TargetConstant:i16<4>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(4): Data Latency=1
    SU(6): Data Latency=1
SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(7): t9: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283948>, t14


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283948>, t14


Examining Available:
Height 0: SU(1): t14: ch = TokenFactor t10, t13


*** Scheduling [1]: SU(1): t14: ch = TokenFactor t10, t13


Examining Available:
  Comparing latency of SU (6) depth 1 vs SU (2) depth 2
Height 2: SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

  Comparing latency of SU (6) depth 1 vs SU (2) depth 2

*** Scheduling [2]: SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0


Examining Available:
Height 3: SU(3): t8: i16 = MOVI TargetConstant:i16<4>

Height 3: SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [3]: SU(3): t8: i16 = MOVI TargetConstant:i16<4>


Examining Available:
Height 3: SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [4]: SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [5]: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


Examining Available:
Height 6: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 6: SU(7): t9: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [6]: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 6: SU(7): t9: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [7]: SU(7): t9: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(7): t9: i16 = MOVI TargetConstant:i16<0>

SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(3): t8: i16 = MOVI TargetConstant:i16<4>

SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0

SU(1): t14: ch = TokenFactor t10, t13

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283948>, t14


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>

Initial selection DAG: %bb.23 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>

Combining: t1: ch = BasicBlock< 0x16b38283a90>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.23 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>



Legalizing node: t1: ch = BasicBlock< 0x16b38283a90>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38283a90>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38283a90>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.23 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38283a90>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.23 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>

Legalizing: t1: ch = BasicBlock< 0x16b38283a90>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38283a90>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.23 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>


===== Instruction selection begins: %bb.23 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38283a90>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38283a90>
Selecting: t1: ch = BasicBlock< 0x16b38283a90>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.23 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t0


********** List Scheduling %bb.23 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t0


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<0>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38283a90>

Initial selection DAG: %bb.14 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283a90>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38283a90>

Combining: t6: ch = BasicBlock< 0x16b38283a90>

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.14 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283a90>



Legalizing node: t6: ch = BasicBlock< 0x16b38283a90>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38283a90>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<0>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<0>
Creating constant: t8: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<0>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
Creating new node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating constant: t10: i16 = Constant<2>
Creating new node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
Creating new node: t13: ch = TokenFactor t9, t12

Legalizing node: t10: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t10: i16 = Constant<2>

Legalizing node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t10: i16 = Constant<2>
Legal operand
Legally typed node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<0>
Legal operand
Analyzing operand: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16

Legalizing node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t13: ch = TokenFactor t9, t12
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
Legal operand
Legally typed node: t13: ch = TokenFactor t9, t12

Legalizing node: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = TokenFactor t9, t12
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38283a90>
Legal operand
Legally typed node: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.14 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>



Combining: t13: ch = TokenFactor t9, t12

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16

Combining: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16

Combining: t10: i16 = Constant<2>

Combining: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t8: i16 = Constant<0>

Combining: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>

Combining: t6: ch = BasicBlock< 0x16b38283a90>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.14 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>



Legalizing: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>
Legal node: nothing to do

Legalizing: t13: ch = TokenFactor t9, t12
Legal node: nothing to do

Legalizing: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t10: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38283a90>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.14 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>



Legalizing: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>
Legal node: nothing to do

Combining: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>

Legalizing: t13: ch = TokenFactor t9, t12
Legal node: nothing to do

Combining: t13: ch = TokenFactor t9, t12

Legalizing: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16

Legalizing: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t10: i16 = Constant<2>
Legal node: nothing to do

Combining: t10: i16 = Constant<2>

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Combining: t8: i16 = Constant<0>

Legalizing: t6: ch = BasicBlock< 0x16b38283a90>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38283a90>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.14 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>


===== Instruction selection begins: %bb.14 ''

ISEL: Starting selection on root node: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>
Selecting: t7: ch = br t13, BasicBlock:ch< 0x16b38283a90>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = TokenFactor t9, t12
Selecting: t13: ch = TokenFactor t9, t12


ISEL: Starting selection on root node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
Selecting: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t15: i16 = TargetConstant<2>
  Morphed node: t14: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<0>
Selecting: t8: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t16: i16 = TargetConstant<0>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38283a90>
Selecting: t6: ch = BasicBlock< 0x16b38283a90>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.14 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
  t8: i16 = MOVI TargetConstant:i16<0>
      t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0
        t14: i16 = ORI disjoint t2, TargetConstant:i16<2>
      t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0
    t13: ch = TokenFactor t9, t12
  t7: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t13


********** List Scheduling %bb.14 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t13: ch = TokenFactor t9, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t8: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(4): Data Latency=1
    SU(6): Data Latency=1
SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t13


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t13


Examining Available:
Height 0: SU(1): t13: ch = TokenFactor t9, t12


*** Scheduling [1]: SU(1): t13: ch = TokenFactor t9, t12


Examining Available:
  Comparing latency of SU (6) depth 1 vs SU (2) depth 2
Height 2: SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

Height 2: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0

  Comparing latency of SU (6) depth 1 vs SU (2) depth 2

*** Scheduling [2]: SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0


Examining Available:
Height 3: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0


*** Scheduling [3]: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 2: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0


*** Scheduling [4]: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0


Examining Available:
Height 5: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 5: SU(3): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [5]: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(3): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [6]: SU(3): t8: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(3): t8: i16 = MOVI TargetConstant:i16<0>

SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0

SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

SU(1): t13: ch = TokenFactor t9, t12

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283a90>, t13


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>

Initial selection DAG: %bb.24 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>

Combining: t1: ch = BasicBlock< 0x16b38283bd8>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.24 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>



Legalizing node: t1: ch = BasicBlock< 0x16b38283bd8>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38283bd8>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38283bd8>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.24 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38283bd8>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.24 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>

Legalizing: t1: ch = BasicBlock< 0x16b38283bd8>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38283bd8>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.24 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>


===== Instruction selection begins: %bb.24 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38283bd8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38283bd8>
Selecting: t1: ch = BasicBlock< 0x16b38283bd8>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.24 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t0


********** List Scheduling %bb.24 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t0


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<2>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<2>, FrameIndex:i16<4>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38283bd8>

Initial selection DAG: %bb.12 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<2>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283bd8>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38283bd8>

Combining: t6: ch = BasicBlock< 0x16b38283bd8>

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<2>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<2>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.12 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<2>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283bd8>



Legalizing node: t6: ch = BasicBlock< 0x16b38283bd8>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38283bd8>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<2>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<2>
Creating constant: t8: i16 = Constant<2>
Creating constant: t9: i16 = Constant<0>

Legalizing node: t9: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t9: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<2>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<2>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<2>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<2>, FrameIndex:i16<4>, undef:i16
Creating new node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating new node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t11, undef:i16
Creating new node: t13: ch = TokenFactor t10, t12

Legalizing node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t8: i16 = Constant<2>
Legal operand
Legally typed node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t11, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<2>
Legal operand
Analyzing operand: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t11, undef:i16

Legalizing node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t13: ch = TokenFactor t10, t12
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t11, undef:i16
Legal operand
Legally typed node: t13: ch = TokenFactor t10, t12

Legalizing node: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = TokenFactor t10, t12
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38283bd8>
Legal operand
Legally typed node: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.12 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t11, undef:i16
    t13: ch = TokenFactor t10, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>



Combining: t13: ch = TokenFactor t10, t12

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t11, undef:i16

Combining: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16

Combining: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t9: i16 = Constant<0>

Combining: t8: i16 = Constant<2>

Combining: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>

Combining: t6: ch = BasicBlock< 0x16b38283bd8>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.12 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16
    t13: ch = TokenFactor t10, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>



Legalizing: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>
Legal node: nothing to do

Legalizing: t13: ch = TokenFactor t10, t12
Legal node: nothing to do

Legalizing: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t9: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38283bd8>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.12 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16
    t13: ch = TokenFactor t10, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>



Legalizing: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>
Legal node: nothing to do

Combining: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>

Legalizing: t13: ch = TokenFactor t10, t12
Legal node: nothing to do

Combining: t13: ch = TokenFactor t10, t12

Legalizing: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16

Legalizing: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t9: i16 = Constant<0>
Legal node: nothing to do

Combining: t9: i16 = Constant<0>

Legalizing: t8: i16 = Constant<2>
Legal node: nothing to do

Combining: t8: i16 = Constant<2>

Legalizing: t6: ch = BasicBlock< 0x16b38283bd8>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38283bd8>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.12 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16
    t13: ch = TokenFactor t10, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>


===== Instruction selection begins: %bb.12 ''

ISEL: Starting selection on root node: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>
Selecting: t7: ch = br t13, BasicBlock:ch< 0x16b38283bd8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = TokenFactor t10, t12
Selecting: t13: ch = TokenFactor t10, t12


ISEL: Starting selection on root node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16
Selecting: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<2>, t14, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, Constant:i16<2>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t15: i16 = TargetConstant<2>
  Morphed node: t14: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i16 = Constant<0>
Selecting: t9: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t16: i16 = TargetConstant<0>
  Morphed node: t9: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<2>
Selecting: t8: i16 = Constant<2>

ISEL: Starting pattern match
  Initial Opcode index to 890
  Morphed node: t8: i16 = MOVI TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38283bd8>
Selecting: t6: ch = BasicBlock< 0x16b38283bd8>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.12 'main:'
SelectionDAG has 13 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
        t9: i16 = MOVI TargetConstant:i16<0>
      t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0
        t14: i16 = ORI disjoint t2, TargetConstant:i16<2>
        t8: i16 = MOVI TargetConstant:i16<2>
      t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0
    t13: ch = TokenFactor t10, t12
  t7: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t13


********** List Scheduling %bb.12 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t13: ch = TokenFactor t10, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t8: i16 = MOVI TargetConstant:i16<2>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(4): Data Latency=1
    SU(6): Data Latency=1
SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(7): t9: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t13


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t13


Examining Available:
Height 0: SU(1): t13: ch = TokenFactor t10, t12


*** Scheduling [1]: SU(1): t13: ch = TokenFactor t10, t12


Examining Available:
  Comparing latency of SU (6) depth 1 vs SU (2) depth 2
Height 2: SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

  Comparing latency of SU (6) depth 1 vs SU (2) depth 2

*** Scheduling [2]: SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0


Examining Available:
Height 3: SU(3): t8: i16 = MOVI TargetConstant:i16<2>

Height 3: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [3]: SU(3): t8: i16 = MOVI TargetConstant:i16<2>


Examining Available:
Height 3: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [4]: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [5]: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


Examining Available:
Height 6: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 6: SU(7): t9: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [6]: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 6: SU(7): t9: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [7]: SU(7): t9: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(7): t9: i16 = MOVI TargetConstant:i16<0>

SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(3): t8: i16 = MOVI TargetConstant:i16<2>

SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

SU(1): t13: ch = TokenFactor t10, t12

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283bd8>, t13


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>

Initial selection DAG: %bb.25 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>

Combining: t1: ch = BasicBlock< 0x16b38283d20>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.25 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>



Legalizing node: t1: ch = BasicBlock< 0x16b38283d20>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38283d20>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38283d20>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.25 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38283d20>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.25 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>

Legalizing: t1: ch = BasicBlock< 0x16b38283d20>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38283d20>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.25 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>


===== Instruction selection begins: %bb.25 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38283d20>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38283d20>
Selecting: t1: ch = BasicBlock< 0x16b38283d20>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.25 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t0


********** List Scheduling %bb.25 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t0


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<1>, FrameIndex:i16<4>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38283d20>

Initial selection DAG: %bb.10 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<1>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283d20>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38283d20>

Combining: t6: ch = BasicBlock< 0x16b38283d20>

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<1>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<1>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.10 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<1>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283d20>



Legalizing node: t6: ch = BasicBlock< 0x16b38283d20>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38283d20>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<1>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<1>
Creating constant: t8: i16 = Constant<1>
Creating constant: t9: i16 = Constant<0>

Legalizing node: t9: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t9: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<1>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<1>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<1>, FrameIndex:i16<4>, undef:i16
Creating new node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating constant: t11: i16 = Constant<2>
Creating new node: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t12, undef:i16
Creating new node: t14: ch = TokenFactor t10, t13

Legalizing node: t11: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = Constant<2>

Legalizing node: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t11: i16 = Constant<2>
Legal operand
Legally typed node: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t12, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<1>
Legal operand
Analyzing operand: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t12, undef:i16

Legalizing node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t14: ch = TokenFactor t10, t13
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t12, undef:i16
Legal operand
Legally typed node: t14: ch = TokenFactor t10, t13

Legalizing node: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = TokenFactor t10, t13
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38283d20>
Legal operand
Legally typed node: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.10 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t12, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>



Combining: t14: ch = TokenFactor t10, t13

Combining: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t12, undef:i16

Combining: t12: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16

Combining: t11: i16 = Constant<2>

Combining: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t9: i16 = Constant<0>

Combining: t8: i16 = Constant<1>

Combining: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>

Combining: t6: ch = BasicBlock< 0x16b38283d20>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.10 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>



Legalizing: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>
Legal node: nothing to do

Legalizing: t14: ch = TokenFactor t10, t13
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t9: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38283d20>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.10 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>



Legalizing: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>
Legal node: nothing to do

Combining: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>

Legalizing: t14: ch = TokenFactor t10, t13
Legal node: nothing to do

Combining: t14: ch = TokenFactor t10, t13

Legalizing: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16

Legalizing: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t11: i16 = Constant<2>
Legal node: nothing to do

Combining: t11: i16 = Constant<2>

Legalizing: t9: i16 = Constant<0>
Legal node: nothing to do

Combining: t9: i16 = Constant<0>

Legalizing: t8: i16 = Constant<1>
Legal node: nothing to do

Combining: t8: i16 = Constant<1>

Legalizing: t6: ch = BasicBlock< 0x16b38283d20>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38283d20>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.10 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
      t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16
    t14: ch = TokenFactor t10, t13
  t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>


===== Instruction selection begins: %bb.10 ''

ISEL: Starting selection on root node: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>
Selecting: t7: ch = br t14, BasicBlock:ch< 0x16b38283d20>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t14
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch = TokenFactor t10, t13
Selecting: t14: ch = TokenFactor t10, t13


ISEL: Starting selection on root node: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16
Selecting: t13: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<1>, t15, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, Constant:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t15: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t16: i16 = TargetConstant<2>
  Morphed node: t15: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t10: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i16 = Constant<0>
Selecting: t9: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t17: i16 = TargetConstant<0>
  Morphed node: t9: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<1>
Selecting: t8: i16 = Constant<1>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t18: i16 = TargetConstant<1>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38283d20>
Selecting: t6: ch = BasicBlock< 0x16b38283d20>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.10 'main:'
SelectionDAG has 14 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
        t9: i16 = MOVI TargetConstant:i16<0>
      t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0
        t15: i16 = ORI disjoint t2, TargetConstant:i16<2>
        t8: i16 = MOVI TargetConstant:i16<1>
      t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0
    t14: ch = TokenFactor t10, t13
  t7: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t14


********** List Scheduling %bb.10 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t14

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t14: ch = TokenFactor t10, t13

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t8: i16 = MOVI TargetConstant:i16<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(4): Data Latency=1
    SU(6): Data Latency=1
SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(7): t9: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t14


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t14


Examining Available:
Height 0: SU(1): t14: ch = TokenFactor t10, t13


*** Scheduling [1]: SU(1): t14: ch = TokenFactor t10, t13


Examining Available:
  Comparing latency of SU (6) depth 1 vs SU (2) depth 2
Height 2: SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

  Comparing latency of SU (6) depth 1 vs SU (2) depth 2

*** Scheduling [2]: SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0


Examining Available:
Height 3: SU(3): t8: i16 = MOVI TargetConstant:i16<1>

Height 3: SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [3]: SU(3): t8: i16 = MOVI TargetConstant:i16<1>


Examining Available:
Height 3: SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [4]: SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 2: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


*** Scheduling [5]: SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0


Examining Available:
Height 6: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 6: SU(7): t9: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [6]: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 6: SU(7): t9: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [7]: SU(7): t9: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(7): t9: i16 = MOVI TargetConstant:i16<0>

SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(6): t10: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t9, t0

SU(4): t15: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(3): t8: i16 = MOVI TargetConstant:i16<1>

SU(2): t13: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t15, t8, t0

SU(1): t14: ch = TokenFactor t10, t13

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283d20>, t14


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>

Initial selection DAG: %bb.26 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>

Combining: t1: ch = BasicBlock< 0x16b38283e68>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.26 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>



Legalizing node: t1: ch = BasicBlock< 0x16b38283e68>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38283e68>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38283e68>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.26 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38283e68>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.26 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>

Legalizing: t1: ch = BasicBlock< 0x16b38283e68>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38283e68>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.26 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>


===== Instruction selection begins: %bb.26 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38283e68>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38283e68>
Selecting: t1: ch = BasicBlock< 0x16b38283e68>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.26 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t0


********** List Scheduling %bb.26 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t0


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<0>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38283e68>

Initial selection DAG: %bb.8 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283e68>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38283e68>

Combining: t6: ch = BasicBlock< 0x16b38283e68>

Combining: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t1: i32 = Constant<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.8 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38283e68>



Legalizing node: t6: ch = BasicBlock< 0x16b38283e68>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38283e68>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<4>

Legalizing node: t1: i32 = Constant<0>
Analyzing result type: i32
Expand integer result: t1: i32 = Constant<0>
Creating constant: t8: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<0>
Expand integer operand: t5: ch = store<(store (s32) into %ir.5)> t0, Constant:i32<0>, FrameIndex:i16<4>, undef:i16
Creating new node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Creating constant: t10: i16 = Constant<2>
Creating new node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
Creating new node: t13: ch = TokenFactor t9, t12

Legalizing node: t10: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t10: i16 = Constant<2>

Legalizing node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t10: i16 = Constant<2>
Legal operand
Legally typed node: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<0>
Legal operand
Analyzing operand: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16

Legalizing node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing node: t13: ch = TokenFactor t9, t12
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
Legal operand
Legally typed node: t13: ch = TokenFactor t9, t12

Legalizing node: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = TokenFactor t9, t12
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38283e68>
Legal operand
Legally typed node: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.8 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>



Combining: t13: ch = TokenFactor t9, t12

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t11, undef:i16

Combining: t11: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16

Combining: t10: i16 = Constant<2>

Combining: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Combining: t8: i16 = Constant<0>

Combining: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>

Combining: t6: ch = BasicBlock< 0x16b38283e68>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<4>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.8 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>



Legalizing: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>
Legal node: nothing to do

Legalizing: t13: ch = TokenFactor t9, t12
Legal node: nothing to do

Legalizing: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t10: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38283e68>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.8 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>



Legalizing: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>
Legal node: nothing to do

Combining: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>

Legalizing: t13: ch = TokenFactor t9, t12
Legal node: nothing to do

Combining: t13: ch = TokenFactor t9, t12

Legalizing: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16

Legalizing: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

Legalizing: t10: i16 = Constant<2>
Legal node: nothing to do

Combining: t10: i16 = Constant<2>

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Combining: t8: i16 = Constant<0>

Legalizing: t6: ch = BasicBlock< 0x16b38283e68>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38283e68>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<4>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.8 'main:'
SelectionDAG has 11 nodes:
  t0: ch,glue = EntryToken
      t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
        t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
      t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
    t13: ch = TokenFactor t9, t12
  t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>


===== Instruction selection begins: %bb.8 ''

ISEL: Starting selection on root node: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>
Selecting: t7: ch = br t13, BasicBlock:ch< 0x16b38283e68>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = TokenFactor t9, t12
Selecting: t13: ch = TokenFactor t9, t12


ISEL: Starting selection on root node: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16
Selecting: t12: ch = store<(store (s16) into %ir.5 + 2, basealign 4)> t0, Constant:i16<0>, t14, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t14: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
Creating constant: t15: i16 = TargetConstant<2>
  Morphed node: t14: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16
Selecting: t9: ch = store<(store (s16) into %ir.5, align 4)> t0, Constant:i16<0>, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> FrameIndex:i16<4>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<0>
Selecting: t8: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t16: i16 = TargetConstant<0>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38283e68>
Selecting: t6: ch = BasicBlock< 0x16b38283e68>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<4>
Selecting: t2: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.8 'main:'
SelectionDAG has 12 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
  t8: i16 = MOVI TargetConstant:i16<0>
      t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0
        t14: i16 = ORI disjoint t2, TargetConstant:i16<2>
      t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0
    t13: ch = TokenFactor t9, t12
  t7: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t13


********** List Scheduling %bb.8 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t13

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t13: ch = TokenFactor t9, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t8: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(4): Data Latency=1
    SU(6): Data Latency=1
SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t13


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t13


Examining Available:
Height 0: SU(1): t13: ch = TokenFactor t9, t12


*** Scheduling [1]: SU(1): t13: ch = TokenFactor t9, t12


Examining Available:
  Comparing latency of SU (6) depth 1 vs SU (2) depth 2
Height 2: SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

Height 2: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0

  Comparing latency of SU (6) depth 1 vs SU (2) depth 2

*** Scheduling [2]: SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0


Examining Available:
Height 3: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

Height 2: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0


*** Scheduling [3]: SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>


Examining Available:
Height 2: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0


*** Scheduling [4]: SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0


Examining Available:
Height 5: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 5: SU(3): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [5]: SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 5: SU(3): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [6]: SU(3): t8: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(3): t8: i16 = MOVI TargetConstant:i16<0>

SU(5): t2: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(6): t9: ch = STORE16R<Mem:(store (s16) into %ir.5, align 4)> t2, t8, t0

SU(4): t14: i16 = ORI disjoint t2, TargetConstant:i16<2>

SU(2): t12: ch = STORE16R<Mem:(store (s16) into %ir.5 + 2, basealign 4)> t14, t8, t0

SU(1): t13: ch = TokenFactor t9, t12

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38283e68>, t13


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Creating new node: t7: i32 = zero_extend t6
Creating constant: t8: i16 = Constant<3>
Creating new node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Creating new node: t10: i16 = add nuw t4, t9
Creating constant: t11: i8 = Constant<0>
Creating new node: t12: ch = TokenFactor t4:1, t6:1
Creating new node: t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16
Creating new node: t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t13, FrameIndex:i16<4>, undef:i16
Creating new node: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16
Creating new node: t18: i32 = zero_extend t17
Creating new node: t19: i16 = shl nuw nsw t17, Constant:i16<3>
Creating new node: t20: i16 = add nuw t16, t19
Creating constant: t21: i16 = Constant<4>
Creating new node: t22: i16 = add nuw t20, Constant:i16<4>
Creating new node: t23: ch = TokenFactor t15:1, t16:1, t17:1
Creating new node: t24: ch = store<(store (s32) into %ir.96)> t23, t15, t22, undef:i16
Creating new node: t25: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t24, FrameIndex:i16<1>, undef:i16
Creating new node: t26: i32 = zero_extend t25
Creating constant: t27: i32 = Constant<2>
Creating new node: t29: i1 = setcc t26, Constant:i32<2>, setge:ch
Creating constant: t30: i1 = Constant<-1>
Creating new node: t31: i1 = xor t29, Constant:i1<-1>
Creating new node: t33: ch = brcond t24, t31, BasicBlock:ch< 0x16b38288ac0>
Creating new node: t35: ch = br t33, BasicBlock:ch< 0x16b38283fb0>

Initial selection DAG: %bb.27 'main:'
SelectionDAG has 36 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t7: i32 = zero_extend t6
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16
  t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t13, FrameIndex:i16<4>, undef:i16
  t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16
  t18: i32 = zero_extend t17
    t23: ch = TokenFactor t15:1, t16:1, t17:1
        t19: i16 = shl nuw nsw t17, Constant:i16<3>
      t20: i16 = add nuw t16, t19
    t22: i16 = add nuw t20, Constant:i16<4>
  t24: ch = store<(store (s32) into %ir.96)> t23, t15, t22, undef:i16
            t25: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t24, FrameIndex:i16<1>, undef:i16
          t26: i32 = zero_extend t25
        t29: i1 = setcc t26, Constant:i32<2>, setge:ch
      t31: i1 = xor t29, Constant:i1<-1>
    t33: ch = brcond t24, t31, BasicBlock:ch< 0x16b38288ac0>
  t35: ch = br t33, BasicBlock:ch< 0x16b38283fb0>



Combining: t35: ch = br t33, BasicBlock:ch< 0x16b38283fb0>

Combining: t34: ch = BasicBlock< 0x16b38283fb0>

Combining: t33: ch = brcond t24, t31, BasicBlock:ch< 0x16b38288ac0>
Creating new node: t37: i1 = setcc t26, Constant:i32<2>, setlt:ch
Creating new node: t38: ch = brcond t24, t37, BasicBlock:ch< 0x16b38288ac0>
 ... into: t38: ch = brcond t24, t37, BasicBlock:ch< 0x16b38288ac0>

Combining: t38: ch = brcond t24, t37, BasicBlock:ch< 0x16b38288ac0>

Combining: t37: i1 = setcc t26, Constant:i32<2>, setlt:ch

Combining: t36: ch = setlt

Combining: t35: ch = br t38, BasicBlock:ch< 0x16b38283fb0>

Combining: t32: ch = BasicBlock< 0x16b38288ac0>

Combining: t27: i32 = Constant<2>

Combining: t26: i32 = zero_extend t25
Creating new node: t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t24, FrameIndex:i16<1>, undef:i16

Replacing.1 t26: i32 = zero_extend t25

With: t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t24, FrameIndex:i16<1>, undef:i16
 and 0 other values

Combining: t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t24, FrameIndex:i16<1>, undef:i16

Combining: t37: i1 = setcc t39, Constant:i32<2>, setlt:ch

Combining: t24: ch = store<(store (s32) into %ir.96)> t23, t15, t22, undef:i16

Combining: t23: ch = TokenFactor t15:1, t16:1, t17:1

Combining: t22: i16 = add nuw t20, Constant:i16<4>

Combining: t21: i16 = Constant<4>

Combining: t20: i16 = add nuw t16, t19

Combining: t19: i16 = shl nuw nsw t17, Constant:i16<3>

Combining: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16

Combining: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t13, FrameIndex:i16<4>, undef:i16

Combining: t14: i16 = FrameIndex<4>

Combining: t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16

Combining: t12: ch = TokenFactor t4:1, t6:1

Combining: t11: i8 = Constant<0>

Combining: t10: i16 = add nuw t4, t9

Combining: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Combining: t8: i16 = Constant<3>

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.27 'main:'
SelectionDAG has 30 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16
  t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t13, FrameIndex:i16<4>, undef:i16
  t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16
    t23: ch = TokenFactor t15:1, t16:1, t17:1
        t19: i16 = shl nuw nsw t17, Constant:i16<3>
      t20: i16 = add nuw t16, t19
    t22: i16 = add nuw t20, Constant:i16<4>
  t24: ch = store<(store (s32) into %ir.96)> t23, t15, t22, undef:i16
        t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t24, FrameIndex:i16<1>, undef:i16
      t37: i1 = setcc t39, Constant:i32<2>, setlt:ch
    t38: ch = brcond t24, t37, BasicBlock:ch< 0x16b38288ac0>
  t35: ch = br t38, BasicBlock:ch< 0x16b38283fb0>



Legalizing node: t36: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t36: ch = setlt

Legalizing node: t34: ch = BasicBlock< 0x16b38283fb0>
Analyzing result type: ch
Legal result type
Legally typed node: t34: ch = BasicBlock< 0x16b38283fb0>

Legalizing node: t32: ch = BasicBlock< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Legally typed node: t32: ch = BasicBlock< 0x16b38288ac0>

Legalizing node: t27: i32 = Constant<2>
Analyzing result type: i32
Expand integer result: t27: i32 = Constant<2>
Creating constant: t40: i16 = Constant<2>
Creating constant: t41: i16 = Constant<0>

Legalizing node: t41: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t41: i16 = Constant<0>

Legalizing node: t40: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t40: i16 = Constant<2>

Legalizing node: t21: i16 = Constant<4>
Analyzing result type: i16
Legal result type
Legally typed node: t21: i16 = Constant<4>

Legalizing node: t14: i16 = FrameIndex<4>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = FrameIndex<4>

Legalizing node: t11: i8 = Constant<0>
Analyzing result type: i8
Promote integer result: t11: i8 = Constant<0>

Legalizing node: t8: i16 = Constant<3>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<3>

Legalizing node: t5: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = FrameIndex<1>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = GlobalAddress<ptr @stack> 0
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = GlobalAddress<ptr @stack> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i16 = Constant<3>
Legal operand
Legally typed node: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Legalizing node: t10: i16 = add nuw t4, t9
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Legal operand
Legally typed node: t10: i16 = add nuw t4, t9

Legalizing node: t12: ch = TokenFactor t4:1, t6:1
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t4:1, t6:1

Legalizing node: t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t4:1, t6:1
Legal operand
Analyzing operand: t11: i8 = Constant<0>
Promote integer operand: t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16
Creating new node: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Replacing: t13: ch = store<(store (s8) into %ir.90, align 4)> t12, Constant:i8<0>, t10, undef:i16
     with: t42: ch = store<(store (s8) into %ir.<badref>, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16

Legalizing node: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t4:1, t6:1
Legal operand
Analyzing operand: t41: i16 = Constant<0>
Legal operand
Analyzing operand: t10: i16 = add nuw t4, t9
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16

Legalizing node: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16

Legalizing node: t19: i16 = shl nuw nsw t17, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i16 = Constant<3>
Legal operand
Legally typed node: t19: i16 = shl nuw nsw t17, Constant:i16<3>

Legalizing node: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t20: i16 = add nuw t16, t19
Analyzing result type: i16
Legal result type
Analyzing operand: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t19: i16 = shl nuw nsw t17, Constant:i16<3>
Legal operand
Legally typed node: t20: i16 = add nuw t16, t19

Legalizing node: t22: i16 = add nuw t20, Constant:i16<4>
Analyzing result type: i16
Legal result type
Analyzing operand: t20: i16 = add nuw t16, t19
Legal operand
Analyzing operand: t21: i16 = Constant<4>
Legal operand
Legally typed node: t22: i16 = add nuw t20, Constant:i16<4>

Legalizing node: t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t42, FrameIndex:i16<4>, undef:i16
Analyzing result type: i32
Expand integer result: t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t42, FrameIndex:i16<4>, undef:i16
Creating new node: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Creating new node: t44: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16
Creating new node: t46: ch = TokenFactor t43:1, t45:1

Legalizing node: t44: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t14: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t40: i16 = Constant<2>
Legal operand
Legally typed node: t44: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>

Legalizing node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Legal operand
Analyzing operand: t44: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16

Legalizing node: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Legal operand
Analyzing operand: t14: i16 = FrameIndex<4>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16

Legalizing node: t46: ch = TokenFactor t43:1, t45:1
Analyzing result type: ch
Legal result type
Analyzing operand: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16
Legal operand
Legally typed node: t46: ch = TokenFactor t43:1, t45:1

Legalizing node: t23: ch = TokenFactor t46, t16:1, t17:1
Analyzing result type: ch
Legal result type
Analyzing operand: t46: ch = TokenFactor t43:1, t45:1
Legal operand
Analyzing operand: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t23: ch = TokenFactor t46, t16:1, t17:1

Legalizing node: t24: ch = store<(store (s32) into %ir.96)> t23, t15, t22, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = TokenFactor t46, t16:1, t17:1
Legal operand
Analyzing operand: t15: i32,ch = load<(dereferenceable load (s32) from %ir.5)> t42, FrameIndex:i16<4>, undef:i16
Expand integer operand: t24: ch = store<(store (s32) into %ir.96)> t23, t15, t22, undef:i16
Creating new node: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
Creating new node: t48: i16 = add nuw t22, Constant:i16<2>
Creating new node: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t48, undef:i16
Creating new node: t50: ch = TokenFactor t47, t49

Legalizing node: t48: i16 = add nuw t22, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t22: i16 = add nuw t20, Constant:i16<4>
Legal operand
Analyzing operand: t40: i16 = Constant<2>
Legal operand
Legally typed node: t48: i16 = add nuw t22, Constant:i16<2>

Legalizing node: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t48, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = TokenFactor t46, t16:1, t17:1
Legal operand
Analyzing operand: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16
Legal operand
Analyzing operand: t48: i16 = add nuw t22, Constant:i16<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t48, undef:i16

Legalizing node: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = TokenFactor t46, t16:1, t17:1
Legal operand
Analyzing operand: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Legal operand
Analyzing operand: t22: i16 = add nuw t20, Constant:i16<4>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16

Legalizing node: t50: ch = TokenFactor t47, t49
Analyzing result type: ch
Legal result type
Analyzing operand: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
Legal operand
Analyzing operand: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t48, undef:i16
Legal operand
Legally typed node: t50: ch = TokenFactor t47, t49

Legalizing node: t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t50, FrameIndex:i16<1>, undef:i16
Analyzing result type: i32
Expand integer result: t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t50, FrameIndex:i16<1>, undef:i16
Creating new node: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16

Legalizing node: t37: i1 = setcc t39, Constant:i32<2>, setlt:ch
Analyzing result type: i1
Promote integer result: t37: i1 = setcc t39, Constant:i32<2>, setlt:ch
Creating new node: t52: i16 = setcc t39, Constant:i32<2>, setlt:ch

Legalizing node: t38: ch = brcond t50, t37, BasicBlock:ch< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Analyzing operand: t50: ch = TokenFactor t47, t49
Legal operand
Analyzing operand: t37: i1 = setcc t39, Constant:i32<2>, setlt:ch
Promote integer operand: t38: ch = brcond t50, t37, BasicBlock:ch< 0x16b38288ac0>
Creating new node: t53: i16 = any_extend t37

Legalizing node: t53: i16 = any_extend t37
Analyzing result type: i16
Legal result type
Analyzing operand: t37: i1 = setcc t39, Constant:i32<2>, setlt:ch
Promote integer operand: t53: i16 = any_extend t37
Replacing: t53: i16 = any_extend t37
     with: t52: i16 = setcc t39, Constant:i32<2>, setlt:ch

Legalizing node: t52: i16 = setcc t39, Constant:i32<2>, setlt:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t39: i32,ch = load<(dereferenceable load (s16) from %ir.2), zext from i16> t50, FrameIndex:i16<1>, undef:i16
Expand integer operand: t52: i16 = setcc t39, Constant:i32<2>, setlt:ch
Creating new node: t55: i16 = setcc t51, Constant:i16<2>, setult:ch

Legalizing node: t54: ch = setult
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = setult

Legalizing node: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t50: ch = TokenFactor t47, t49
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16

Legalizing node: t55: i16 = setcc t51, Constant:i16<2>, setult:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t40: i16 = Constant<2>
Legal operand
Analyzing operand: t54: ch = setult
Legal operand
Legally typed node: t55: i16 = setcc t51, Constant:i16<2>, setult:ch

Legalizing node: t38: ch = brcond t50, t55, BasicBlock:ch< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Analyzing operand: t50: ch = TokenFactor t47, t49
Legal operand
Analyzing operand: t55: i16 = setcc t51, Constant:i16<2>, setult:ch
Legal operand
Analyzing operand: t32: ch = BasicBlock< 0x16b38288ac0>
Legal operand
Legally typed node: t38: ch = brcond t50, t55, BasicBlock:ch< 0x16b38288ac0>

Legalizing node: t35: ch = br t38, BasicBlock:ch< 0x16b38283fb0>
Analyzing result type: ch
Legal result type
Analyzing operand: t38: ch = brcond t50, t55, BasicBlock:ch< 0x16b38288ac0>
Legal operand
Analyzing operand: t34: ch = BasicBlock< 0x16b38283fb0>
Legal operand
Legally typed node: t35: ch = br t38, BasicBlock:ch< 0x16b38283fb0>

Legalizing node: t65535: ch = handlenode t35
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch = br t38, BasicBlock:ch< 0x16b38283fb0>
Legal operand
Legally typed node: t65535: ch = handlenode t35

Type-legalized selection DAG: %bb.27 'main:'
SelectionDAG has 36 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
      t19: i16 = shl nuw nsw t17, Constant:i16<3>
    t20: i16 = add nuw t16, t19
  t22: i16 = add nuw t20, Constant:i16<4>
    t46: ch = TokenFactor t43:1, t45:1
  t23: ch = TokenFactor t46, t16:1, t17:1
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
  t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
    t44: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16
    t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
      t48: i16 = add nuw t22, Constant:i16<2>
    t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t48, undef:i16
  t50: ch = TokenFactor t47, t49
        t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
      t55: i16 = setcc t51, Constant:i16<2>, setult:ch
    t38: ch = brcond t50, t55, BasicBlock:ch< 0x16b38288ac0>
  t35: ch = br t38, BasicBlock:ch< 0x16b38283fb0>



Combining: t55: i16 = setcc t51, Constant:i16<2>, setult:ch

Combining: t54: ch = setult

Combining: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16

Combining: t50: ch = TokenFactor t47, t49

Combining: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t48, undef:i16

Combining: t48: i16 = add nuw t22, Constant:i16<2>
Creating constant: t56: i16 = Constant<6>
Creating new node: t57: i16 = add nuw t20, Constant:i16<6>
 ... into: t57: i16 = add nuw t20, Constant:i16<6>

Combining: t57: i16 = add nuw t20, Constant:i16<6>

Combining: t56: i16 = Constant<6>

Combining: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16

Combining: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16

Combining: t46: ch = TokenFactor t43:1, t45:1

Combining: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t44, undef:i16

Combining: t44: i16 = add nuw FrameIndex:i16<4>, Constant:i16<2>
Creating new node: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
 ... into: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Combining: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16

Combining: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16

Combining: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16

Combining: t41: i16 = Constant<0>

Combining: t40: i16 = Constant<2>

Combining: t38: ch = brcond t50, t55, BasicBlock:ch< 0x16b38288ac0>
Creating new node: t59: ch = br_cc t50, setult:ch, t51, Constant:i16<2>, BasicBlock:ch< 0x16b38288ac0>
 ... into: t59: ch = br_cc t50, setult:ch, t51, Constant:i16<2>, BasicBlock:ch< 0x16b38288ac0>

Combining: t50: ch = TokenFactor t47, t49

Combining: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16

Combining: t40: i16 = Constant<2>

Combining: t54: ch = setult

Combining: t59: ch = br_cc t50, setult:ch, t51, Constant:i16<2>, BasicBlock:ch< 0x16b38288ac0>

Combining: t35: ch = br t59, BasicBlock:ch< 0x16b38283fb0>

Combining: t34: ch = BasicBlock< 0x16b38283fb0>

Combining: t32: ch = BasicBlock< 0x16b38288ac0>

Combining: t23: ch = TokenFactor t46, t16:1, t17:1

Combining: t22: i16 = add nuw t20, Constant:i16<4>

Combining: t21: i16 = Constant<4>

Combining: t20: i16 = add nuw t16, t19

Combining: t19: i16 = shl nuw nsw t17, Constant:i16<3>

Combining: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16

Combining: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t14: i16 = FrameIndex<4>

Combining: t12: ch = TokenFactor t4:1, t6:1

Combining: t10: i16 = add nuw t4, t9

Combining: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Combining: t8: i16 = Constant<3>

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.27 'main:'
SelectionDAG has 36 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
    t19: i16 = shl nuw nsw t17, Constant:i16<3>
  t20: i16 = add nuw t16, t19
    t46: ch = TokenFactor t43:1, t45:1
  t23: ch = TokenFactor t46, t16:1, t17:1
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
  t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
    t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16
      t22: i16 = add nuw t20, Constant:i16<4>
    t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
      t57: i16 = add nuw t20, Constant:i16<6>
    t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16
  t50: ch = TokenFactor t47, t49
      t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
    t59: ch = br_cc t50, setult:ch, t51, Constant:i16<2>, BasicBlock:ch< 0x16b38288ac0>
  t35: ch = br t59, BasicBlock:ch< 0x16b38283fb0>



Legalizing: t35: ch = br t59, BasicBlock:ch< 0x16b38283fb0>
Legal node: nothing to do

Legalizing: t59: ch = br_cc t50, setult:ch, t51, Constant:i16<2>, BasicBlock:ch< 0x16b38288ac0>
Trying custom legalization
Creating new node: t60: glue = SymphonyISD::CMP t51, Constant:i16<2>
Creating new node: t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60
Successfully custom legalized node
 ... replacing: t59: ch = br_cc t50, setult:ch, t51, Constant:i16<2>, BasicBlock:ch< 0x16b38288ac0>
     with:      t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60

Legalizing: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t50: ch = TokenFactor t47, t49
Legal node: nothing to do

Legalizing: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t22: i16 = add nuw t20, Constant:i16<4>
Legal node: nothing to do

Legalizing: t57: i16 = add nuw t20, Constant:i16<6>
Legal node: nothing to do

Legalizing: t20: i16 = add nuw t16, t19
Legal node: nothing to do

Legalizing: t23: ch = TokenFactor t46, t16:1, t17:1
Legal node: nothing to do

Legalizing: t19: i16 = shl nuw nsw t17, Constant:i16<3>
Legal node: nothing to do

Legalizing: t46: ch = TokenFactor t43:1, t45:1
Legal node: nothing to do

Legalizing: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Legalizing non-extending load operation

Legalizing: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16
Legalizing non-extending load operation

Legalizing: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Legalizing truncating store operations

Legalizing: t10: i16 = add nuw t4, t9
Legal node: nothing to do

Legalizing: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Legal node: nothing to do

Legalizing: t12: ch = TokenFactor t4:1, t6:1
Legal node: nothing to do

Legalizing: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Legalizing: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t56: i16 = Constant<6>
Legal node: nothing to do

Legalizing: t41: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t40: i16 = Constant<2>
Legal node: nothing to do

Legalizing: t34: ch = BasicBlock< 0x16b38283fb0>
Legal node: nothing to do

Legalizing: t32: ch = BasicBlock< 0x16b38288ac0>
Legal node: nothing to do

Legalizing: t21: i16 = Constant<4>
Legal node: nothing to do

Legalizing: t14: i16 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<3>
Legal node: nothing to do

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = GlobalAddress<ptr @stack> 0
Trying custom legalization
Successfully custom legalized node
 ... replacing: t1: i16 = GlobalAddress<ptr @stack> 0
     with:      t62: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t62: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Legalizing: t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60
Legal node: nothing to do

Legalizing: t60: glue = SymphonyISD::CMP t51, Constant:i16<2>
Legal node: nothing to do

Legalized selection DAG: %bb.27 'main:'
SelectionDAG has 36 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
    t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16
  t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
  t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
    t46: ch = TokenFactor t43:1, t45:1
  t23: ch = TokenFactor t46, t16:1, t17:1
    t19: i16 = shl nuw nsw t17, Constant:i16<3>
  t20: i16 = add nuw t16, t19
      t22: i16 = add nuw t20, Constant:i16<4>
    t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
      t57: i16 = add nuw t20, Constant:i16<6>
    t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16
  t50: ch = TokenFactor t47, t49
        t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
      t60: glue = SymphonyISD::CMP t51, Constant:i16<2>
    t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60
  t35: ch = br t61, BasicBlock:ch< 0x16b38283fb0>



Legalizing: t62: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Combining: t62: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60
Legal node: nothing to do

Combining: t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60

Legalizing: t60: glue = SymphonyISD::CMP t51, Constant:i16<2>
Legal node: nothing to do

Combining: t60: glue = SymphonyISD::CMP t51, Constant:i16<2>

Legalizing: t35: ch = br t61, BasicBlock:ch< 0x16b38283fb0>
Legal node: nothing to do

Combining: t35: ch = br t61, BasicBlock:ch< 0x16b38283fb0>

Legalizing: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16

Legalizing: t50: ch = TokenFactor t47, t49
Legal node: nothing to do

Combining: t50: ch = TokenFactor t47, t49

Legalizing: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16

Legalizing: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16

Legalizing: t22: i16 = add nuw t20, Constant:i16<4>
Legal node: nothing to do

Combining: t22: i16 = add nuw t20, Constant:i16<4>

Legalizing: t57: i16 = add nuw t20, Constant:i16<6>
Legal node: nothing to do

Combining: t57: i16 = add nuw t20, Constant:i16<6>

Legalizing: t20: i16 = add nuw t16, t19
Legal node: nothing to do

Combining: t20: i16 = add nuw t16, t19

Legalizing: t23: ch = TokenFactor t46, t16:1, t17:1
Legal node: nothing to do

Combining: t23: ch = TokenFactor t46, t16:1, t17:1

Legalizing: t19: i16 = shl nuw nsw t17, Constant:i16<3>
Legal node: nothing to do

Combining: t19: i16 = shl nuw nsw t17, Constant:i16<3>

Legalizing: t46: ch = TokenFactor t43:1, t45:1
Legal node: nothing to do

Combining: t46: ch = TokenFactor t43:1, t45:1

Legalizing: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16

Legalizing: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Legalizing non-extending load operation

Combining: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16

Legalizing: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16
Legalizing non-extending load operation

Combining: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16

Legalizing: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Legalizing truncating store operations

Combining: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16

Legalizing: t10: i16 = add nuw t4, t9
Legal node: nothing to do

Combining: t10: i16 = add nuw t4, t9

Legalizing: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Legal node: nothing to do

Combining: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Legalizing: t12: ch = TokenFactor t4:1, t6:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t4:1, t6:1

Legalizing: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Legal node: nothing to do

Combining: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

Legalizing: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t56: i16 = Constant<6>
Legal node: nothing to do

Combining: t56: i16 = Constant<6>

Legalizing: t41: i16 = Constant<0>
Legal node: nothing to do

Combining: t41: i16 = Constant<0>

Legalizing: t40: i16 = Constant<2>
Legal node: nothing to do

Combining: t40: i16 = Constant<2>

Legalizing: t34: ch = BasicBlock< 0x16b38283fb0>
Legal node: nothing to do

Combining: t34: ch = BasicBlock< 0x16b38283fb0>

Legalizing: t32: ch = BasicBlock< 0x16b38288ac0>
Legal node: nothing to do

Combining: t32: ch = BasicBlock< 0x16b38288ac0>

Legalizing: t21: i16 = Constant<4>
Legal node: nothing to do

Combining: t21: i16 = Constant<4>

Legalizing: t14: i16 = FrameIndex<4>
Legal node: nothing to do

Combining: t14: i16 = FrameIndex<4>

Legalizing: t8: i16 = Constant<3>
Legal node: nothing to do

Combining: t8: i16 = Constant<3>

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i16 = FrameIndex<1>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.27 'main:'
SelectionDAG has 36 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
    t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
  t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16
  t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
  t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
    t46: ch = TokenFactor t43:1, t45:1
  t23: ch = TokenFactor t46, t16:1, t17:1
    t19: i16 = shl nuw nsw t17, Constant:i16<3>
  t20: i16 = add nuw t16, t19
      t22: i16 = add nuw t20, Constant:i16<4>
    t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
      t57: i16 = add nuw t20, Constant:i16<6>
    t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16
  t50: ch = TokenFactor t47, t49
        t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
      t60: glue = SymphonyISD::CMP t51, Constant:i16<2>
    t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60
  t35: ch = br t61, BasicBlock:ch< 0x16b38283fb0>


===== Instruction selection begins: %bb.27 ''

ISEL: Starting selection on root node: t35: ch = br t61, BasicBlock:ch< 0x16b38283fb0>
Selecting: t35: ch = br t61, BasicBlock:ch< 0x16b38283fb0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t35: ch = JMPI BasicBlock:ch< 0x16b38283fb0>, t61
ISEL: Match complete!

ISEL: Starting selection on root node: t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60
Selecting: t61: ch = SymphonyISD::BR_CC t50, BasicBlock:ch< 0x16b38288ac0>, Constant:i16<4>, t60

ISEL: Starting pattern match
  Initial Opcode index to 413
  Skipped scope entry (due to false predicate) at index 423, continuing at 432
  Skipped scope entry (due to false predicate) at index 433, continuing at 442
  Morphed node: t61: ch = JLI BasicBlock:ch< 0x16b38288ac0>, t50, t60
ISEL: Match complete!

ISEL: Starting selection on root node: t60: glue = SymphonyISD::CMP t51, Constant:i16<2>
Selecting: t60: glue = SymphonyISD::CMP t51, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t63: i16 = TargetConstant<2>
  Morphed node: t60: i16,glue = CMPI t51, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16
Selecting: t51: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t50, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t51: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t50
ISEL: Match complete!

ISEL: Starting selection on root node: t50: ch = TokenFactor t47, t49
Selecting: t50: ch = TokenFactor t47, t49


ISEL: Starting selection on root node: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16
Selecting: t47: ch = store<(store (s16) into %ir.96, align 4)> t23, t43, t22, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t47: ch = STORE16R<Mem:(store (s16) into %ir.96, align 4)> t22, t43, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16
Selecting: t49: ch = store<(store (s16) into %ir.96 + 2, basealign 4)> t23, t45, t57, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i16 = add nuw t20, Constant:i16<4>
Selecting: t22: i16 = add nuw t20, Constant:i16<4>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t64: i16 = TargetConstant<4>
  Morphed node: t22: i16 = ADDI nuw t20, TargetConstant:i16<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t57: i16 = add nuw t20, Constant:i16<6>
Selecting: t57: i16 = add nuw t20, Constant:i16<6>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t65: i16 = TargetConstant<6>
  Morphed node: t57: i16 = ADDI nuw t20, TargetConstant:i16<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16 = add nuw t16, t19
Selecting: t20: i16 = add nuw t16, t19

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t20: i16 = ADDR nuw t16, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch = TokenFactor t46, t16:1, t17:1
Selecting: t23: ch = TokenFactor t46, t16:1, t17:1


ISEL: Starting selection on root node: t19: i16 = shl nuw nsw t17, Constant:i16<3>
Selecting: t19: i16 = shl nuw nsw t17, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
Creating constant: t66: i16 = TargetConstant<3>
  Morphed node: t19: i16 = LSLI nuw nsw t17, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t46: ch = TokenFactor t43:1, t45:1
Selecting: t46: ch = TokenFactor t43:1, t45:1


ISEL: Starting selection on root node: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16
Selecting: t17: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t42, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t17: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t42
ISEL: Match complete!

ISEL: Starting selection on root node: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t16: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t42, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42
ISEL: Match complete!

ISEL: Starting selection on root node: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16
Selecting: t43: i16,ch = load<(dereferenceable load (s16) from %ir.5, align 4)> t42, FrameIndex:i16<4>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> FrameIndex:i16<4>, t42
ISEL: Match complete!

ISEL: Starting selection on root node: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16
Selecting: t45: i16,ch = load<(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t42, t58, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42
ISEL: Match complete!

ISEL: Starting selection on root node: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16
Selecting: t42: ch = store<(store (s8) into %ir.90, align 4), trunc to i8> t12, Constant:i16<0>, t10, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, Constant:i16<0>, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i16 = add nuw t4, t9
Selecting: t10: i16 = add nuw t4, t9

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t10: i16 = ADDR nuw t4, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t4:1, t6:1
Selecting: t12: ch = TokenFactor t4:1, t6:1


ISEL: Starting selection on root node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Selecting: t9: i16 = shl nuw nsw t6, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
  Morphed node: t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>
Selecting: t58: i16 = or disjoint FrameIndex:i16<4>, Constant:i16<2>

ISEL: Starting pattern match
  Initial Opcode index to 526
  Morphed node: t58: i16 = ORI disjoint FrameIndex:i16<4>, TargetConstant:i16<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Selecting: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t62: i16 = TargetGlobalAddress<ptr @stack> 0
Selecting: t62: i16 = TargetGlobalAddress<ptr @stack> 0


ISEL: Starting selection on root node: t41: i16 = Constant<0>
Selecting: t41: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t67: i16 = TargetConstant<0>
  Morphed node: t41: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t34: ch = BasicBlock< 0x16b38283fb0>
Selecting: t34: ch = BasicBlock< 0x16b38283fb0>


ISEL: Starting selection on root node: t32: ch = BasicBlock< 0x16b38288ac0>
Selecting: t32: ch = BasicBlock< 0x16b38288ac0>


ISEL: Starting selection on root node: t14: i16 = FrameIndex<4>
Selecting: t14: i16 = FrameIndex<4>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t14: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i16 = FrameIndex<1>
Selecting: t5: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.27 'main:'
SelectionDAG has 38 nodes:
  t0: ch,glue = EntryToken
  t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
  t14: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>
  t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0
  t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
      t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>
    t10: i16 = ADDR nuw t4, t9
    t41: i16 = MOVI TargetConstant:i16<0>
    t12: ch = TokenFactor t4:1, t6:1
  t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, t41, t12
    t58: i16 = ORI disjoint t14, TargetConstant:i16<2>
  t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42
  t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42
  t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42
  t17: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t42
    t46: ch = TokenFactor t43:1, t45:1
  t23: ch = TokenFactor t46, t16:1, t17:1
    t19: i16 = LSLI nuw nsw t17, TargetConstant:i16<3>
  t20: i16 = ADDR nuw t16, t19
      t22: i16 = ADDI nuw t20, TargetConstant:i16<4>
    t47: ch = STORE16R<Mem:(store (s16) into %ir.96, align 4)> t22, t43, t23
      t57: i16 = ADDI nuw t20, TargetConstant:i16<6>
    t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23
  t50: ch = TokenFactor t47, t49
        t51: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t50
      t60: i16,glue = CMPI t51, TargetConstant:i16<2>
    t61: ch = JLI BasicBlock:ch< 0x16b38288ac0>, t50, t60:1
  t35: ch = JMPI BasicBlock:ch< 0x16b38283fb0>, t61


********** List Scheduling %bb.27 '' **********
SU(0): t35: ch = JMPI BasicBlock:ch< 0x16b38283fb0>, t61

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t61: ch = JLI BasicBlock:ch< 0x16b38288ac0>, t50, t60:1

    t60: i16,glue = CMPI t51, TargetConstant:i16<2>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t51: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t50

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 10
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
    SU(4): Ord  Latency=0 Barrier
  Successors:
    SU(1): Data Latency=1
SU(3): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(2): Data Latency=1
    SU(7): Data Latency=1
    SU(10): Data Latency=1
SU(4): t50: ch = TokenFactor t47, t49

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 10
  Height             : 2
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
    SU(2): Ord  Latency=0 Barrier
SU(5): t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(19): Data Latency=1
    SU(6): Ord  Latency=0 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(6): t23: ch = TokenFactor t46, t16:1, t17:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 3
  Predecessors:
    SU(16): Ord  Latency=0 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=0 Barrier
    SU(24): Ord  Latency=0 Barrier
SU(7): t17: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t42

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 7
  Predecessors:
    SU(3): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(23): Data Latency=1
SU(8): t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, t41, t12

  # preds left       : 3
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
    SU(12): Data Latency=1
    SU(9): Ord  Latency=0 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(19): Ord  Latency=1 Barrier
SU(9): t12: ch = TokenFactor t4:1, t6:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=0 Barrier
SU(10): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 11
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(14): Data Latency=1
SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(13): Data Latency=1
SU(12): t41: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(8): Data Latency=1
SU(13): t10: i16 = ADDR nuw t4, t9

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 9
  Predecessors:
    SU(11): Data Latency=1
    SU(14): Data Latency=1
  Successors:
    SU(8): Data Latency=1
SU(14): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(15): t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 6
  Predecessors:
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(16): t46: ch = TokenFactor t43:1, t45:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 3
  Predecessors:
    SU(17): Ord  Latency=1 Barrier
    SU(19): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=0 Barrier
SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 4
  Predecessors:
    SU(18): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(16): Ord  Latency=1 Barrier
    SU(24): Data Latency=1
SU(18): t14: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(17): Data Latency=1
    SU(20): Data Latency=1
SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 4
  Predecessors:
    SU(20): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(5): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
SU(20): t58: i16 = ORI disjoint t14, TargetConstant:i16<2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(18): Data Latency=1
  Successors:
    SU(19): Data Latency=1
SU(21): t57: i16 = ADDI nuw t20, TargetConstant:i16<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(22): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(22): t20: i16 = ADDR nuw t16, t19

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(15): Data Latency=1
    SU(23): Data Latency=1
  Successors:
    SU(21): Data Latency=1
    SU(25): Data Latency=1
SU(23): t19: i16 = LSLI nuw nsw t17, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 6
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(22): Data Latency=1
SU(24): t47: ch = STORE16R<Mem:(store (s16) into %ir.96, align 4)> t22, t43, t23

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(25): Data Latency=1
    SU(17): Data Latency=1
    SU(6): Ord  Latency=0 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(22): Data Latency=1
  Successors:
    SU(24): Data Latency=1

Examining Available:
Height 0: SU(0): t35: ch = JMPI BasicBlock:ch< 0x16b38283fb0>, t61


*** Scheduling [0]: SU(0): t35: ch = JMPI BasicBlock:ch< 0x16b38283fb0>, t61


Examining Available:
Height 1: SU(1): t61: ch = JLI BasicBlock:ch< 0x16b38288ac0>, t50, t60:1

    t60: i16,glue = CMPI t51, TargetConstant:i16<2>


*** Scheduling [1]: SU(1): t61: ch = JLI BasicBlock:ch< 0x16b38288ac0>, t50, t60:1

    t60: i16,glue = CMPI t51, TargetConstant:i16<2>


Examining Available:
Height 2: SU(2): t51: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t50


*** Scheduling [2]: SU(2): t51: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t50


Examining Available:
Height 2: SU(4): t50: ch = TokenFactor t47, t49


*** Scheduling [3]: SU(4): t50: ch = TokenFactor t47, t49


Examining Available:
Height 4: SU(24): t47: ch = STORE16R<Mem:(store (s16) into %ir.96, align 4)> t22, t43, t23

Height 4: SU(5): t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23


*** Scheduling [4]: SU(24): t47: ch = STORE16R<Mem:(store (s16) into %ir.96, align 4)> t22, t43, t23


Examining Available:
Height 4: SU(5): t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23

Height 5: SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>


*** Scheduling [5]: SU(5): t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23


Examining Available:
Height 5: SU(6): t23: ch = TokenFactor t46, t16:1, t17:1

Height 6: SU(21): t57: i16 = ADDI nuw t20, TargetConstant:i16<6>

Height 5: SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>


*** Scheduling [6]: SU(6): t23: ch = TokenFactor t46, t16:1, t17:1


Examining Available:
Height 6: SU(16): t46: ch = TokenFactor t43:1, t45:1

Height 6: SU(21): t57: i16 = ADDI nuw t20, TargetConstant:i16<6>

Height 5: SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>


*** Scheduling [7]: SU(16): t46: ch = TokenFactor t43:1, t45:1


Examining Available:
Height 6: SU(21): t57: i16 = ADDI nuw t20, TargetConstant:i16<6>

Height 5: SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>

Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [8]: SU(21): t57: i16 = ADDI nuw t20, TargetConstant:i16<6>


Examining Available:
Height 5: SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>

Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [9]: SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>


Examining Available:
Height 10: SU(22): t20: i16 = ADDR nuw t16, t19

Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [10]: SU(22): t20: i16 = ADDR nuw t16, t19


Examining Available:
Height 11: SU(23): t19: i16 = LSLI nuw nsw t17, TargetConstant:i16<3>

Height 11: SU(15): t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42

Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [11]: SU(23): t19: i16 = LSLI nuw nsw t17, TargetConstant:i16<3>


Examining Available:
Height 12: SU(7): t17: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t42

Height 11: SU(15): t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42

Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [12]: SU(7): t17: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t42


Examining Available:
Height 11: SU(15): t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42

Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [13]: SU(15): t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42


Examining Available:
Height 8: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [14]: SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42


Examining Available:
Height 15: SU(20): t58: i16 = ORI disjoint t14, TargetConstant:i16<2>

Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [15]: SU(20): t58: i16 = ORI disjoint t14, TargetConstant:i16<2>


Examining Available:
Height 8: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


*** Scheduling [16]: SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42


Examining Available:
Height 17: SU(18): t14: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

Height 17: SU(8): t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, t41, t12


*** Scheduling [17]: SU(18): t14: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>


Examining Available:
Height 17: SU(8): t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, t41, t12


*** Scheduling [18]: SU(8): t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, t41, t12


Examining Available:
Height 18: SU(9): t12: ch = TokenFactor t4:1, t6:1

Height 19: SU(12): t41: i16 = MOVI TargetConstant:i16<0>

Height 19: SU(13): t10: i16 = ADDR nuw t4, t9


*** Scheduling [19]: SU(9): t12: ch = TokenFactor t4:1, t6:1


Examining Available:
Height 19: SU(12): t41: i16 = MOVI TargetConstant:i16<0>

Height 19: SU(13): t10: i16 = ADDR nuw t4, t9


*** Scheduling [20]: SU(12): t41: i16 = MOVI TargetConstant:i16<0>


Examining Available:
Height 19: SU(13): t10: i16 = ADDR nuw t4, t9


*** Scheduling [21]: SU(13): t10: i16 = ADDR nuw t4, t9


Examining Available:
Height 22: SU(14): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>

Height 22: SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [22]: SU(14): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>


Examining Available:
Height 23: SU(10): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

Height 22: SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [23]: SU(10): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0


Examining Available:
Height 24: SU(3): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 22: SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [24]: SU(3): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 22: SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [25]: SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

*** Final schedule ***
SU(11): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

SU(3): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(10): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

SU(14): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>

SU(13): t10: i16 = ADDR nuw t4, t9

SU(12): t41: i16 = MOVI TargetConstant:i16<0>

SU(9): t12: ch = TokenFactor t4:1, t6:1

SU(8): t42: ch = STORE8R<Mem:(store (s8) into %ir.90, align 4)> t10, t41, t12

SU(18): t14: i16 = ADDI TargetFrameIndex:i16<4>, TargetConstant:i16<0>

SU(17): t43: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5, align 4)> t14, t42

SU(20): t58: i16 = ORI disjoint t14, TargetConstant:i16<2>

SU(19): t45: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.5 + 2, basealign 4)> t58, t42

SU(15): t16: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t42

SU(7): t17: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t42

SU(23): t19: i16 = LSLI nuw nsw t17, TargetConstant:i16<3>

SU(22): t20: i16 = ADDR nuw t16, t19

SU(25): t22: i16 = ADDI nuw t20, TargetConstant:i16<4>

SU(21): t57: i16 = ADDI nuw t20, TargetConstant:i16<6>

SU(16): t46: ch = TokenFactor t43:1, t45:1

SU(6): t23: ch = TokenFactor t46, t16:1, t17:1

SU(5): t49: ch = STORE16R<Mem:(store (s16) into %ir.96 + 2, basealign 4)> t57, t45, t23

SU(24): t47: ch = STORE16R<Mem:(store (s16) into %ir.96, align 4)> t22, t43, t23

SU(4): t50: ch = TokenFactor t47, t49

SU(2): t51: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t50

SU(1): t61: ch = JLI BasicBlock:ch< 0x16b38288ac0>, t50, t60:1

    t60: i16,glue = CMPI t51, TargetConstant:i16<2>

SU(0): t35: ch = JMPI BasicBlock:ch< 0x16b38283fb0>, t61


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Creating new node: t7: i32 = zero_extend t6
Creating constant: t8: i32 = Constant<2>
Creating new node: t9: i32 = sub nsw t7, Constant:i32<2>
Creating new node: t10: i16 = truncate t9
Creating constant: t11: i16 = Constant<3>
Creating new node: t12: i16 = shl nsw t10, Constant:i16<3>
Creating new node: t13: i16 = add t4, t12
Creating new node: t14: i8,ch = load<(load (s8) from %ir.106, align 4)> t0, t13, undef:i16
Creating new node: t15: i32 = sign_extend t14
Creating constant: t16: i32 = Constant<0>
Creating new node: t18: i1 = setcc t15, Constant:i32<0>, setne:ch
Creating constant: t19: i1 = Constant<-1>
Creating new node: t20: i1 = xor t18, Constant:i1<-1>
Creating new node: t22: ch = brcond t0, t20, BasicBlock:ch< 0x16b38284388>
Creating new node: t24: ch = br t22, BasicBlock:ch< 0x16b382840f8>

Initial selection DAG: %bb.28 'main:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
                t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
                        t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
                      t7: i32 = zero_extend t6
                    t9: i32 = sub nsw t7, Constant:i32<2>
                  t10: i16 = truncate t9
                t12: i16 = shl nsw t10, Constant:i16<3>
              t13: i16 = add t4, t12
            t14: i8,ch = load<(load (s8) from %ir.106, align 4)> t0, t13, undef:i16
          t15: i32 = sign_extend t14
        t18: i1 = setcc t15, Constant:i32<0>, setne:ch
      t20: i1 = xor t18, Constant:i1<-1>
    t22: ch = brcond t0, t20, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t22, BasicBlock:ch< 0x16b382840f8>



Combining: t24: ch = br t22, BasicBlock:ch< 0x16b382840f8>

Combining: t23: ch = BasicBlock< 0x16b382840f8>

Combining: t22: ch = brcond t0, t20, BasicBlock:ch< 0x16b38284388>
Creating new node: t26: i1 = setcc t15, Constant:i32<0>, seteq:ch
Creating new node: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
 ... into: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>

Combining: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>

Combining: t26: i1 = setcc t15, Constant:i32<0>, seteq:ch

Combining: t25: ch = seteq

Combining: t24: ch = br t27, BasicBlock:ch< 0x16b382840f8>

Combining: t21: ch = BasicBlock< 0x16b38284388>

Combining: t16: i32 = Constant<0>

Combining: t15: i32 = sign_extend t14
Creating new node: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t13, undef:i16

Replacing.1 t15: i32 = sign_extend t14

With: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t13, undef:i16
 and 0 other values

Combining: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t13, undef:i16

Combining: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch

Combining: t13: i16 = add t4, t12
Creating new node: t29: i32 = any_extend t6

Replacing.2 t7: i32 = zero_extend t6

With: t29: i32 = any_extend t6


Combining: t29: i32 = any_extend t6
Creating new node: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16

Replacing.1 t29: i32 = any_extend t6

With: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16
 and 0 other values

Combining: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16

Combining: t13: i16 = add t4, t12

Combining: t12: i16 = shl t10, Constant:i16<3>

Combining: t11: i16 = Constant<3>

Combining: t10: i16 = truncate t9
Creating new node: t31: i16 = truncate t30
Creating constant: t32: i16 = Constant<2>
Creating new node: t33: i16 = sub t31, Constant:i16<2>
 ... into: t33: i16 = sub t31, Constant:i16<2>

Combining: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16

Combining: t33: i16 = sub t31, Constant:i16<2>
Creating constant: t34: i16 = Constant<-2>
Creating new node: t35: i16 = add t31, Constant:i16<-2>
 ... into: t35: i16 = add t31, Constant:i16<-2>

Combining: t35: i16 = add t31, Constant:i16<-2>

Combining: t34: i16 = Constant<-2>

Combining: t31: i16 = truncate t30
Creating constant: t36: i16 = Constant<0>
Creating new node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
 ... into: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t35: i16 = add t37, Constant:i16<-2>

Combining: t12: i16 = shl t35, Constant:i16<3>
Creating constant: t38: i16 = Constant<-16>
Creating new node: t39: i16 = shl t37, Constant:i16<3>
Creating new node: t40: i16 = add t39, Constant:i16<-16>
 ... into: t40: i16 = add t39, Constant:i16<-16>

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t11: i16 = Constant<3>

Combining: t40: i16 = add t39, Constant:i16<-16>

Combining: t38: i16 = Constant<-16>

Combining: t13: i16 = add t4, t40
Creating new node: t41: i16 = add t39, t4
Creating new node: t42: i16 = add t41, Constant:i16<-16>
 ... into: t42: i16 = add t41, Constant:i16<-16>

Combining: t38: i16 = Constant<-16>

Combining: t42: i16 = add t41, Constant:i16<-16>

Combining: t41: i16 = add t39, t4

Combining: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16

Combining: t39: i16 = shl t37, Constant:i16<3>

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.28 'main:'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
                t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
              t39: i16 = shl t37, Constant:i16<3>
              t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
            t41: i16 = add t39, t4
          t42: i16 = add t41, Constant:i16<-16>
        t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
      t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
    t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t27, BasicBlock:ch< 0x16b382840f8>



Legalizing node: t38: i16 = Constant<-16>
Analyzing result type: i16
Legal result type
Legally typed node: t38: i16 = Constant<-16>

Legalizing node: t25: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t25: ch = seteq

Legalizing node: t23: ch = BasicBlock< 0x16b382840f8>
Analyzing result type: ch
Legal result type
Legally typed node: t23: ch = BasicBlock< 0x16b382840f8>

Legalizing node: t21: ch = BasicBlock< 0x16b38284388>
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = BasicBlock< 0x16b38284388>

Legalizing node: t16: i32 = Constant<0>
Analyzing result type: i32
Expand integer result: t16: i32 = Constant<0>
Creating constant: t43: i16 = Constant<0>

Legalizing node: t43: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t43: i16 = Constant<0>

Legalizing node: t11: i16 = Constant<3>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = Constant<3>

Legalizing node: t5: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = FrameIndex<1>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = GlobalAddress<ptr @stack> 0
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = GlobalAddress<ptr @stack> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing node: t39: i16 = shl t37, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t11: i16 = Constant<3>
Legal operand
Legally typed node: t39: i16 = shl t37, Constant:i16<3>

Legalizing node: t41: i16 = add t39, t4
Analyzing result type: i16
Legal result type
Analyzing operand: t39: i16 = shl t37, Constant:i16<3>
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Legally typed node: t41: i16 = add t39, t4

Legalizing node: t42: i16 = add t41, Constant:i16<-16>
Analyzing result type: i16
Legal result type
Analyzing operand: t41: i16 = add t39, t4
Legal operand
Analyzing operand: t38: i16 = Constant<-16>
Legal operand
Legally typed node: t42: i16 = add t41, Constant:i16<-16>

Legalizing node: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Analyzing result type: i32
Expand integer result: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Creating new node: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Creating constant: t45: i16 = Constant<15>
Creating new node: t46: i16 = sra t44, Constant:i16<15>

Legalizing node: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Analyzing result type: i1
Promote integer result: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Creating new node: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch

Legalizing node: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Promote integer operand: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
Creating new node: t48: i16 = any_extend t26

Legalizing node: t48: i16 = any_extend t26
Analyzing result type: i16
Legal result type
Analyzing operand: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Promote integer operand: t48: i16 = any_extend t26
Replacing: t48: i16 = any_extend t26
     with: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch

Legalizing node: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t28: i32,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Expand integer operand: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch
Creating new node: t49: i16 = or t44, t46

Legalizing node: t45: i16 = Constant<15>
Analyzing result type: i16
Legal result type
Legally typed node: t45: i16 = Constant<15>

Legalizing node: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t42: i16 = add t41, Constant:i16<-16>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16

Legalizing node: t46: i16 = sra t44, Constant:i16<15>
Analyzing result type: i16
Legal result type
Analyzing operand: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Legal operand
Analyzing operand: t45: i16 = Constant<15>
Legal operand
Legally typed node: t46: i16 = sra t44, Constant:i16<15>

Legalizing node: t49: i16 = or t44, t46
Analyzing result type: i16
Legal result type
Analyzing operand: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Legal operand
Analyzing operand: t46: i16 = sra t44, Constant:i16<15>
Legal operand
Legally typed node: t49: i16 = or t44, t46

Legalizing node: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t49: i16 = or t44, t46
Legal operand
Analyzing operand: t43: i16 = Constant<0>
Legal operand
Analyzing operand: t25: ch = seteq
Legal operand
Legally typed node: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch

Legalizing node: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t21: ch = BasicBlock< 0x16b38284388>
Legal operand
Legally typed node: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>

Legalizing node: t24: ch = br t27, BasicBlock:ch< 0x16b382840f8>
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
Legal operand
Analyzing operand: t23: ch = BasicBlock< 0x16b382840f8>
Legal operand
Legally typed node: t24: ch = br t27, BasicBlock:ch< 0x16b382840f8>

Legalizing node: t65535: ch = handlenode t24
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = br t27, BasicBlock:ch< 0x16b382840f8>
Legal operand
Legally typed node: t65535: ch = handlenode t24

Type-legalized selection DAG: %bb.28 'main:'
SelectionDAG has 22 nodes:
  t0: ch,glue = EntryToken
          t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
        t39: i16 = shl t37, Constant:i16<3>
        t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t41: i16 = add t39, t4
    t42: i16 = add t41, Constant:i16<-16>
  t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
          t46: i16 = sra t44, Constant:i16<15>
        t49: i16 = or t44, t46
      t47: i16 = setcc t49, Constant:i16<0>, seteq:ch
    t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t27, BasicBlock:ch< 0x16b382840f8>



Combining: t49: i16 = or t44, t46

Combining: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch

Combining: t46: i16 = sra t44, Constant:i16<15>

Combining: t45: i16 = Constant<15>

Combining: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16

Combining: t43: i16 = Constant<0>

Combining: t42: i16 = add t41, Constant:i16<-16>

Combining: t41: i16 = add t39, t4

Combining: t39: i16 = shl t37, Constant:i16<3>

Combining: t38: i16 = Constant<-16>

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
Creating new node: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
 ... into: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>

Combining: t49: i16 = or t44, t46

Combining: t43: i16 = Constant<0>

Combining: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>

Combining: t25: ch = seteq

Combining: t24: ch = br t50, BasicBlock:ch< 0x16b382840f8>

Combining: t23: ch = BasicBlock< 0x16b382840f8>

Combining: t21: ch = BasicBlock< 0x16b38284388>

Combining: t11: i16 = Constant<3>

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.28 'main:'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
          t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
        t39: i16 = shl t37, Constant:i16<3>
        t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t41: i16 = add t39, t4
    t42: i16 = add t41, Constant:i16<-16>
  t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
        t46: i16 = sra t44, Constant:i16<15>
      t49: i16 = or t44, t46
    t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t50, BasicBlock:ch< 0x16b382840f8>



Legalizing: t24: ch = br t50, BasicBlock:ch< 0x16b382840f8>
Legal node: nothing to do

Legalizing: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
Trying custom legalization
Creating new node: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Creating constant: t52: i16 = Constant<1>
Creating new node: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Successfully custom legalized node
 ... replacing: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
     with:      t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51

Legalizing: t49: i16 = or t44, t46
Legal node: nothing to do

Legalizing: t46: i16 = sra t44, Constant:i16<15>
Legal node: nothing to do

Legalizing: t44: i16,ch = load<(load (s8) from %ir.106, align 4), sext from i8> t0, t42, undef:i16
Legalizing extending load operation
Creating new node: t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16
Creating new node: t56: i16 = sign_extend_inreg t54, ValueType:ch:i8

Legalizing: t42: i16 = add t41, Constant:i16<-16>
Legal node: nothing to do

Legalizing: t41: i16 = add t39, t4
Legal node: nothing to do

Legalizing: t39: i16 = shl t37, Constant:i16<3>
Legal node: nothing to do

Legalizing: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t45: i16 = Constant<15>
Legal node: nothing to do

Legalizing: t43: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t38: i16 = Constant<-16>
Legal node: nothing to do

Legalizing: t23: ch = BasicBlock< 0x16b382840f8>
Legal node: nothing to do

Legalizing: t21: ch = BasicBlock< 0x16b38284388>
Legal node: nothing to do

Legalizing: t11: i16 = Constant<3>
Legal node: nothing to do

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = GlobalAddress<ptr @stack> 0
Trying custom legalization
Successfully custom legalized node
 ... replacing: t1: i16 = GlobalAddress<ptr @stack> 0
     with:      t57: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t57: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Legalizing: t56: i16 = sign_extend_inreg t54, ValueType:ch:i8
Trying to expand node
Creating constant: t58: i16 = Constant<8>
Creating new node: t59: i16 = shl t54, Constant:i16<8>
Creating new node: t60: i16 = sra t59, Constant:i16<8>
Successfully expanded node
 ... replacing: t56: i16 = sign_extend_inreg t54, ValueType:ch:i8
     with:      t60: i16 = sra t59, Constant:i16<8>

Legalizing: t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16
Legalizing extending load operation

Legalizing: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Legal node: nothing to do

Legalizing: t52: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Legal node: nothing to do

Legalizing: t60: i16 = sra t59, Constant:i16<8>
Legal node: nothing to do

Legalizing: t59: i16 = shl t54, Constant:i16<8>
Legal node: nothing to do

Legalizing: t58: i16 = Constant<8>
Legal node: nothing to do

Legalized selection DAG: %bb.28 'main:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
              t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
            t39: i16 = shl t37, Constant:i16<3>
            t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
          t41: i16 = add t39, t4
        t42: i16 = add t41, Constant:i16<-16>
      t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16
    t59: i16 = shl t54, Constant:i16<8>
  t60: i16 = sra t59, Constant:i16<8>
          t46: i16 = sra t60, Constant:i16<15>
        t49: i16 = or t60, t46
      t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
    t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
  t24: ch = br t53, BasicBlock:ch< 0x16b382840f8>



Legalizing: t60: i16 = sra t59, Constant:i16<8>
Legal node: nothing to do

Combining: t60: i16 = sra t59, Constant:i16<8>

Legalizing: t59: i16 = shl t54, Constant:i16<8>
Legal node: nothing to do

Combining: t59: i16 = shl t54, Constant:i16<8>

Legalizing: t58: i16 = Constant<8>
Legal node: nothing to do

Combining: t58: i16 = Constant<8>

Legalizing: t57: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Combining: t57: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16
Legalizing extending load operation

Combining: t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16

Legalizing: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Legal node: nothing to do

Combining: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51

Legalizing: t52: i16 = Constant<1>
Legal node: nothing to do

Combining: t52: i16 = Constant<1>

Legalizing: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Legal node: nothing to do

Combining: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>

Legalizing: t24: ch = br t53, BasicBlock:ch< 0x16b382840f8>
Legal node: nothing to do

Combining: t24: ch = br t53, BasicBlock:ch< 0x16b382840f8>

Legalizing: t49: i16 = or t60, t46
Legal node: nothing to do

Combining: t49: i16 = or t60, t46

Legalizing: t46: i16 = sra t60, Constant:i16<15>
Legal node: nothing to do

Combining: t46: i16 = sra t60, Constant:i16<15>
Creating new node: t61: i16 = sra t59, Constant:i16<15>
 ... into: t61: i16 = sra t59, Constant:i16<15>

Legalizing: t60: i16 = sra t59, Constant:i16<8>
Legal node: nothing to do

Combining: t60: i16 = sra t59, Constant:i16<8>

Legalizing: t61: i16 = sra t59, Constant:i16<15>
Legal node: nothing to do

Combining: t61: i16 = sra t59, Constant:i16<15>

Legalizing: t49: i16 = or t60, t61
Legal node: nothing to do

Combining: t49: i16 = or t60, t61

Legalizing: t42: i16 = add t41, Constant:i16<-16>
Legal node: nothing to do

Combining: t42: i16 = add t41, Constant:i16<-16>

Legalizing: t41: i16 = add t39, t4
Legal node: nothing to do

Combining: t41: i16 = add t39, t4

Legalizing: t39: i16 = shl t37, Constant:i16<3>
Legal node: nothing to do

Combining: t39: i16 = shl t37, Constant:i16<3>

Legalizing: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t45: i16 = Constant<15>
Legal node: nothing to do

Combining: t45: i16 = Constant<15>

Legalizing: t43: i16 = Constant<0>
Legal node: nothing to do

Combining: t43: i16 = Constant<0>

Legalizing: t38: i16 = Constant<-16>
Legal node: nothing to do

Combining: t38: i16 = Constant<-16>

Legalizing: t23: ch = BasicBlock< 0x16b382840f8>
Legal node: nothing to do

Combining: t23: ch = BasicBlock< 0x16b382840f8>

Legalizing: t21: ch = BasicBlock< 0x16b38284388>
Legal node: nothing to do

Combining: t21: ch = BasicBlock< 0x16b38284388>

Legalizing: t11: i16 = Constant<3>
Legal node: nothing to do

Combining: t11: i16 = Constant<3>

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i16 = FrameIndex<1>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.28 'main:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
            t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
          t39: i16 = shl t37, Constant:i16<3>
          t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
        t41: i16 = add t39, t4
      t42: i16 = add t41, Constant:i16<-16>
    t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16
  t59: i16 = shl t54, Constant:i16<8>
          t60: i16 = sra t59, Constant:i16<8>
          t61: i16 = sra t59, Constant:i16<15>
        t49: i16 = or t60, t61
      t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
    t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
  t24: ch = br t53, BasicBlock:ch< 0x16b382840f8>


===== Instruction selection begins: %bb.28 ''

ISEL: Starting selection on root node: t24: ch = br t53, BasicBlock:ch< 0x16b382840f8>
Selecting: t24: ch = br t53, BasicBlock:ch< 0x16b382840f8>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t24: ch = JMPI BasicBlock:ch< 0x16b382840f8>, t53
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Selecting: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51
ISEL: Match complete!

ISEL: Starting selection on root node: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Selecting: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t62: i16 = TargetConstant<0>
  Morphed node: t51: i16,glue = CMPI t49, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t49: i16 = or t60, t61
Selecting: t49: i16 = or t60, t61

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t49: i16 = ORR t60, t61
ISEL: Match complete!

ISEL: Starting selection on root node: t60: i16 = sra t59, Constant:i16<8>
Selecting: t60: i16 = sra t59, Constant:i16<8>

ISEL: Starting pattern match
  Initial Opcode index to 766
Creating constant: t63: i16 = TargetConstant<8>
  Morphed node: t60: i16 = ASRI t59, TargetConstant:i16<8>
ISEL: Match complete!

ISEL: Starting selection on root node: t61: i16 = sra t59, Constant:i16<15>
Selecting: t61: i16 = sra t59, Constant:i16<15>

ISEL: Starting pattern match
  Initial Opcode index to 766
Creating constant: t64: i16 = TargetConstant<15>
  Morphed node: t61: i16 = ASRI t59, TargetConstant:i16<15>
ISEL: Match complete!

ISEL: Starting selection on root node: t59: i16 = shl t54, Constant:i16<8>
Selecting: t59: i16 = shl t54, Constant:i16<8>

ISEL: Starting pattern match
  Initial Opcode index to 646
  Morphed node: t59: i16 = LSLI t54, TargetConstant:i16<8>
ISEL: Match complete!

ISEL: Starting selection on root node: t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16
Selecting: t54: i16,ch = load<(load (s8) from %ir.106, align 4), anyext from i8> t0, t42, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Morphed node: t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.106, align 4)> t42, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t42: i16 = add t41, Constant:i16<-16>
Selecting: t42: i16 = add t41, Constant:i16<-16>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t65: i16 = TargetConstant<-16>
  Morphed node: t42: i16 = ADDI t41, TargetConstant:i16<-16>
ISEL: Match complete!

ISEL: Starting selection on root node: t41: i16 = add t39, t4
Selecting: t41: i16 = add t39, t4

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t41: i16 = ADDR t39, t4
ISEL: Match complete!

ISEL: Starting selection on root node: t39: i16 = shl t37, Constant:i16<3>
Selecting: t39: i16 = shl t37, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
Creating constant: t66: i16 = TargetConstant<3>
  Morphed node: t39: i16 = LSLI t37, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Selecting: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t57: i16 = TargetGlobalAddress<ptr @stack> 0
Selecting: t57: i16 = TargetGlobalAddress<ptr @stack> 0


ISEL: Starting selection on root node: t23: ch = BasicBlock< 0x16b382840f8>
Selecting: t23: ch = BasicBlock< 0x16b382840f8>


ISEL: Starting selection on root node: t21: ch = BasicBlock< 0x16b38284388>
Selecting: t21: ch = BasicBlock< 0x16b38284388>


ISEL: Starting selection on root node: t5: i16 = FrameIndex<1>
Selecting: t5: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.28 'main:'
SelectionDAG has 24 nodes:
  t0: ch,glue = EntryToken
              t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
            t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0
          t39: i16 = LSLI t37, TargetConstant:i16<3>
          t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
        t41: i16 = ADDR t39, t4
      t42: i16 = ADDI t41, TargetConstant:i16<-16>
    t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.106, align 4)> t42, t0
  t59: i16 = LSLI t54, TargetConstant:i16<8>
          t60: i16 = ASRI t59, TargetConstant:i16<8>
          t61: i16 = ASRI t59, TargetConstant:i16<15>
        t49: i16 = ORR t60, t61
      t51: i16,glue = CMPI t49, TargetConstant:i16<0>
    t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1
  t24: ch = JMPI BasicBlock:ch< 0x16b382840f8>, t53


********** List Scheduling %bb.28 '' **********
SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b382840f8>, t53

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t49: i16 = ORR t60, t61

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
    SU(12): Data Latency=1
SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.106, align 4)> t42, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t41: i16 = ADDR t39, t4

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(6): Data Latency=1
SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(7): Data Latency=1
SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(9): Data Latency=1
SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(10): Data Latency=1
SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b382840f8>, t53


*** Scheduling [0]: SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b382840f8>, t53


Examining Available:
Height 1: SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t49: i16 = ORR t60, t61


*** Scheduling [2]: SU(2): t49: i16 = ORR t60, t61


Examining Available:
Height 3: SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>

Height 3: SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>


*** Scheduling [3]: SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>


Examining Available:
Height 3: SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>


*** Scheduling [4]: SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>


Examining Available:
Height 5: SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>


*** Scheduling [5]: SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>


Examining Available:
Height 6: SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.106, align 4)> t42, t0


*** Scheduling [6]: SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.106, align 4)> t42, t0


Examining Available:
Height 7: SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>


*** Scheduling [7]: SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>


Examining Available:
Height 8: SU(7): t41: i16 = ADDR t39, t4


*** Scheduling [8]: SU(7): t41: i16 = ADDR t39, t4


Examining Available:
Height 9: SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>

Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [9]: SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>


Examining Available:
Height 10: SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [10]: SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0


Examining Available:
Height 11: SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [11]: SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [12]: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

*** Final schedule ***
SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>

SU(7): t41: i16 = ADDR t39, t4

SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>

SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.106, align 4)> t42, t0

SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>

SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>

SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>

SU(2): t49: i16 = ORR t60, t61

SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>

SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b382840f8>, t53


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Creating new node: t7: i32 = zero_extend t6
Creating constant: t8: i32 = Constant<2>
Creating new node: t9: i32 = sub nsw t7, Constant:i32<2>
Creating new node: t10: i16 = truncate t9
Creating constant: t11: i16 = Constant<3>
Creating new node: t12: i16 = shl nsw t10, Constant:i16<3>
Creating new node: t13: i16 = add t4, t12
Creating new node: t14: i8,ch = load<(load (s8) from %ir.116, align 4)> t0, t13, undef:i16
Creating new node: t15: i32 = sign_extend t14
Creating constant: t16: i32 = Constant<0>
Creating new node: t18: i1 = setcc t15, Constant:i32<0>, setne:ch
Creating constant: t19: i1 = Constant<-1>
Creating new node: t20: i1 = xor t18, Constant:i1<-1>
Creating new node: t22: ch = brcond t0, t20, BasicBlock:ch< 0x16b38284388>
Creating new node: t24: ch = br t22, BasicBlock:ch< 0x16b38284240>

Initial selection DAG: %bb.29 'main:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
                t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
                        t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
                      t7: i32 = zero_extend t6
                    t9: i32 = sub nsw t7, Constant:i32<2>
                  t10: i16 = truncate t9
                t12: i16 = shl nsw t10, Constant:i16<3>
              t13: i16 = add t4, t12
            t14: i8,ch = load<(load (s8) from %ir.116, align 4)> t0, t13, undef:i16
          t15: i32 = sign_extend t14
        t18: i1 = setcc t15, Constant:i32<0>, setne:ch
      t20: i1 = xor t18, Constant:i1<-1>
    t22: ch = brcond t0, t20, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t22, BasicBlock:ch< 0x16b38284240>



Combining: t24: ch = br t22, BasicBlock:ch< 0x16b38284240>

Combining: t23: ch = BasicBlock< 0x16b38284240>

Combining: t22: ch = brcond t0, t20, BasicBlock:ch< 0x16b38284388>
Creating new node: t26: i1 = setcc t15, Constant:i32<0>, seteq:ch
Creating new node: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
 ... into: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>

Combining: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>

Combining: t26: i1 = setcc t15, Constant:i32<0>, seteq:ch

Combining: t25: ch = seteq

Combining: t24: ch = br t27, BasicBlock:ch< 0x16b38284240>

Combining: t21: ch = BasicBlock< 0x16b38284388>

Combining: t16: i32 = Constant<0>

Combining: t15: i32 = sign_extend t14
Creating new node: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t13, undef:i16

Replacing.1 t15: i32 = sign_extend t14

With: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t13, undef:i16
 and 0 other values

Combining: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t13, undef:i16

Combining: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch

Combining: t13: i16 = add t4, t12
Creating new node: t29: i32 = any_extend t6

Replacing.2 t7: i32 = zero_extend t6

With: t29: i32 = any_extend t6


Combining: t29: i32 = any_extend t6
Creating new node: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16

Replacing.1 t29: i32 = any_extend t6

With: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16
 and 0 other values

Combining: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16

Combining: t13: i16 = add t4, t12

Combining: t12: i16 = shl t10, Constant:i16<3>

Combining: t11: i16 = Constant<3>

Combining: t10: i16 = truncate t9
Creating new node: t31: i16 = truncate t30
Creating constant: t32: i16 = Constant<2>
Creating new node: t33: i16 = sub t31, Constant:i16<2>
 ... into: t33: i16 = sub t31, Constant:i16<2>

Combining: t30: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t0, FrameIndex:i16<1>, undef:i16

Combining: t33: i16 = sub t31, Constant:i16<2>
Creating constant: t34: i16 = Constant<-2>
Creating new node: t35: i16 = add t31, Constant:i16<-2>
 ... into: t35: i16 = add t31, Constant:i16<-2>

Combining: t35: i16 = add t31, Constant:i16<-2>

Combining: t34: i16 = Constant<-2>

Combining: t31: i16 = truncate t30
Creating constant: t36: i16 = Constant<0>
Creating new node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
 ... into: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t35: i16 = add t37, Constant:i16<-2>

Combining: t12: i16 = shl t35, Constant:i16<3>
Creating constant: t38: i16 = Constant<-16>
Creating new node: t39: i16 = shl t37, Constant:i16<3>
Creating new node: t40: i16 = add t39, Constant:i16<-16>
 ... into: t40: i16 = add t39, Constant:i16<-16>

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t11: i16 = Constant<3>

Combining: t40: i16 = add t39, Constant:i16<-16>

Combining: t38: i16 = Constant<-16>

Combining: t13: i16 = add t4, t40
Creating new node: t41: i16 = add t39, t4
Creating new node: t42: i16 = add t41, Constant:i16<-16>
 ... into: t42: i16 = add t41, Constant:i16<-16>

Combining: t38: i16 = Constant<-16>

Combining: t42: i16 = add t41, Constant:i16<-16>

Combining: t41: i16 = add t39, t4

Combining: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16

Combining: t39: i16 = shl t37, Constant:i16<3>

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.29 'main:'
SelectionDAG has 19 nodes:
  t0: ch,glue = EntryToken
                t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
              t39: i16 = shl t37, Constant:i16<3>
              t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
            t41: i16 = add t39, t4
          t42: i16 = add t41, Constant:i16<-16>
        t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
      t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
    t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t27, BasicBlock:ch< 0x16b38284240>



Legalizing node: t38: i16 = Constant<-16>
Analyzing result type: i16
Legal result type
Legally typed node: t38: i16 = Constant<-16>

Legalizing node: t25: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t25: ch = seteq

Legalizing node: t23: ch = BasicBlock< 0x16b38284240>
Analyzing result type: ch
Legal result type
Legally typed node: t23: ch = BasicBlock< 0x16b38284240>

Legalizing node: t21: ch = BasicBlock< 0x16b38284388>
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = BasicBlock< 0x16b38284388>

Legalizing node: t16: i32 = Constant<0>
Analyzing result type: i32
Expand integer result: t16: i32 = Constant<0>
Creating constant: t43: i16 = Constant<0>

Legalizing node: t43: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t43: i16 = Constant<0>

Legalizing node: t11: i16 = Constant<3>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = Constant<3>

Legalizing node: t5: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = FrameIndex<1>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = GlobalAddress<ptr @stack> 0
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = GlobalAddress<ptr @stack> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing node: t39: i16 = shl t37, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t11: i16 = Constant<3>
Legal operand
Legally typed node: t39: i16 = shl t37, Constant:i16<3>

Legalizing node: t41: i16 = add t39, t4
Analyzing result type: i16
Legal result type
Analyzing operand: t39: i16 = shl t37, Constant:i16<3>
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Legally typed node: t41: i16 = add t39, t4

Legalizing node: t42: i16 = add t41, Constant:i16<-16>
Analyzing result type: i16
Legal result type
Analyzing operand: t41: i16 = add t39, t4
Legal operand
Analyzing operand: t38: i16 = Constant<-16>
Legal operand
Legally typed node: t42: i16 = add t41, Constant:i16<-16>

Legalizing node: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Analyzing result type: i32
Expand integer result: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Creating new node: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Creating constant: t45: i16 = Constant<15>
Creating new node: t46: i16 = sra t44, Constant:i16<15>

Legalizing node: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Analyzing result type: i1
Promote integer result: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Creating new node: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch

Legalizing node: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Promote integer operand: t27: ch = brcond t0, t26, BasicBlock:ch< 0x16b38284388>
Creating new node: t48: i16 = any_extend t26

Legalizing node: t48: i16 = any_extend t26
Analyzing result type: i16
Legal result type
Analyzing operand: t26: i1 = setcc t28, Constant:i32<0>, seteq:ch
Promote integer operand: t48: i16 = any_extend t26
Replacing: t48: i16 = any_extend t26
     with: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch

Legalizing node: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t28: i32,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Expand integer operand: t47: i16 = setcc t28, Constant:i32<0>, seteq:ch
Creating new node: t49: i16 = or t44, t46

Legalizing node: t45: i16 = Constant<15>
Analyzing result type: i16
Legal result type
Legally typed node: t45: i16 = Constant<15>

Legalizing node: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t42: i16 = add t41, Constant:i16<-16>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16

Legalizing node: t46: i16 = sra t44, Constant:i16<15>
Analyzing result type: i16
Legal result type
Analyzing operand: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Legal operand
Analyzing operand: t45: i16 = Constant<15>
Legal operand
Legally typed node: t46: i16 = sra t44, Constant:i16<15>

Legalizing node: t49: i16 = or t44, t46
Analyzing result type: i16
Legal result type
Analyzing operand: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Legal operand
Analyzing operand: t46: i16 = sra t44, Constant:i16<15>
Legal operand
Legally typed node: t49: i16 = or t44, t46

Legalizing node: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch
Analyzing result type: i16
Legal result type
Analyzing operand: t49: i16 = or t44, t46
Legal operand
Analyzing operand: t43: i16 = Constant<0>
Legal operand
Analyzing operand: t25: ch = seteq
Legal operand
Legally typed node: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch

Legalizing node: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch
Legal operand
Analyzing operand: t21: ch = BasicBlock< 0x16b38284388>
Legal operand
Legally typed node: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>

Legalizing node: t24: ch = br t27, BasicBlock:ch< 0x16b38284240>
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
Legal operand
Analyzing operand: t23: ch = BasicBlock< 0x16b38284240>
Legal operand
Legally typed node: t24: ch = br t27, BasicBlock:ch< 0x16b38284240>

Legalizing node: t65535: ch = handlenode t24
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = br t27, BasicBlock:ch< 0x16b38284240>
Legal operand
Legally typed node: t65535: ch = handlenode t24

Type-legalized selection DAG: %bb.29 'main:'
SelectionDAG has 22 nodes:
  t0: ch,glue = EntryToken
          t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
        t39: i16 = shl t37, Constant:i16<3>
        t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t41: i16 = add t39, t4
    t42: i16 = add t41, Constant:i16<-16>
  t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
          t46: i16 = sra t44, Constant:i16<15>
        t49: i16 = or t44, t46
      t47: i16 = setcc t49, Constant:i16<0>, seteq:ch
    t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t27, BasicBlock:ch< 0x16b38284240>



Combining: t49: i16 = or t44, t46

Combining: t47: i16 = setcc t49, Constant:i16<0>, seteq:ch

Combining: t46: i16 = sra t44, Constant:i16<15>

Combining: t45: i16 = Constant<15>

Combining: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16

Combining: t43: i16 = Constant<0>

Combining: t42: i16 = add t41, Constant:i16<-16>

Combining: t41: i16 = add t39, t4

Combining: t39: i16 = shl t37, Constant:i16<3>

Combining: t38: i16 = Constant<-16>

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t27: ch = brcond t0, t47, BasicBlock:ch< 0x16b38284388>
Creating new node: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
 ... into: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>

Combining: t49: i16 = or t44, t46

Combining: t43: i16 = Constant<0>

Combining: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>

Combining: t25: ch = seteq

Combining: t24: ch = br t50, BasicBlock:ch< 0x16b38284240>

Combining: t23: ch = BasicBlock< 0x16b38284240>

Combining: t21: ch = BasicBlock< 0x16b38284388>

Combining: t11: i16 = Constant<3>

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.29 'main:'
SelectionDAG has 21 nodes:
  t0: ch,glue = EntryToken
          t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
        t39: i16 = shl t37, Constant:i16<3>
        t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t41: i16 = add t39, t4
    t42: i16 = add t41, Constant:i16<-16>
  t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
        t46: i16 = sra t44, Constant:i16<15>
      t49: i16 = or t44, t46
    t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
  t24: ch = br t50, BasicBlock:ch< 0x16b38284240>



Legalizing: t24: ch = br t50, BasicBlock:ch< 0x16b38284240>
Legal node: nothing to do

Legalizing: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
Trying custom legalization
Creating new node: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Creating constant: t52: i16 = Constant<1>
Creating new node: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Successfully custom legalized node
 ... replacing: t50: ch = br_cc t0, seteq:ch, t49, Constant:i16<0>, BasicBlock:ch< 0x16b38284388>
     with:      t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51

Legalizing: t49: i16 = or t44, t46
Legal node: nothing to do

Legalizing: t46: i16 = sra t44, Constant:i16<15>
Legal node: nothing to do

Legalizing: t44: i16,ch = load<(load (s8) from %ir.116, align 4), sext from i8> t0, t42, undef:i16
Legalizing extending load operation
Creating new node: t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16
Creating new node: t56: i16 = sign_extend_inreg t54, ValueType:ch:i8

Legalizing: t42: i16 = add t41, Constant:i16<-16>
Legal node: nothing to do

Legalizing: t41: i16 = add t39, t4
Legal node: nothing to do

Legalizing: t39: i16 = shl t37, Constant:i16<3>
Legal node: nothing to do

Legalizing: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t45: i16 = Constant<15>
Legal node: nothing to do

Legalizing: t43: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t38: i16 = Constant<-16>
Legal node: nothing to do

Legalizing: t23: ch = BasicBlock< 0x16b38284240>
Legal node: nothing to do

Legalizing: t21: ch = BasicBlock< 0x16b38284388>
Legal node: nothing to do

Legalizing: t11: i16 = Constant<3>
Legal node: nothing to do

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = GlobalAddress<ptr @stack> 0
Trying custom legalization
Successfully custom legalized node
 ... replacing: t1: i16 = GlobalAddress<ptr @stack> 0
     with:      t57: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t57: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Legalizing: t56: i16 = sign_extend_inreg t54, ValueType:ch:i8
Trying to expand node
Creating constant: t58: i16 = Constant<8>
Creating new node: t59: i16 = shl t54, Constant:i16<8>
Creating new node: t60: i16 = sra t59, Constant:i16<8>
Successfully expanded node
 ... replacing: t56: i16 = sign_extend_inreg t54, ValueType:ch:i8
     with:      t60: i16 = sra t59, Constant:i16<8>

Legalizing: t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16
Legalizing extending load operation

Legalizing: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Legal node: nothing to do

Legalizing: t52: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Legal node: nothing to do

Legalizing: t60: i16 = sra t59, Constant:i16<8>
Legal node: nothing to do

Legalizing: t59: i16 = shl t54, Constant:i16<8>
Legal node: nothing to do

Legalizing: t58: i16 = Constant<8>
Legal node: nothing to do

Legalized selection DAG: %bb.29 'main:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
              t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
            t39: i16 = shl t37, Constant:i16<3>
            t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
          t41: i16 = add t39, t4
        t42: i16 = add t41, Constant:i16<-16>
      t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16
    t59: i16 = shl t54, Constant:i16<8>
  t60: i16 = sra t59, Constant:i16<8>
          t46: i16 = sra t60, Constant:i16<15>
        t49: i16 = or t60, t46
      t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
    t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
  t24: ch = br t53, BasicBlock:ch< 0x16b38284240>



Legalizing: t60: i16 = sra t59, Constant:i16<8>
Legal node: nothing to do

Combining: t60: i16 = sra t59, Constant:i16<8>

Legalizing: t59: i16 = shl t54, Constant:i16<8>
Legal node: nothing to do

Combining: t59: i16 = shl t54, Constant:i16<8>

Legalizing: t58: i16 = Constant<8>
Legal node: nothing to do

Combining: t58: i16 = Constant<8>

Legalizing: t57: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Combining: t57: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16
Legalizing extending load operation

Combining: t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16

Legalizing: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Legal node: nothing to do

Combining: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51

Legalizing: t52: i16 = Constant<1>
Legal node: nothing to do

Combining: t52: i16 = Constant<1>

Legalizing: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Legal node: nothing to do

Combining: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>

Legalizing: t24: ch = br t53, BasicBlock:ch< 0x16b38284240>
Legal node: nothing to do

Combining: t24: ch = br t53, BasicBlock:ch< 0x16b38284240>

Legalizing: t49: i16 = or t60, t46
Legal node: nothing to do

Combining: t49: i16 = or t60, t46

Legalizing: t46: i16 = sra t60, Constant:i16<15>
Legal node: nothing to do

Combining: t46: i16 = sra t60, Constant:i16<15>
Creating new node: t61: i16 = sra t59, Constant:i16<15>
 ... into: t61: i16 = sra t59, Constant:i16<15>

Legalizing: t60: i16 = sra t59, Constant:i16<8>
Legal node: nothing to do

Combining: t60: i16 = sra t59, Constant:i16<8>

Legalizing: t61: i16 = sra t59, Constant:i16<15>
Legal node: nothing to do

Combining: t61: i16 = sra t59, Constant:i16<15>

Legalizing: t49: i16 = or t60, t61
Legal node: nothing to do

Combining: t49: i16 = or t60, t61

Legalizing: t42: i16 = add t41, Constant:i16<-16>
Legal node: nothing to do

Combining: t42: i16 = add t41, Constant:i16<-16>

Legalizing: t41: i16 = add t39, t4
Legal node: nothing to do

Combining: t41: i16 = add t39, t4

Legalizing: t39: i16 = shl t37, Constant:i16<3>
Legal node: nothing to do

Combining: t39: i16 = shl t37, Constant:i16<3>

Legalizing: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t45: i16 = Constant<15>
Legal node: nothing to do

Combining: t45: i16 = Constant<15>

Legalizing: t43: i16 = Constant<0>
Legal node: nothing to do

Combining: t43: i16 = Constant<0>

Legalizing: t38: i16 = Constant<-16>
Legal node: nothing to do

Combining: t38: i16 = Constant<-16>

Legalizing: t23: ch = BasicBlock< 0x16b38284240>
Legal node: nothing to do

Combining: t23: ch = BasicBlock< 0x16b38284240>

Legalizing: t21: ch = BasicBlock< 0x16b38284388>
Legal node: nothing to do

Combining: t21: ch = BasicBlock< 0x16b38284388>

Legalizing: t11: i16 = Constant<3>
Legal node: nothing to do

Combining: t11: i16 = Constant<3>

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i16 = FrameIndex<1>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.29 'main:'
SelectionDAG has 25 nodes:
  t0: ch,glue = EntryToken
            t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
          t39: i16 = shl t37, Constant:i16<3>
          t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
        t41: i16 = add t39, t4
      t42: i16 = add t41, Constant:i16<-16>
    t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16
  t59: i16 = shl t54, Constant:i16<8>
          t60: i16 = sra t59, Constant:i16<8>
          t61: i16 = sra t59, Constant:i16<15>
        t49: i16 = or t60, t61
      t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
    t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
  t24: ch = br t53, BasicBlock:ch< 0x16b38284240>


===== Instruction selection begins: %bb.29 ''

ISEL: Starting selection on root node: t24: ch = br t53, BasicBlock:ch< 0x16b38284240>
Selecting: t24: ch = br t53, BasicBlock:ch< 0x16b38284240>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t24: ch = JMPI BasicBlock:ch< 0x16b38284240>, t53
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51
Selecting: t53: ch = SymphonyISD::BR_CC t0, BasicBlock:ch< 0x16b38284388>, Constant:i16<1>, t51

ISEL: Starting pattern match
  Initial Opcode index to 413
  Morphed node: t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51
ISEL: Match complete!

ISEL: Starting selection on root node: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>
Selecting: t51: glue = SymphonyISD::CMP t49, Constant:i16<0>

ISEL: Starting pattern match
  Initial Opcode index to 826
Creating constant: t62: i16 = TargetConstant<0>
  Morphed node: t51: i16,glue = CMPI t49, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t49: i16 = or t60, t61
Selecting: t49: i16 = or t60, t61

ISEL: Starting pattern match
  Initial Opcode index to 526
  Match failed at index 531
  Continuing at 544
  Morphed node: t49: i16 = ORR t60, t61
ISEL: Match complete!

ISEL: Starting selection on root node: t60: i16 = sra t59, Constant:i16<8>
Selecting: t60: i16 = sra t59, Constant:i16<8>

ISEL: Starting pattern match
  Initial Opcode index to 766
Creating constant: t63: i16 = TargetConstant<8>
  Morphed node: t60: i16 = ASRI t59, TargetConstant:i16<8>
ISEL: Match complete!

ISEL: Starting selection on root node: t61: i16 = sra t59, Constant:i16<15>
Selecting: t61: i16 = sra t59, Constant:i16<15>

ISEL: Starting pattern match
  Initial Opcode index to 766
Creating constant: t64: i16 = TargetConstant<15>
  Morphed node: t61: i16 = ASRI t59, TargetConstant:i16<15>
ISEL: Match complete!

ISEL: Starting selection on root node: t59: i16 = shl t54, Constant:i16<8>
Selecting: t59: i16 = shl t54, Constant:i16<8>

ISEL: Starting pattern match
  Initial Opcode index to 646
  Morphed node: t59: i16 = LSLI t54, TargetConstant:i16<8>
ISEL: Match complete!

ISEL: Starting selection on root node: t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16
Selecting: t54: i16,ch = load<(load (s8) from %ir.116, align 4), anyext from i8> t0, t42, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Morphed node: t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.116, align 4)> t42, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t42: i16 = add t41, Constant:i16<-16>
Selecting: t42: i16 = add t41, Constant:i16<-16>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t65: i16 = TargetConstant<-16>
  Morphed node: t42: i16 = ADDI t41, TargetConstant:i16<-16>
ISEL: Match complete!

ISEL: Starting selection on root node: t41: i16 = add t39, t4
Selecting: t41: i16 = add t39, t4

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t41: i16 = ADDR t39, t4
ISEL: Match complete!

ISEL: Starting selection on root node: t39: i16 = shl t37, Constant:i16<3>
Selecting: t39: i16 = shl t37, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
Creating constant: t66: i16 = TargetConstant<3>
  Morphed node: t39: i16 = LSLI t37, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Selecting: t37: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t57: i16 = TargetGlobalAddress<ptr @stack> 0
Selecting: t57: i16 = TargetGlobalAddress<ptr @stack> 0


ISEL: Starting selection on root node: t23: ch = BasicBlock< 0x16b38284240>
Selecting: t23: ch = BasicBlock< 0x16b38284240>


ISEL: Starting selection on root node: t21: ch = BasicBlock< 0x16b38284388>
Selecting: t21: ch = BasicBlock< 0x16b38284388>


ISEL: Starting selection on root node: t5: i16 = FrameIndex<1>
Selecting: t5: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.29 'main:'
SelectionDAG has 24 nodes:
  t0: ch,glue = EntryToken
              t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
            t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0
          t39: i16 = LSLI t37, TargetConstant:i16<3>
          t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
        t41: i16 = ADDR t39, t4
      t42: i16 = ADDI t41, TargetConstant:i16<-16>
    t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.116, align 4)> t42, t0
  t59: i16 = LSLI t54, TargetConstant:i16<8>
          t60: i16 = ASRI t59, TargetConstant:i16<8>
          t61: i16 = ASRI t59, TargetConstant:i16<15>
        t49: i16 = ORR t60, t61
      t51: i16,glue = CMPI t49, TargetConstant:i16<0>
    t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1
  t24: ch = JMPI BasicBlock:ch< 0x16b38284240>, t53


********** List Scheduling %bb.29 '' **********
SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38284240>, t53

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t49: i16 = ORR t60, t61

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
    SU(12): Data Latency=1
SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.116, align 4)> t42, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t41: i16 = ADDR t39, t4

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(6): Data Latency=1
SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(7): Data Latency=1
SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(9): Data Latency=1
SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(10): Data Latency=1
SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38284240>, t53


*** Scheduling [0]: SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38284240>, t53


Examining Available:
Height 1: SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>


*** Scheduling [1]: SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t49: i16 = ORR t60, t61


*** Scheduling [2]: SU(2): t49: i16 = ORR t60, t61


Examining Available:
Height 3: SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>

Height 3: SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>


*** Scheduling [3]: SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>


Examining Available:
Height 3: SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>


*** Scheduling [4]: SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>


Examining Available:
Height 5: SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>


*** Scheduling [5]: SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>


Examining Available:
Height 6: SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.116, align 4)> t42, t0


*** Scheduling [6]: SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.116, align 4)> t42, t0


Examining Available:
Height 7: SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>


*** Scheduling [7]: SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>


Examining Available:
Height 8: SU(7): t41: i16 = ADDR t39, t4


*** Scheduling [8]: SU(7): t41: i16 = ADDR t39, t4


Examining Available:
Height 9: SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>

Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [9]: SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>


Examining Available:
Height 10: SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [10]: SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0


Examining Available:
Height 11: SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [11]: SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 9: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [12]: SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

*** Final schedule ***
SU(8): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(10): t37: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

SU(9): t39: i16 = LSLI t37, TargetConstant:i16<3>

SU(7): t41: i16 = ADDR t39, t4

SU(6): t42: i16 = ADDI t41, TargetConstant:i16<-16>

SU(5): t54: i16,ch = LOAD8R<Mem:(load (s8) from %ir.116, align 4)> t42, t0

SU(4): t59: i16 = LSLI t54, TargetConstant:i16<8>

SU(3): t61: i16 = ASRI t59, TargetConstant:i16<15>

SU(12): t60: i16 = ASRI t59, TargetConstant:i16<8>

SU(2): t49: i16 = ORR t60, t61

SU(1): t53: ch = JEI BasicBlock:ch< 0x16b38284388>, t0, t51:1

    t51: i16,glue = CMPI t49, TargetConstant:i16<0>

SU(0): t24: ch = JMPI BasicBlock:ch< 0x16b38284240>, t53


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Creating new node: t7: i32 = zero_extend t6
Creating constant: t8: i16 = Constant<3>
Creating new node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Creating new node: t10: i16 = add nuw t4, t9
Creating constant: t11: i16 = Constant<4>
Creating new node: t12: i16 = add nuw t10, Constant:i16<4>
Creating new node: t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
Creating constant: t14: i32 = Constant<2>
Creating new node: t15: i32 = sub nsw t7, Constant:i32<2>
Creating new node: t16: i16 = truncate t15
Creating new node: t17: i16 = shl nsw t16, Constant:i16<3>
Creating new node: t18: i16 = add t4, t17
Creating new node: t19: i16 = add nuw t18, Constant:i16<4>
Creating new node: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t19, undef:i16
Creating constant: t21: i32 = Constant<1>
Creating new node: t22: i32 = sub nsw t7, Constant:i32<1>
Creating new node: t23: i16 = truncate t22
Creating new node: t24: i16 = shl nsw t23, Constant:i16<3>
Creating new node: t25: i16 = add t4, t24
Creating new node: t26: i16 = add nuw t25, Constant:i16<4>
Creating new node: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t26, undef:i16
Creating new node: t29: ch = TokenFactor t4:1, t6:1, t13:1, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Creating constant: t30: i16 = Constant<1>
Creating new node: t31: i16 = extract_element t13, Constant:i16<1>
Creating new node: t32: i16 = extract_element t13, Constant:i16<0>
Creating new node: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t31
Creating new node: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t32, t35:1
Creating new node: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Creating new node: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
Creating new node: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Creating new node: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Creating new node: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
Creating new node: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Creating new node: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
Creating new node: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Creating new node: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Creating new node: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t54: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Creating new node: t55: i32 = zero_extend t54
Creating new node: t56: i32 = sub nsw t55, Constant:i32<2>
Creating new node: t57: i16 = truncate t56
Creating new node: t58: i16 = shl nsw t57, Constant:i16<3>
Creating new node: t59: i16 = add t53, t58
Creating new node: t60: i16 = add nuw t59, Constant:i16<4>
Creating new node: t61: ch = TokenFactor t52:1, t53:1, t54:1
Creating new node: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t60, undef:i16
Creating new node: t63: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Creating new node: t64: i32 = zero_extend t63
Creating new node: t65: i32 = sub nsw t64, Constant:i32<2>
Creating new node: t66: i16 = truncate t65
Creating new node: t67: ch = store<(store (s16) into %ir.2)> t63:1, t66, FrameIndex:i16<1>, undef:i16
Creating new node: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>

Initial selection DAG: %bb.30 'main:'
SelectionDAG has 70 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t7: i32 = zero_extend t6
        t9: i16 = shl nuw nsw t6, Constant:i16<3>
      t10: i16 = add nuw t4, t9
    t12: i16 = add nuw t10, Constant:i16<4>
  t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
            t15: i32 = sub nsw t7, Constant:i32<2>
          t16: i16 = truncate t15
        t17: i16 = shl nsw t16, Constant:i16<3>
      t18: i16 = add t4, t17
    t19: i16 = add nuw t18, Constant:i16<4>
  t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t19, undef:i16
            t22: i32 = sub nsw t7, Constant:i32<1>
          t23: i16 = truncate t22
        t24: i16 = shl nsw t23, Constant:i16<3>
      t25: i16 = add t4, t24
    t26: i16 = add nuw t25, Constant:i16<4>
  t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t26, undef:i16
  t28: i16 = GlobalAddress<ptr @do_calc> 0
  t29: ch = TokenFactor t4:1, t6:1, t13:1, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
    t31: i16 = extract_element t13, Constant:i16<1>
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t31
    t32: i16 = extract_element t13, Constant:i16<0>
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t32, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
  t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
  t48: i16 = GlobalAddress<ptr @output> 0
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
  t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
  t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t54: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
      t61: ch = TokenFactor t52:1, t53:1, t54:1
                t55: i32 = zero_extend t54
              t56: i32 = sub nsw t55, Constant:i32<2>
            t57: i16 = truncate t56
          t58: i16 = shl nsw t57, Constant:i16<3>
        t59: i16 = add t53, t58
      t60: i16 = add nuw t59, Constant:i16<4>
    t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t60, undef:i16
  t63: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
          t64: i32 = zero_extend t63
        t65: i32 = sub nsw t64, Constant:i32<2>
      t66: i16 = truncate t65
    t67: ch = store<(store (s16) into %ir.2)> t63:1, t66, FrameIndex:i16<1>, undef:i16
  t69: ch = br t67, BasicBlock:ch< 0x16b38284388>



Combining: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>

Combining: t68: ch = BasicBlock< 0x16b38284388>

Combining: t67: ch = store<(store (s16) into %ir.2)> t63:1, t66, FrameIndex:i16<1>, undef:i16

Combining: t66: i16 = truncate t65
Creating new node: t70: i32 = any_extend t63

Replacing.2 t64: i32 = zero_extend t63

With: t70: i32 = any_extend t63


Combining: t70: i32 = any_extend t63
Creating new node: t71: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t62, FrameIndex:i16<1>, undef:i16

Replacing.1 t70: i32 = any_extend t63

With: t71: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t62, FrameIndex:i16<1>, undef:i16
 and 0 other values

Combining: t71: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t62, FrameIndex:i16<1>, undef:i16

Combining: t66: i16 = truncate t65
Creating new node: t72: i16 = truncate t71
Creating constant: t73: i16 = Constant<2>
Creating new node: t74: i16 = sub t72, Constant:i16<2>
 ... into: t74: i16 = sub t72, Constant:i16<2>

Combining: t71: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t62, FrameIndex:i16<1>, undef:i16

Combining: t74: i16 = sub t72, Constant:i16<2>
Creating constant: t75: i16 = Constant<-2>
Creating new node: t76: i16 = add t72, Constant:i16<-2>
 ... into: t76: i16 = add t72, Constant:i16<-2>

Combining: t76: i16 = add t72, Constant:i16<-2>

Combining: t75: i16 = Constant<-2>

Combining: t72: i16 = truncate t71
Creating new node: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
 ... into: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16

Combining: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16

Combining: t76: i16 = add t77, Constant:i16<-2>

Combining: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16

Combining: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t60, undef:i16

Combining: t61: ch = TokenFactor t52:1, t53:1, t54:1

Combining: t60: i16 = add nuw t59, Constant:i16<4>
Creating new node: t78: i32 = any_extend t54

Replacing.2 t55: i32 = zero_extend t54

With: t78: i32 = any_extend t54


Combining: t78: i32 = any_extend t54
Creating new node: t79: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t51, FrameIndex:i16<1>, undef:i16

Replacing.1 t78: i32 = any_extend t54

With: t79: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t51, FrameIndex:i16<1>, undef:i16
 and 0 other values

Combining: t79: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t51, FrameIndex:i16<1>, undef:i16

Combining: t60: i16 = add t59, Constant:i16<4>

Combining: t59: i16 = add t53, t58

Combining: t58: i16 = shl t57, Constant:i16<3>

Combining: t57: i16 = truncate t56
Creating new node: t80: i16 = truncate t79
Creating constant: t81: i16 = Constant<2>
Creating new node: t82: i16 = sub t80, Constant:i16<2>
 ... into: t82: i16 = sub t80, Constant:i16<2>

Combining: t79: i32,ch = load<(dereferenceable load (s16) from %ir.2), anyext from i16> t51, FrameIndex:i16<1>, undef:i16

Combining: t82: i16 = sub t80, Constant:i16<2>
Creating new node: t83: i16 = add t80, Constant:i16<-2>
 ... into: t83: i16 = add t80, Constant:i16<-2>

Combining: t83: i16 = add t80, Constant:i16<-2>

Combining: t80: i16 = truncate t79
Creating new node: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
 ... into: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

Combining: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

Combining: t61: ch = TokenFactor t52:1, t53:1, t84:1

Combining: t83: i16 = add t84, Constant:i16<-2>

Combining: t58: i16 = shl t83, Constant:i16<3>
Creating constant: t85: i16 = Constant<-16>
Creating new node: t86: i16 = shl t84, Constant:i16<3>
Creating new node: t87: i16 = add t86, Constant:i16<-16>
 ... into: t87: i16 = add t86, Constant:i16<-16>

Combining: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

Combining: t75: i16 = Constant<-2>

Combining: t87: i16 = add t86, Constant:i16<-16>

Combining: t85: i16 = Constant<-16>

Combining: t59: i16 = add t53, t87
Creating new node: t88: i16 = add t86, t53
Creating new node: t89: i16 = add t88, Constant:i16<-16>
 ... into: t89: i16 = add t88, Constant:i16<-16>

Combining: t85: i16 = Constant<-16>

Combining: t89: i16 = add t88, Constant:i16<-16>

Combining: t88: i16 = add t86, t53

Combining: t60: i16 = add t89, Constant:i16<4>
Creating constant: t90: i16 = Constant<-12>
Creating new node: t91: i16 = add t88, Constant:i16<-12>
 ... into: t91: i16 = add t88, Constant:i16<-12>

Combining: t88: i16 = add t86, t53

Combining: t91: i16 = add t88, Constant:i16<-12>

Combining: t90: i16 = Constant<-12>

Combining: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16

Combining: t86: i16 = shl t84, Constant:i16<3>

Combining: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16

Combining: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1

Combining: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47

Combining: t49: i16 = TargetGlobalAddress<ptr @output> 0

Combining: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16

Combining: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16

Combining: t45: i16 = FrameIndex<5>

Combining: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

Combining: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

Combining: t40: i16 = Register $r4

Combining: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

Combining: t38: i16 = Register $r3

Combining: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t32, t35:1

Combining: t36: i16 = Register $r2

Combining: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t31

Combining: t34: i16 = Register $r1

Combining: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0

Combining: t32: i16 = extract_element t13, Constant:i16<0>

Combining: t31: i16 = extract_element t13, Constant:i16<1>

Combining: t30: i16 = Constant<1>

Combining: t29: ch = TokenFactor t4:1, t6:1, t13:1, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1

Combining: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t26, undef:i16

Combining: t26: i16 = add nuw t25, Constant:i16<4>

Combining: t25: i16 = add t4, t24

Combining: t24: i16 = shl nsw t23, Constant:i16<3>

Combining: t23: i16 = truncate t22
Creating new node: t92: i16 = sub t6, Constant:i16<1>
 ... into: t92: i16 = sub t6, Constant:i16<1>

Combining: t92: i16 = sub t6, Constant:i16<1>
Creating constant: t93: i16 = Constant<-1>
Creating new node: t94: i16 = add t6, Constant:i16<-1>
 ... into: t94: i16 = add t6, Constant:i16<-1>

Combining: t30: i16 = Constant<1>

Combining: t94: i16 = add t6, Constant:i16<-1>

Combining: t93: i16 = Constant<-1>

Combining: t24: i16 = shl nsw t94, Constant:i16<3>
Creating constant: t95: i16 = Constant<-8>
Creating new node: t96: i16 = add t9, Constant:i16<-8>
 ... into: t96: i16 = add t9, Constant:i16<-8>

Combining: t96: i16 = add t9, Constant:i16<-8>

Combining: t95: i16 = Constant<-8>

Combining: t25: i16 = add t4, t96
Creating new node: t97: i16 = add t9, t4
Creating new node: t98: i16 = add t97, Constant:i16<-8>
 ... into: t98: i16 = add t97, Constant:i16<-8>

Combining: t95: i16 = Constant<-8>

Combining: t98: i16 = add t97, Constant:i16<-8>

Combining: t97: i16 = add t9, t4
 ... into: t10: i16 = add t4, t9

Combining: t98: i16 = add t10, Constant:i16<-8>

Combining: t26: i16 = add nuw t98, Constant:i16<4>
Creating constant: t99: i16 = Constant<-4>
Creating new node: t100: i16 = add t10, Constant:i16<-4>
 ... into: t100: i16 = add t10, Constant:i16<-4>

Combining: t100: i16 = add t10, Constant:i16<-4>

Combining: t99: i16 = Constant<-4>

Combining: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16

Combining: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t19, undef:i16

Combining: t19: i16 = add nuw t18, Constant:i16<4>
Creating new node: t101: i32 = any_extend t6

Replacing.2 t7: i32 = zero_extend t6

With: t101: i32 = any_extend t6


Combining: t101: i32 = any_extend t6

Combining: t19: i16 = add t18, Constant:i16<4>

Combining: t18: i16 = add t4, t17

Combining: t17: i16 = shl t16, Constant:i16<3>

Combining: t16: i16 = truncate t15
Creating constant: t102: i16 = Constant<2>
Creating new node: t103: i16 = sub t6, Constant:i16<2>
 ... into: t103: i16 = sub t6, Constant:i16<2>

Combining: t103: i16 = sub t6, Constant:i16<2>
Creating new node: t104: i16 = add t6, Constant:i16<-2>
 ... into: t104: i16 = add t6, Constant:i16<-2>

Combining: t104: i16 = add t6, Constant:i16<-2>

Combining: t17: i16 = shl t104, Constant:i16<3>
Creating constant: t105: i16 = Constant<-16>
Creating new node: t106: i16 = add t9, Constant:i16<-16>
 ... into: t106: i16 = add t9, Constant:i16<-16>

Combining: t75: i16 = Constant<-2>

Combining: t106: i16 = add t9, Constant:i16<-16>

Combining: t105: i16 = Constant<-16>

Combining: t18: i16 = add t4, t106
Creating new node: t107: i16 = add t9, t4
Creating new node: t108: i16 = add t107, Constant:i16<-16>
 ... into: t108: i16 = add t107, Constant:i16<-16>

Combining: t105: i16 = Constant<-16>

Combining: t108: i16 = add t107, Constant:i16<-16>

Combining: t107: i16 = add t9, t4
 ... into: t10: i16 = add t4, t9

Combining: t100: i16 = add t10, Constant:i16<-4>

Combining: t108: i16 = add t10, Constant:i16<-16>

Combining: t19: i16 = add t108, Constant:i16<4>
Creating new node: t109: i16 = add t10, Constant:i16<-12>
 ... into: t109: i16 = add t10, Constant:i16<-12>

Combining: t109: i16 = add t10, Constant:i16<-12>

Combining: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16

Combining: t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16

Combining: t12: i16 = add nuw t10, Constant:i16<4>

Combining: t11: i16 = Constant<4>

Combining: t10: i16 = add t4, t9

Combining: t9: i16 = shl t6, Constant:i16<3>

Combining: t8: i16 = Constant<3>

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t2: i16 = Constant<0>

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.30 'main:'
SelectionDAG has 55 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t9: i16 = shl t6, Constant:i16<3>
  t10: i16 = add t4, t9
    t12: i16 = add nuw t10, Constant:i16<4>
  t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
    t109: i16 = add t10, Constant:i16<-12>
  t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
    t100: i16 = add t10, Constant:i16<-4>
  t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
  t29: ch = TokenFactor t4:1, t6:1, t13:1, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
    t31: i16 = extract_element t13, Constant:i16<1>
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t31
    t32: i16 = extract_element t13, Constant:i16<0>
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t32, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
  t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
  t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
  t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t61: ch = TokenFactor t52:1, t53:1, t84:1
          t86: i16 = shl t84, Constant:i16<3>
        t88: i16 = add t86, t53
      t91: i16 = add t88, Constant:i16<-12>
    t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
  t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
  t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
      t76: i16 = add t77, Constant:i16<-2>
    t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
  t69: ch = br t67, BasicBlock:ch< 0x16b38284388>



Legalizing node: t99: i16 = Constant<-4>
Analyzing result type: i16
Legal result type
Legally typed node: t99: i16 = Constant<-4>

Legalizing node: t90: i16 = Constant<-12>
Analyzing result type: i16
Legal result type
Legally typed node: t90: i16 = Constant<-12>

Legalizing node: t75: i16 = Constant<-2>
Analyzing result type: i16
Legal result type
Legally typed node: t75: i16 = Constant<-2>

Legalizing node: t68: ch = BasicBlock< 0x16b38284388>
Analyzing result type: ch
Legal result type
Legally typed node: t68: ch = BasicBlock< 0x16b38284388>

Legalizing node: t49: i16 = TargetGlobalAddress<ptr @output> 0
Analyzing result type: i16
Legal result type
Legally typed node: t49: i16 = TargetGlobalAddress<ptr @output> 0

Legalizing node: t45: i16 = FrameIndex<5>
Analyzing result type: i16
Legal result type
Legally typed node: t45: i16 = FrameIndex<5>

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i16 = Register $r4
Ignoring node results
Legally typed node: t40: i16 = Register $r4

Legalizing node: t38: i16 = Register $r3
Ignoring node results
Legally typed node: t38: i16 = Register $r3

Legalizing node: t36: i16 = Register $r2
Ignoring node results
Legally typed node: t36: i16 = Register $r2

Legalizing node: t34: i16 = Register $r1
Ignoring node results
Legally typed node: t34: i16 = Register $r1

Legalizing node: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0
Analyzing result type: i16
Legal result type
Legally typed node: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0

Legalizing node: t30: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t30: i16 = Constant<1>

Legalizing node: t11: i16 = Constant<4>
Analyzing result type: i16
Legal result type
Legally typed node: t11: i16 = Constant<4>

Legalizing node: t8: i16 = Constant<3>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<3>

Legalizing node: t5: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = FrameIndex<1>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t2: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = Constant<0>

Legalizing node: t1: i16 = GlobalAddress<ptr @stack> 0
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = GlobalAddress<ptr @stack> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing node: t9: i16 = shl t6, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i16 = Constant<3>
Legal operand
Legally typed node: t9: i16 = shl t6, Constant:i16<3>

Legalizing node: t10: i16 = add t4, t9
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t9: i16 = shl t6, Constant:i16<3>
Legal operand
Legally typed node: t10: i16 = add t4, t9

Legalizing node: t12: i16 = add nuw t10, Constant:i16<4>
Analyzing result type: i16
Legal result type
Analyzing operand: t10: i16 = add t4, t9
Legal operand
Analyzing operand: t11: i16 = Constant<4>
Legal operand
Legally typed node: t12: i16 = add nuw t10, Constant:i16<4>

Legalizing node: t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
Analyzing result type: i32
Expand integer result: t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
Creating new node: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Creating constant: t111: i16 = Constant<2>
Creating new node: t112: i16 = add nuw t12, Constant:i16<2>
Creating new node: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16
Creating new node: t114: ch = TokenFactor t110:1, t113:1

Legalizing node: t31: i16 = extract_element t13, Constant:i16<1>
Analyzing result type: i16
Legal result type
Analyzing operand: t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
Expand integer operand: t31: i16 = extract_element t13, Constant:i16<1>

Legalizing node: t32: i16 = extract_element t13, Constant:i16<0>
Analyzing result type: i16
Legal result type
Analyzing operand: t13: i32,ch = load<(load (s32) from %ir.125)> t0, t12, undef:i16
Expand integer operand: t32: i16 = extract_element t13, Constant:i16<0>

Legalizing node: t111: i16 = Constant<2>
Analyzing result type: i16
Legal result type
Legally typed node: t111: i16 = Constant<2>

Legalizing node: t112: i16 = add nuw t12, Constant:i16<2>
Analyzing result type: i16
Legal result type
Analyzing operand: t12: i16 = add nuw t10, Constant:i16<4>
Legal operand
Analyzing operand: t111: i16 = Constant<2>
Legal operand
Legally typed node: t112: i16 = add nuw t12, Constant:i16<2>

Legalizing node: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t112: i16 = add nuw t12, Constant:i16<2>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16

Legalizing node: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t12: i16 = add nuw t10, Constant:i16<4>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16

Legalizing node: t114: ch = TokenFactor t110:1, t113:1
Analyzing result type: ch
Legal result type
Analyzing operand: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Legal operand
Analyzing operand: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16
Legal operand
Legally typed node: t114: ch = TokenFactor t110:1, t113:1

Legalizing node: t100: i16 = add t10, Constant:i16<-4>
Analyzing result type: i16
Legal result type
Analyzing operand: t10: i16 = add t4, t9
Legal operand
Analyzing operand: t99: i16 = Constant<-4>
Legal operand
Legally typed node: t100: i16 = add t10, Constant:i16<-4>

Legalizing node: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t100: i16 = add t10, Constant:i16<-4>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16

Legalizing node: t109: i16 = add t10, Constant:i16<-12>
Analyzing result type: i16
Legal result type
Analyzing operand: t10: i16 = add t4, t9
Legal operand
Analyzing operand: t90: i16 = Constant<-12>
Legal operand
Legally typed node: t109: i16 = add t10, Constant:i16<-12>

Legalizing node: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t109: i16 = add t10, Constant:i16<-12>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16

Legalizing node: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t114: ch = TokenFactor t110:1, t113:1
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
Legal operand
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
Legal operand
Legally typed node: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1

Legalizing node: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Legal operand
Analyzing operand: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Legal operand
Legally typed node: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

Legalizing node: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
Legal operand
Analyzing operand: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16
Legal operand
Analyzing operand: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
Legal operand
Legally typed node: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

Legalizing node: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
Legal operand
Analyzing operand: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
Legal operand
Analyzing operand: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
Legal operand
Legally typed node: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Legal operand
Analyzing operand: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
Legal operand
Analyzing operand: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

Legalizing node: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Legal operand
Analyzing operand: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
Legal operand
Legally typed node: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1

Legalizing node: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

Legalizing node: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Legal operand
Analyzing operand: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Legal operand
Analyzing operand: t45: i16 = FrameIndex<5>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16

Legalizing node: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
Legal operand
Analyzing operand: t45: i16 = FrameIndex<5>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16

Legalizing node: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Legal operand
Analyzing operand: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Legal operand
Legally typed node: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47

Legalizing node: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Legal operand
Analyzing operand: t49: i16 = TargetGlobalAddress<ptr @output> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
Legal operand
Legally typed node: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1

Legalizing node: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Legal operand
Analyzing operand: t45: i16 = FrameIndex<5>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16

Legalizing node: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

Legalizing node: t61: ch = TokenFactor t52:1, t53:1, t84:1
Analyzing result type: ch
Legal result type
Analyzing operand: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Legal operand
Analyzing operand: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t61: ch = TokenFactor t52:1, t53:1, t84:1

Legalizing node: t86: i16 = shl t84, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i16 = Constant<3>
Legal operand
Legally typed node: t86: i16 = shl t84, Constant:i16<3>

Legalizing node: t88: i16 = add t86, t53
Analyzing result type: i16
Legal result type
Analyzing operand: t86: i16 = shl t84, Constant:i16<3>
Legal operand
Analyzing operand: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Legally typed node: t88: i16 = add t86, t53

Legalizing node: t91: i16 = add t88, Constant:i16<-12>
Analyzing result type: i16
Legal result type
Analyzing operand: t88: i16 = add t86, t53
Legal operand
Analyzing operand: t90: i16 = Constant<-12>
Legal operand
Legally typed node: t91: i16 = add t88, Constant:i16<-12>

Legalizing node: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t61: ch = TokenFactor t52:1, t53:1, t84:1
Legal operand
Analyzing operand: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Legal operand
Analyzing operand: t91: i16 = add t88, Constant:i16<-12>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16

Legalizing node: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16

Legalizing node: t76: i16 = add t77, Constant:i16<-2>
Analyzing result type: i16
Legal result type
Analyzing operand: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t75: i16 = Constant<-2>
Legal operand
Legally typed node: t76: i16 = add t77, Constant:i16<-2>

Legalizing node: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t76: i16 = add t77, Constant:i16<-2>
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16

Legalizing node: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>
Analyzing result type: ch
Legal result type
Analyzing operand: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t68: ch = BasicBlock< 0x16b38284388>
Legal operand
Legally typed node: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>

Legalizing node: t65535: ch = handlenode t69
Analyzing result type: ch
Legal result type
Analyzing operand: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>
Legal operand
Legally typed node: t65535: ch = handlenode t69

Type-legalized selection DAG: %bb.30 'main:'
SelectionDAG has 55 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t9: i16 = shl t6, Constant:i16<3>
  t10: i16 = add t4, t9
  t12: i16 = add nuw t10, Constant:i16<4>
    t109: i16 = add t10, Constant:i16<-12>
  t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
    t100: i16 = add t10, Constant:i16<-4>
  t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
    t114: ch = TokenFactor t110:1, t113:1
  t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
  t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
  t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
  t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t61: ch = TokenFactor t52:1, t53:1, t84:1
          t86: i16 = shl t84, Constant:i16<3>
        t88: i16 = add t86, t53
      t91: i16 = add t88, Constant:i16<-12>
    t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
  t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
  t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
  t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
    t112: i16 = add nuw t12, Constant:i16<2>
  t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16
      t76: i16 = add t77, Constant:i16<-2>
    t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
  t69: ch = br t67, BasicBlock:ch< 0x16b38284388>



Combining: t114: ch = TokenFactor t110:1, t113:1

Combining: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t112, undef:i16

Combining: t112: i16 = add nuw t12, Constant:i16<2>
Creating constant: t115: i16 = Constant<6>
Creating new node: t116: i16 = add nuw t10, Constant:i16<6>
 ... into: t116: i16 = add nuw t10, Constant:i16<6>

Combining: t116: i16 = add nuw t10, Constant:i16<6>

Combining: t115: i16 = Constant<6>

Combining: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16

Combining: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16

Combining: t109: i16 = add t10, Constant:i16<-12>

Combining: t100: i16 = add t10, Constant:i16<-4>

Combining: t99: i16 = Constant<-4>

Combining: t91: i16 = add t88, Constant:i16<-12>

Combining: t90: i16 = Constant<-12>

Combining: t88: i16 = add t86, t53

Combining: t86: i16 = shl t84, Constant:i16<3>

Combining: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

Combining: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16

Combining: t76: i16 = add t77, Constant:i16<-2>

Combining: t75: i16 = Constant<-2>

Combining: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>

Combining: t68: ch = BasicBlock< 0x16b38284388>

Combining: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16

Combining: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16

Combining: t61: ch = TokenFactor t52:1, t53:1, t84:1

Combining: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16

Combining: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1

Combining: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47

Combining: t49: i16 = TargetGlobalAddress<ptr @output> 0

Combining: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16

Combining: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16

Combining: t45: i16 = FrameIndex<5>

Combining: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

Combining: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

Combining: t40: i16 = Register $r4

Combining: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

Combining: t38: i16 = Register $r3

Combining: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

Combining: t36: i16 = Register $r2

Combining: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

Combining: t34: i16 = Register $r1

Combining: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0

Combining: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1

Combining: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16

Combining: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16

Combining: t12: i16 = add nuw t10, Constant:i16<4>

Combining: t11: i16 = Constant<4>

Combining: t10: i16 = add t4, t9

Combining: t9: i16 = shl t6, Constant:i16<3>

Combining: t8: i16 = Constant<3>

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.30 'main:'
SelectionDAG has 55 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t9: i16 = shl t6, Constant:i16<3>
  t10: i16 = add t4, t9
    t109: i16 = add t10, Constant:i16<-12>
  t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
    t100: i16 = add t10, Constant:i16<-4>
  t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
    t114: ch = TokenFactor t110:1, t113:1
  t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
  t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
  t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
  t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
      t61: ch = TokenFactor t52:1, t53:1, t84:1
          t86: i16 = shl t84, Constant:i16<3>
        t88: i16 = add t86, t53
      t91: i16 = add t88, Constant:i16<-12>
    t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
  t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
  t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
    t12: i16 = add nuw t10, Constant:i16<4>
  t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
    t116: i16 = add nuw t10, Constant:i16<6>
  t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16
      t76: i16 = add t77, Constant:i16<-2>
    t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
  t69: ch = br t67, BasicBlock:ch< 0x16b38284388>



Legalizing: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>
Legal node: nothing to do

Legalizing: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t76: i16 = add t77, Constant:i16<-2>
Legal node: nothing to do

Legalizing: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t91: i16 = add t88, Constant:i16<-12>
Legal node: nothing to do

Legalizing: t88: i16 = add t86, t53
Legal node: nothing to do

Legalizing: t61: ch = TokenFactor t52:1, t53:1, t84:1
Legal node: nothing to do

Legalizing: t86: i16 = shl t84, Constant:i16<3>
Legal node: nothing to do

Legalizing: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Legalizing non-extending load operation

Legalizing: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Legal node: nothing to do

Legalizing: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
Legal node: nothing to do

Legalizing: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Legalizing non-extending load operation

Legalizing: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Legal node: nothing to do

Legalizing: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
Legal node: nothing to do

Legalizing: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Legal node: nothing to do

Legalizing: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
Legal node: nothing to do

Legalizing: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
Legal node: nothing to do

Legalizing: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Legal node: nothing to do

Legalizing: t114: ch = TokenFactor t110:1, t113:1
Legal node: nothing to do

Legalizing: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Legalizing non-extending load operation

Legalizing: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
Legalizing non-extending load operation

Legalizing: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
Legalizing non-extending load operation

Legalizing: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16
Legalizing non-extending load operation

Legalizing: t12: i16 = add nuw t10, Constant:i16<4>
Legal node: nothing to do

Legalizing: t100: i16 = add t10, Constant:i16<-4>
Legal node: nothing to do

Legalizing: t109: i16 = add t10, Constant:i16<-12>
Legal node: nothing to do

Legalizing: t116: i16 = add nuw t10, Constant:i16<6>
Legal node: nothing to do

Legalizing: t10: i16 = add t4, t9
Legal node: nothing to do

Legalizing: t9: i16 = shl t6, Constant:i16<3>
Legal node: nothing to do

Legalizing: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t115: i16 = Constant<6>
Legal node: nothing to do

Legalizing: t99: i16 = Constant<-4>
Legal node: nothing to do

Legalizing: t90: i16 = Constant<-12>
Legal node: nothing to do

Legalizing: t75: i16 = Constant<-2>
Legal node: nothing to do

Legalizing: t68: ch = BasicBlock< 0x16b38284388>
Legal node: nothing to do

Legalizing: t49: i16 = TargetGlobalAddress<ptr @output> 0
Legal node: nothing to do

Legalizing: t45: i16 = FrameIndex<5>
Legal node: nothing to do

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i16 = Register $r4

Legalizing: t38: i16 = Register $r3

Legalizing: t36: i16 = Register $r2

Legalizing: t34: i16 = Register $r1

Legalizing: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0
Legal node: nothing to do

Legalizing: t11: i16 = Constant<4>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<3>
Legal node: nothing to do

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = GlobalAddress<ptr @stack> 0
Trying custom legalization
Successfully custom legalized node
 ... replacing: t1: i16 = GlobalAddress<ptr @stack> 0
     with:      t117: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t117: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Legalized selection DAG: %bb.30 'main:'
SelectionDAG has 55 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t9: i16 = shl t6, Constant:i16<3>
  t10: i16 = add t4, t9
    t116: i16 = add nuw t10, Constant:i16<6>
  t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16
    t109: i16 = add t10, Constant:i16<-12>
  t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
    t100: i16 = add t10, Constant:i16<-4>
  t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
    t12: i16 = add nuw t10, Constant:i16<4>
  t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
    t114: ch = TokenFactor t110:1, t113:1
  t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
  t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
  t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
  t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
      t61: ch = TokenFactor t52:1, t53:1, t84:1
          t86: i16 = shl t84, Constant:i16<3>
        t88: i16 = add t86, t53
      t91: i16 = add t88, Constant:i16<-12>
    t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
  t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
      t76: i16 = add t77, Constant:i16<-2>
    t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
  t69: ch = br t67, BasicBlock:ch< 0x16b38284388>



Legalizing: t117: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Combining: t117: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>
Legal node: nothing to do

Combining: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>

Legalizing: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16

Legalizing: t76: i16 = add t77, Constant:i16<-2>
Legal node: nothing to do

Combining: t76: i16 = add t77, Constant:i16<-2>

Legalizing: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16

Legalizing: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16

Legalizing: t91: i16 = add t88, Constant:i16<-12>
Legal node: nothing to do

Combining: t91: i16 = add t88, Constant:i16<-12>

Legalizing: t88: i16 = add t86, t53
Legal node: nothing to do

Combining: t88: i16 = add t86, t53

Legalizing: t61: ch = TokenFactor t52:1, t53:1, t84:1
Legal node: nothing to do

Combining: t61: ch = TokenFactor t52:1, t53:1, t84:1

Legalizing: t86: i16 = shl t84, Constant:i16<3>
Legal node: nothing to do

Combining: t86: i16 = shl t84, Constant:i16<3>

Legalizing: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Legalizing non-extending load operation

Combining: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16

Legalizing: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

Legalizing: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Legal node: nothing to do

Combining: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1

Legalizing: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
Legal node: nothing to do

Combining: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47

Legalizing: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Legalizing non-extending load operation

Combining: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16

Legalizing: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16

Legalizing: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Legal node: nothing to do

Combining: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

Legalizing: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

Legalizing: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Legal node: nothing to do

Combining: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

Legalizing: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
Legal node: nothing to do

Combining: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

Legalizing: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
Legal node: nothing to do

Combining: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

Legalizing: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Legal node: nothing to do

Combining: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1

Legalizing: t114: ch = TokenFactor t110:1, t113:1
Legal node: nothing to do

Combining: t114: ch = TokenFactor t110:1, t113:1

Legalizing: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Legalizing non-extending load operation

Combining: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16

Legalizing: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
Legalizing non-extending load operation

Combining: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16

Legalizing: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16

Legalizing: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16
Legalizing non-extending load operation

Combining: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16

Legalizing: t12: i16 = add nuw t10, Constant:i16<4>
Legal node: nothing to do

Combining: t12: i16 = add nuw t10, Constant:i16<4>

Legalizing: t100: i16 = add t10, Constant:i16<-4>
Legal node: nothing to do

Combining: t100: i16 = add t10, Constant:i16<-4>

Legalizing: t109: i16 = add t10, Constant:i16<-12>
Legal node: nothing to do

Combining: t109: i16 = add t10, Constant:i16<-12>

Legalizing: t116: i16 = add nuw t10, Constant:i16<6>
Legal node: nothing to do

Combining: t116: i16 = add nuw t10, Constant:i16<6>

Legalizing: t10: i16 = add t4, t9
Legal node: nothing to do

Combining: t10: i16 = add t4, t9

Legalizing: t9: i16 = shl t6, Constant:i16<3>
Legal node: nothing to do

Combining: t9: i16 = shl t6, Constant:i16<3>

Legalizing: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t115: i16 = Constant<6>
Legal node: nothing to do

Combining: t115: i16 = Constant<6>

Legalizing: t99: i16 = Constant<-4>
Legal node: nothing to do

Combining: t99: i16 = Constant<-4>

Legalizing: t90: i16 = Constant<-12>
Legal node: nothing to do

Combining: t90: i16 = Constant<-12>

Legalizing: t75: i16 = Constant<-2>
Legal node: nothing to do

Combining: t75: i16 = Constant<-2>

Legalizing: t68: ch = BasicBlock< 0x16b38284388>
Legal node: nothing to do

Combining: t68: ch = BasicBlock< 0x16b38284388>

Legalizing: t49: i16 = TargetGlobalAddress<ptr @output> 0
Legal node: nothing to do

Combining: t49: i16 = TargetGlobalAddress<ptr @output> 0

Legalizing: t45: i16 = FrameIndex<5>
Legal node: nothing to do

Combining: t45: i16 = FrameIndex<5>

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i16 = Register $r4

Combining: t40: i16 = Register $r4

Legalizing: t38: i16 = Register $r3

Combining: t38: i16 = Register $r3

Legalizing: t36: i16 = Register $r2

Combining: t36: i16 = Register $r2

Legalizing: t34: i16 = Register $r1

Combining: t34: i16 = Register $r1

Legalizing: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0
Legal node: nothing to do

Combining: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0

Legalizing: t11: i16 = Constant<4>
Legal node: nothing to do

Combining: t11: i16 = Constant<4>

Legalizing: t8: i16 = Constant<3>
Legal node: nothing to do

Combining: t8: i16 = Constant<3>

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i16 = FrameIndex<1>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.30 'main:'
SelectionDAG has 55 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t9: i16 = shl t6, Constant:i16<3>
  t10: i16 = add t4, t9
    t116: i16 = add nuw t10, Constant:i16<6>
  t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16
    t109: i16 = add t10, Constant:i16<-12>
  t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
    t100: i16 = add t10, Constant:i16<-4>
  t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
    t12: i16 = add nuw t10, Constant:i16<4>
  t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
    t114: ch = TokenFactor t110:1, t113:1
  t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
  t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
  t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
  t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
      t61: ch = TokenFactor t52:1, t53:1, t84:1
          t86: i16 = shl t84, Constant:i16<3>
        t88: i16 = add t86, t53
      t91: i16 = add t88, Constant:i16<-12>
    t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
  t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
      t76: i16 = add t77, Constant:i16<-2>
    t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
  t69: ch = br t67, BasicBlock:ch< 0x16b38284388>


===== Instruction selection begins: %bb.30 ''

ISEL: Starting selection on root node: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>
Selecting: t69: ch = br t67, BasicBlock:ch< 0x16b38284388>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t69: ch = JMPI BasicBlock:ch< 0x16b38284388>, t67
ISEL: Match complete!

ISEL: Starting selection on root node: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16
Selecting: t67: ch = store<(store (s16) into %ir.2)> t77:1, t76, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t67: ch = STORE16R<Mem:(store (s16) into %ir.2)> FrameIndex:i16<1>, t76, t77:1
ISEL: Match complete!

ISEL: Starting selection on root node: t76: i16 = add t77, Constant:i16<-2>
Selecting: t76: i16 = add t77, Constant:i16<-2>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t118: i16 = TargetConstant<-2>
  Morphed node: t76: i16 = ADDI t77, TargetConstant:i16<-2>
ISEL: Match complete!

ISEL: Starting selection on root node: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16
Selecting: t77: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t62, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t77: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t62
ISEL: Match complete!

ISEL: Starting selection on root node: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16
Selecting: t62: ch = store<(store (s16) into %ir.149, align 4)> t61, t52, t91, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t62: ch = STORE16R<Mem:(store (s16) into %ir.149, align 4)> t91, t52, t61
ISEL: Match complete!

ISEL: Starting selection on root node: t91: i16 = add t88, Constant:i16<-12>
Selecting: t91: i16 = add t88, Constant:i16<-12>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t119: i16 = TargetConstant<-12>
  Morphed node: t91: i16 = ADDI t88, TargetConstant:i16<-12>
ISEL: Match complete!

ISEL: Starting selection on root node: t88: i16 = add t86, t53
Selecting: t88: i16 = add t86, t53

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t88: i16 = ADDR t86, t53
ISEL: Match complete!

ISEL: Starting selection on root node: t61: ch = TokenFactor t52:1, t53:1, t84:1
Selecting: t61: ch = TokenFactor t52:1, t53:1, t84:1


ISEL: Starting selection on root node: t86: i16 = shl t84, Constant:i16<3>
Selecting: t86: i16 = shl t84, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
Creating constant: t120: i16 = TargetConstant<3>
  Morphed node: t86: i16 = LSLI t84, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16
Selecting: t52: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t51, FrameIndex:i16<5>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<5>, t51
ISEL: Match complete!

ISEL: Starting selection on root node: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t53: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t51, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51
ISEL: Match complete!

ISEL: Starting selection on root node: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16
Selecting: t84: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t51, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t84: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t51
ISEL: Match complete!

ISEL: Starting selection on root node: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1
Selecting: t51: ch,glue = SymphonyISD::Call t47:1, TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t50:1

ISEL: Starting pattern match
  Initial Opcode index to 859
  Morphed node: t51: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t47:1, t50:1
ISEL: Match complete!

ISEL: Starting selection on root node: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
Selecting: t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47


ISEL: Starting selection on root node: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16
Selecting: t47: i16,ch = load<(dereferenceable load (s16) from %ir.6)> t46, FrameIndex:i16<5>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t47: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> FrameIndex:i16<5>, t46
ISEL: Match complete!

ISEL: Starting selection on root node: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16
Selecting: t46: ch = store<(store (s16) into %ir.6)> t44:1, t44, FrameIndex:i16<5>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t46: ch = STORE16R<Mem:(store (s16) into %ir.6)> FrameIndex:i16<5>, t44, t44:1
ISEL: Match complete!

ISEL: Starting selection on root node: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
Selecting: t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1


ISEL: Starting selection on root node: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1
Selecting: t43: ch,glue = SymphonyISD::Call t29, TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t41:1

ISEL: Starting pattern match
  Initial Opcode index to 859
  Morphed node: t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
Selecting: t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1


ISEL: Starting selection on root node: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
Selecting: t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1


ISEL: Starting selection on root node: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
Selecting: t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1


ISEL: Starting selection on root node: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
Selecting: t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110


ISEL: Starting selection on root node: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
Selecting: t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1


ISEL: Starting selection on root node: t114: ch = TokenFactor t110:1, t113:1
Selecting: t114: ch = TokenFactor t110:1, t113:1


ISEL: Starting selection on root node: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16
Selecting: t110: i16,ch = load<(load (s16) from %ir.125, align 4)> t0, t12, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16
Selecting: t27: i16,ch = load<(load (s16) from %ir.139, align 4)> t0, t100, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16
Selecting: t20: i16,ch = load<(load (s16) from %ir.132, align 4)> t0, t109, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16
Selecting: t113: i16,ch = load<(load (s16) from %ir.125 + 2, basealign 4)> t0, t116, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i16 = add nuw t10, Constant:i16<4>
Selecting: t12: i16 = add nuw t10, Constant:i16<4>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t121: i16 = TargetConstant<4>
  Morphed node: t12: i16 = ADDI nuw t10, TargetConstant:i16<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t100: i16 = add t10, Constant:i16<-4>
Selecting: t100: i16 = add t10, Constant:i16<-4>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t122: i16 = TargetConstant<-4>
  Morphed node: t100: i16 = ADDI t10, TargetConstant:i16<-4>
ISEL: Match complete!

ISEL: Starting selection on root node: t109: i16 = add t10, Constant:i16<-12>
Selecting: t109: i16 = add t10, Constant:i16<-12>

ISEL: Starting pattern match
  Initial Opcode index to 586
  Morphed node: t109: i16 = ADDI t10, TargetConstant:i16<-12>
ISEL: Match complete!

ISEL: Starting selection on root node: t116: i16 = add nuw t10, Constant:i16<6>
Selecting: t116: i16 = add nuw t10, Constant:i16<6>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t123: i16 = TargetConstant<6>
  Morphed node: t116: i16 = ADDI nuw t10, TargetConstant:i16<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i16 = add t4, t9
Selecting: t10: i16 = add t4, t9

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t10: i16 = ADDR t4, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i16 = shl t6, Constant:i16<3>
Selecting: t9: i16 = shl t6, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
  Morphed node: t9: i16 = LSLI t6, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Selecting: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t117: i16 = TargetGlobalAddress<ptr @stack> 0
Selecting: t117: i16 = TargetGlobalAddress<ptr @stack> 0


ISEL: Starting selection on root node: t68: ch = BasicBlock< 0x16b38284388>
Selecting: t68: ch = BasicBlock< 0x16b38284388>


ISEL: Starting selection on root node: t49: i16 = TargetGlobalAddress<ptr @output> 0
Selecting: t49: i16 = TargetGlobalAddress<ptr @output> 0


ISEL: Starting selection on root node: t45: i16 = FrameIndex<5>
Selecting: t45: i16 = FrameIndex<5>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t125: i16 = TargetConstant<0>
  Morphed node: t45: i16 = ADDI TargetFrameIndex:i16<5>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t42: Untyped = RegisterMask
Selecting: t42: Untyped = RegisterMask


ISEL: Starting selection on root node: t40: i16 = Register $r4
Selecting: t40: i16 = Register $r4


ISEL: Starting selection on root node: t38: i16 = Register $r3
Selecting: t38: i16 = Register $r3


ISEL: Starting selection on root node: t36: i16 = Register $r2
Selecting: t36: i16 = Register $r2


ISEL: Starting selection on root node: t34: i16 = Register $r1
Selecting: t34: i16 = Register $r1


ISEL: Starting selection on root node: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0
Selecting: t33: i16 = TargetGlobalAddress<ptr @do_calc> 0


ISEL: Starting selection on root node: t5: i16 = FrameIndex<1>
Selecting: t5: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.30 'main:'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
  t45: i16 = ADDI TargetFrameIndex:i16<5>, TargetConstant:i16<0>
  t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0
  t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
    t9: i16 = LSLI t6, TargetConstant:i16<3>
  t10: i16 = ADDR t4, t9
    t116: i16 = ADDI nuw t10, TargetConstant:i16<6>
  t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0
    t109: i16 = ADDI t10, TargetConstant:i16<-12>
  t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0
    t100: i16 = ADDI t10, TargetConstant:i16<-4>
  t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0
    t12: i16 = ADDI nuw t10, TargetConstant:i16<4>
  t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0
    t114: ch = TokenFactor t110:1, t113:1
  t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1
  t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110
  t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1
  t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1
    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1
  t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1
  t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1
    t46: ch = STORE16R<Mem:(store (s16) into %ir.6)> t45, t44, t44:1
  t47: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t46
    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47
  t51: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t47:1, t50:1
  t84: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t51
  t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51
  t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51
          t86: i16 = LSLI t84, TargetConstant:i16<3>
        t88: i16 = ADDR t86, t53
      t91: i16 = ADDI t88, TargetConstant:i16<-12>
      t61: ch = TokenFactor t52:1, t53:1, t84:1
    t62: ch = STORE16R<Mem:(store (s16) into %ir.149, align 4)> t91, t52, t61
  t77: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t62
      t76: i16 = ADDI t77, TargetConstant:i16<-2>
    t67: ch = STORE16R<Mem:(store (s16) into %ir.2)> t5, t76, t77:1
  t69: ch = JMPI BasicBlock:ch< 0x16b38284388>, t67


********** List Scheduling %bb.30 '' **********
SU(0): t69: ch = JMPI BasicBlock:ch< 0x16b38284388>, t67

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 18
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t67: ch = STORE16R<Mem:(store (s16) into %ir.2)> t5, t76, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 17
  Height             : 1
  Predecessors:
    SU(31): Data Latency=1
    SU(30): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t77: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t62

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 15
  Height             : 3
  Predecessors:
    SU(31): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(30): Data Latency=1
SU(3): t62: ch = STORE16R<Mem:(store (s16) into %ir.149, align 4)> t91, t52, t61

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 14
  Height             : 4
  Predecessors:
    SU(27): Data Latency=1
    SU(26): Data Latency=1
    SU(4): Ord  Latency=0 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t61: ch = TokenFactor t52:1, t53:1, t84:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 4
  Predecessors:
    SU(26): Ord  Latency=1 Barrier
    SU(25): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Ord  Latency=0 Barrier
SU(5): t84: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t51

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 10
  Height             : 8
  Predecessors:
    SU(31): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(29): Data Latency=1
SU(6): t51: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t47:1, t50:1

    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47

  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 9
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
  Successors:
    SU(5): Ord  Latency=1 Barrier
    SU(25): Ord  Latency=1 Barrier
    SU(26): Ord  Latency=1 Barrier
SU(7): t47: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t46

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 10
  Predecessors:
    SU(24): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
SU(8): t46: ch = STORE16R<Mem:(store (s16) into %ir.6)> t45, t44, t44:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 11
  Predecessors:
    SU(24): Data Latency=1
    SU(9): Data Latency=1
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

    t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

    t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

    t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

    t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1

  # preds left       : 5
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 12
  Predecessors:
    SU(22): Ord  Latency=0 Barrier
    SU(10): Data Latency=1
    SU(16): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
  Successors:
    SU(8): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
SU(10): t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 13
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(9): Data Latency=1
    SU(22): Ord  Latency=1 Barrier
SU(11): t100: i16 = ADDI t10, TargetConstant:i16<-4>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 14
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(10): Data Latency=1
SU(12): t10: i16 = ADDR t4, t9

  # preds left       : 2
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 15
  Predecessors:
    SU(15): Data Latency=1
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(17): Data Latency=1
    SU(19): Data Latency=1
    SU(21): Data Latency=1
SU(13): t9: i16 = LSLI t6, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 16
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(12): Data Latency=1
SU(14): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 17
  Predecessors:
    SU(31): Data Latency=1
  Successors:
    SU(13): Data Latency=1
    SU(22): Ord  Latency=1 Barrier
SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 16
  Successors:
    SU(12): Data Latency=1
    SU(22): Ord  Latency=1 Barrier
SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 13
  Predecessors:
    SU(17): Data Latency=1
  Successors:
    SU(9): Data Latency=1
    SU(22): Ord  Latency=1 Barrier
SU(17): t109: i16 = ADDI t10, TargetConstant:i16<-12>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 14
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(16): Data Latency=1
SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 13
  Predecessors:
    SU(19): Data Latency=1
  Successors:
    SU(9): Data Latency=1
    SU(23): Ord  Latency=1 Barrier
SU(19): t116: i16 = ADDI nuw t10, TargetConstant:i16<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 14
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(18): Data Latency=1
SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 13
  Predecessors:
    SU(21): Data Latency=1
  Successors:
    SU(9): Data Latency=1
    SU(23): Ord  Latency=1 Barrier
SU(21): t12: i16 = ADDI nuw t10, TargetConstant:i16<4>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 14
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(20): Data Latency=1
SU(22): t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 12
  Predecessors:
    SU(15): Ord  Latency=1 Barrier
    SU(14): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=0 Barrier
    SU(16): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=0 Barrier
SU(23): t114: ch = TokenFactor t110:1, t113:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 12
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
  Successors:
    SU(22): Ord  Latency=0 Barrier
SU(24): t45: i16 = ADDI TargetFrameIndex:i16<5>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(7): Data Latency=1
    SU(8): Data Latency=1
    SU(26): Data Latency=1
SU(25): t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 10
  Height             : 7
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(28): Data Latency=1
SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 10
  Height             : 5
  Predecessors:
    SU(24): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
SU(27): t91: i16 = ADDI t88, TargetConstant:i16<-12>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 13
  Height             : 5
  Predecessors:
    SU(28): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(28): t88: i16 = ADDR t86, t53

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 12
  Height             : 6
  Predecessors:
    SU(29): Data Latency=1
    SU(25): Data Latency=1
  Successors:
    SU(27): Data Latency=1
SU(29): t86: i16 = LSLI t84, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 11
  Height             : 7
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(28): Data Latency=1
SU(30): t76: i16 = ADDI t77, TargetConstant:i16<-2>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 16
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(31): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 18
  Successors:
    SU(1): Data Latency=1
    SU(2): Data Latency=1
    SU(5): Data Latency=1
    SU(14): Data Latency=1

Examining Available:
Height 0: SU(0): t69: ch = JMPI BasicBlock:ch< 0x16b38284388>, t67


*** Scheduling [0]: SU(0): t69: ch = JMPI BasicBlock:ch< 0x16b38284388>, t67


Examining Available:
Height 1: SU(1): t67: ch = STORE16R<Mem:(store (s16) into %ir.2)> t5, t76, t77:1


*** Scheduling [1]: SU(1): t67: ch = STORE16R<Mem:(store (s16) into %ir.2)> t5, t76, t77:1


Examining Available:
Height 2: SU(30): t76: i16 = ADDI t77, TargetConstant:i16<-2>


*** Scheduling [2]: SU(30): t76: i16 = ADDI t77, TargetConstant:i16<-2>


Examining Available:
Height 3: SU(2): t77: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t62


*** Scheduling [3]: SU(2): t77: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t62


Examining Available:
Height 4: SU(3): t62: ch = STORE16R<Mem:(store (s16) into %ir.149, align 4)> t91, t52, t61


*** Scheduling [4]: SU(3): t62: ch = STORE16R<Mem:(store (s16) into %ir.149, align 4)> t91, t52, t61


Examining Available:
Height 4: SU(4): t61: ch = TokenFactor t52:1, t53:1, t84:1

Height 5: SU(27): t91: i16 = ADDI t88, TargetConstant:i16<-12>


*** Scheduling [5]: SU(4): t61: ch = TokenFactor t52:1, t53:1, t84:1


Examining Available:
Height 5: SU(27): t91: i16 = ADDI t88, TargetConstant:i16<-12>

Height 6: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


*** Scheduling [6]: SU(27): t91: i16 = ADDI t88, TargetConstant:i16<-12>


Examining Available:
Height 7: SU(28): t88: i16 = ADDR t86, t53

Height 6: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


*** Scheduling [7]: SU(28): t88: i16 = ADDR t86, t53


Examining Available:
Height 8: SU(29): t86: i16 = LSLI t84, TargetConstant:i16<3>

Height 8: SU(25): t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51

Height 6: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


*** Scheduling [8]: SU(29): t86: i16 = LSLI t84, TargetConstant:i16<3>


Examining Available:
Height 9: SU(5): t84: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t51

Height 8: SU(25): t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51

Height 6: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


*** Scheduling [9]: SU(5): t84: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t51


Examining Available:
Height 8: SU(25): t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51

Height 6: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


*** Scheduling [10]: SU(25): t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51


Examining Available:
Height 6: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


*** Scheduling [11]: SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51


Examining Available:
Height 12: SU(6): t51: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t47:1, t50:1

    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47


*** Scheduling [12]: SU(6): t51: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t47:1, t50:1

    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47


Examining Available:
Height 13: SU(7): t47: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t46


*** Scheduling [13]: SU(7): t47: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t46


Examining Available:
Height 14: SU(8): t46: ch = STORE16R<Mem:(store (s16) into %ir.6)> t45, t44, t44:1


*** Scheduling [14]: SU(8): t46: ch = STORE16R<Mem:(store (s16) into %ir.6)> t45, t44, t44:1


Examining Available:
Height 15: SU(24): t45: i16 = ADDI TargetFrameIndex:i16<5>, TargetConstant:i16<0>

Height 15: SU(9): t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

    t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

    t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

    t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

    t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1


*** Scheduling [15]: SU(24): t45: i16 = ADDI TargetFrameIndex:i16<5>, TargetConstant:i16<0>


Examining Available:
Height 15: SU(9): t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

    t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

    t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

    t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

    t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1


*** Scheduling [16]: SU(9): t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

    t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

    t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

    t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

    t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1


Examining Available:
Height 16: SU(22): t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1


*** Scheduling [17]: SU(22): t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1


Examining Available:
Height 17: SU(23): t114: ch = TokenFactor t110:1, t113:1

Height 18: SU(10): t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0

Height 18: SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0


*** Scheduling [18]: SU(23): t114: ch = TokenFactor t110:1, t113:1


Examining Available:
Height 18: SU(10): t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0

Height 18: SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0

Height 19: SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

Height 19: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0


*** Scheduling [19]: SU(10): t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0


Examining Available:
Height 20: SU(11): t100: i16 = ADDI t10, TargetConstant:i16<-4>

Height 18: SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0

Height 19: SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

Height 19: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0


*** Scheduling [20]: SU(11): t100: i16 = ADDI t10, TargetConstant:i16<-4>


Examining Available:
Height 18: SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0

Height 19: SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

Height 19: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0


*** Scheduling [21]: SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0


Examining Available:
Height 22: SU(17): t109: i16 = ADDI t10, TargetConstant:i16<-12>

Height 19: SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

Height 19: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0


*** Scheduling [22]: SU(17): t109: i16 = ADDI t10, TargetConstant:i16<-12>


Examining Available:
Height 19: SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

Height 19: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0


*** Scheduling [23]: SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0


Examining Available:
Height 19: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0

Height 24: SU(21): t12: i16 = ADDI nuw t10, TargetConstant:i16<4>


*** Scheduling [24]: SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0


Examining Available:
Height 25: SU(19): t116: i16 = ADDI nuw t10, TargetConstant:i16<6>

Height 24: SU(21): t12: i16 = ADDI nuw t10, TargetConstant:i16<4>


*** Scheduling [25]: SU(19): t116: i16 = ADDI nuw t10, TargetConstant:i16<6>


Examining Available:
Height 24: SU(21): t12: i16 = ADDI nuw t10, TargetConstant:i16<4>


*** Scheduling [26]: SU(21): t12: i16 = ADDI nuw t10, TargetConstant:i16<4>


Examining Available:
Height 27: SU(12): t10: i16 = ADDR t4, t9


*** Scheduling [27]: SU(12): t10: i16 = ADDR t4, t9


Examining Available:
Height 28: SU(13): t9: i16 = LSLI t6, TargetConstant:i16<3>

Height 28: SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [28]: SU(13): t9: i16 = LSLI t6, TargetConstant:i16<3>


Examining Available:
Height 29: SU(14): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

Height 28: SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [29]: SU(14): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0


Examining Available:
Height 30: SU(31): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 28: SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [30]: SU(31): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 28: SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [31]: SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

*** Final schedule ***
SU(15): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

SU(31): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(14): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

SU(13): t9: i16 = LSLI t6, TargetConstant:i16<3>

SU(12): t10: i16 = ADDR t4, t9

SU(21): t12: i16 = ADDI nuw t10, TargetConstant:i16<4>

SU(19): t116: i16 = ADDI nuw t10, TargetConstant:i16<6>

SU(18): t113: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125 + 2, basealign 4)> t116, t0

SU(20): t110: i16,ch = LOAD16R<Mem:(load (s16) from %ir.125, align 4)> t12, t0

SU(17): t109: i16 = ADDI t10, TargetConstant:i16<-12>

SU(16): t20: i16,ch = LOAD16R<Mem:(load (s16) from %ir.132, align 4)> t109, t0

SU(11): t100: i16 = ADDI t10, TargetConstant:i16<-4>

SU(10): t27: i16,ch = LOAD16R<Mem:(load (s16) from %ir.139, align 4)> t100, t0

SU(23): t114: ch = TokenFactor t110:1, t113:1

SU(22): t29: ch = TokenFactor t4:1, t6:1, t114, t4:1, t6:1, t20:1, t4:1, t6:1, t27:1

SU(9): t44: i16,ch,glue = CopyFromReg t43, Register:i16 $r1, t43:1

    t35: ch,glue = CopyToReg t29, Register:i16 $r1, t110

    t37: ch,glue = CopyToReg t35, Register:i16 $r2, t113, t35:1

    t39: ch,glue = CopyToReg t37, Register:i16 $r3, t20, t37:1

    t41: ch,glue = CopyToReg t39, Register:i16 $r4, t27, t39:1

    t43: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @do_calc> 0, Register:i16 $r1, Register:i16 $r2, Register:i16 $r3, Register:i16 $r4, RegisterMask:Untyped, t29, t41:1

SU(24): t45: i16 = ADDI TargetFrameIndex:i16<5>, TargetConstant:i16<0>

SU(8): t46: ch = STORE16R<Mem:(store (s16) into %ir.6)> t45, t44, t44:1

SU(7): t47: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t46

SU(6): t51: ch,glue = SymphonyCallI TargetGlobalAddress:i16<ptr @output> 0, Register:i16 $r1, RegisterMask:Untyped, t47:1, t50:1

    t50: ch,glue = CopyToReg t47:1, Register:i16 $r1, t47

SU(26): t52: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.6)> t45, t51

SU(25): t53: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t51

SU(5): t84: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t51

SU(29): t86: i16 = LSLI t84, TargetConstant:i16<3>

SU(28): t88: i16 = ADDR t86, t53

SU(27): t91: i16 = ADDI t88, TargetConstant:i16<-12>

SU(4): t61: ch = TokenFactor t52:1, t53:1, t84:1

SU(3): t62: ch = STORE16R<Mem:(store (s16) into %ir.149, align 4)> t91, t52, t61

SU(2): t77: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t62

SU(30): t76: i16 = ADDI t77, TargetConstant:i16<-2>

SU(1): t67: ch = STORE16R<Mem:(store (s16) into %ir.2)> t5, t76, t77:1

SU(0): t69: ch = JMPI BasicBlock:ch< 0x16b38284388>, t67


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>

Initial selection DAG: %bb.31 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>

Combining: t1: ch = BasicBlock< 0x16b38288ac0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.31 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>



Legalizing node: t1: ch = BasicBlock< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38288ac0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38288ac0>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.31 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38288ac0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.31 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>

Legalizing: t1: ch = BasicBlock< 0x16b38288ac0>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38288ac0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.31 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>


===== Instruction selection begins: %bb.31 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38288ac0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38288ac0>
Selecting: t1: ch = BasicBlock< 0x16b38288ac0>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.31 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t0


********** List Scheduling %bb.31 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288ac0>, t0


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>

Initial selection DAG: %bb.32 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>

Combining: t1: ch = BasicBlock< 0x16b38288c08>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.32 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>



Legalizing node: t1: ch = BasicBlock< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38288c08>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38288c08>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.32 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38288c08>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.32 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>

Legalizing: t1: ch = BasicBlock< 0x16b38288c08>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38288c08>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.32 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>


===== Instruction selection begins: %bb.32 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38288c08>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38288c08>
Selecting: t1: ch = BasicBlock< 0x16b38288c08>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.32 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t0


********** List Scheduling %bb.32 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288c08>, t0


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>

Initial selection DAG: %bb.33 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>

Combining: t1: ch = BasicBlock< 0x16b38288d50>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.33 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>



Legalizing node: t1: ch = BasicBlock< 0x16b38288d50>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b38288d50>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b38288d50>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.33 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b38288d50>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.33 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>

Legalizing: t1: ch = BasicBlock< 0x16b38288d50>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b38288d50>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.33 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>


===== Instruction selection begins: %bb.33 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b38288d50>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b38288d50>
Selecting: t1: ch = BasicBlock< 0x16b38288d50>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.33 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t0


********** List Scheduling %bb.33 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t0


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Creating new node: t7: i32 = zero_extend t6
Creating constant: t8: i16 = Constant<3>
Creating new node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Creating new node: t10: i16 = add nuw t4, t9
Creating constant: t11: i8 = Constant<1>
Creating new node: t12: ch = TokenFactor t4:1, t6:1
Creating new node: t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16
Creating new node: t15: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t13, FrameIndex:i16<3>, undef:i16
Creating new node: t16: i32 = zero_extend t15
Creating constant: t17: i32 = Constant<48>
Creating new node: t18: i32 = sub nsw t16, Constant:i32<48>
Creating new node: t19: i16 = truncate t18
Creating new node: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16
Creating new node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16
Creating new node: t22: i32 = zero_extend t21
Creating new node: t23: i16 = shl nuw nsw t21, Constant:i16<3>
Creating new node: t24: i16 = add nuw t20, t23
Creating constant: t25: i16 = Constant<4>
Creating new node: t26: i16 = add nuw t24, Constant:i16<4>
Creating new node: t27: ch = TokenFactor t15:1, t20:1, t21:1
Creating new node: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t19, t26, undef:i16
Creating new node: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>

Initial selection DAG: %bb.5 'main:'
SelectionDAG has 31 nodes:
  t0: ch,glue = EntryToken
  t2: i16 = Constant<0>
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t7: i32 = zero_extend t6
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16
  t15: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t13, FrameIndex:i16<3>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16
  t22: i32 = zero_extend t21
      t27: ch = TokenFactor t15:1, t20:1, t21:1
          t16: i32 = zero_extend t15
        t18: i32 = sub nsw t16, Constant:i32<48>
      t19: i16 = truncate t18
          t23: i16 = shl nuw nsw t21, Constant:i16<3>
        t24: i16 = add nuw t20, t23
      t26: i16 = add nuw t24, Constant:i16<4>
    t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t19, t26, undef:i16
  t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>



Combining: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>

Combining: t29: ch = BasicBlock< 0x16b38288d50>

Combining: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t19, t26, undef:i16

Combining: t27: ch = TokenFactor t15:1, t20:1, t21:1

Combining: t26: i16 = add nuw t24, Constant:i16<4>

Combining: t25: i16 = Constant<4>

Combining: t24: i16 = add nuw t20, t23

Combining: t23: i16 = shl nuw nsw t21, Constant:i16<3>

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t19: i16 = truncate t18
Creating new node: t31: i32 = any_extend t15

Replacing.2 t16: i32 = zero_extend t15

With: t31: i32 = any_extend t15


Combining: t31: i32 = any_extend t15
Creating new node: t32: i32,ch = load<(dereferenceable load (s16) from %ir.4), anyext from i16> t13, FrameIndex:i16<3>, undef:i16

Replacing.1 t31: i32 = any_extend t15

With: t32: i32,ch = load<(dereferenceable load (s16) from %ir.4), anyext from i16> t13, FrameIndex:i16<3>, undef:i16
 and 0 other values

Combining: t32: i32,ch = load<(dereferenceable load (s16) from %ir.4), anyext from i16> t13, FrameIndex:i16<3>, undef:i16

Combining: t19: i16 = truncate t18
Creating new node: t33: i16 = truncate t32
Creating constant: t34: i16 = Constant<48>
Creating new node: t35: i16 = sub t33, Constant:i16<48>
 ... into: t35: i16 = sub t33, Constant:i16<48>

Combining: t32: i32,ch = load<(dereferenceable load (s16) from %ir.4), anyext from i16> t13, FrameIndex:i16<3>, undef:i16

Combining: t35: i16 = sub t33, Constant:i16<48>
Creating constant: t36: i16 = Constant<-48>
Creating new node: t37: i16 = add t33, Constant:i16<-48>
 ... into: t37: i16 = add t33, Constant:i16<-48>

Combining: t37: i16 = add t33, Constant:i16<-48>

Combining: t36: i16 = Constant<-48>

Combining: t33: i16 = truncate t32
Creating constant: t38: i16 = Constant<0>
Creating new node: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t13, FrameIndex:i16<3>, undef:i16
 ... into: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t13, FrameIndex:i16<3>, undef:i16

Combining: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t13, FrameIndex:i16<3>, undef:i16

Combining: t27: ch = TokenFactor t39:1, t20:1, t21:1

Combining: t37: i16 = add t39, Constant:i16<-48>

Combining: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16

Combining: t14: i16 = FrameIndex<3>

Combining: t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16

Combining: t12: ch = TokenFactor t4:1, t6:1

Combining: t11: i8 = Constant<1>

Combining: t10: i16 = add nuw t4, t9

Combining: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Combining: t8: i16 = Constant<3>

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.5 'main:'
SelectionDAG has 26 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t13, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t13, FrameIndex:i16<1>, undef:i16
  t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t13, FrameIndex:i16<3>, undef:i16
      t27: ch = TokenFactor t39:1, t20:1, t21:1
      t37: i16 = add t39, Constant:i16<-48>
          t23: i16 = shl nuw nsw t21, Constant:i16<3>
        t24: i16 = add nuw t20, t23
      t26: i16 = add nuw t24, Constant:i16<4>
    t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
  t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>



Legalizing node: t36: i16 = Constant<-48>
Analyzing result type: i16
Legal result type
Legally typed node: t36: i16 = Constant<-48>

Legalizing node: t29: ch = BasicBlock< 0x16b38288d50>
Analyzing result type: ch
Legal result type
Legally typed node: t29: ch = BasicBlock< 0x16b38288d50>

Legalizing node: t25: i16 = Constant<4>
Analyzing result type: i16
Legal result type
Legally typed node: t25: i16 = Constant<4>

Legalizing node: t14: i16 = FrameIndex<3>
Analyzing result type: i16
Legal result type
Legally typed node: t14: i16 = FrameIndex<3>

Legalizing node: t11: i8 = Constant<1>
Analyzing result type: i8
Promote integer result: t11: i8 = Constant<1>
Creating constant: t40: i16 = Constant<1>

Legalizing node: t40: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t40: i16 = Constant<1>

Legalizing node: t8: i16 = Constant<3>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<3>

Legalizing node: t5: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = FrameIndex<1>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = GlobalAddress<ptr @stack> 0
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = GlobalAddress<ptr @stack> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i16 = Constant<3>
Legal operand
Legally typed node: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Legalizing node: t10: i16 = add nuw t4, t9
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Legal operand
Legally typed node: t10: i16 = add nuw t4, t9

Legalizing node: t12: ch = TokenFactor t4:1, t6:1
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t12: ch = TokenFactor t4:1, t6:1

Legalizing node: t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t4:1, t6:1
Legal operand
Analyzing operand: t11: i8 = Constant<1>
Promote integer operand: t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16
Creating new node: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Replacing: t13: ch = store<(store (s8) into %ir.28, align 4)> t12, Constant:i8<1>, t10, undef:i16
     with: t41: ch = store<(store (s8) into %ir.<badref>, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16

Legalizing node: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t4:1, t6:1
Legal operand
Analyzing operand: t40: i16 = Constant<1>
Legal operand
Analyzing operand: t10: i16 = add nuw t4, t9
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16

Legalizing node: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Legal operand
Analyzing operand: t14: i16 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16

Legalizing node: t37: i16 = add t39, Constant:i16<-48>
Analyzing result type: i16
Legal result type
Analyzing operand: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t36: i16 = Constant<-48>
Legal operand
Legally typed node: t37: i16 = add t39, Constant:i16<-48>

Legalizing node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Legal operand
Analyzing operand: t5: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16

Legalizing node: t23: i16 = shl nuw nsw t21, Constant:i16<3>
Analyzing result type: i16
Legal result type
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: i16 = Constant<3>
Legal operand
Legally typed node: t23: i16 = shl nuw nsw t21, Constant:i16<3>

Legalizing node: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Legal operand
Analyzing operand: t1: i16 = GlobalAddress<ptr @stack> 0
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing node: t24: i16 = add nuw t20, t23
Analyzing result type: i16
Legal result type
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t23: i16 = shl nuw nsw t21, Constant:i16<3>
Legal operand
Legally typed node: t24: i16 = add nuw t20, t23

Legalizing node: t26: i16 = add nuw t24, Constant:i16<4>
Analyzing result type: i16
Legal result type
Analyzing operand: t24: i16 = add nuw t20, t23
Legal operand
Analyzing operand: t25: i16 = Constant<4>
Legal operand
Legally typed node: t26: i16 = add nuw t24, Constant:i16<4>

Legalizing node: t27: ch = TokenFactor t39:1, t20:1, t21:1
Analyzing result type: ch
Legal result type
Analyzing operand: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
Legal operand
Analyzing operand: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legal operand
Analyzing operand: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
Legal operand
Legally typed node: t27: ch = TokenFactor t39:1, t20:1, t21:1

Legalizing node: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch = TokenFactor t39:1, t20:1, t21:1
Legal operand
Analyzing operand: t37: i16 = add t39, Constant:i16<-48>
Legal operand
Analyzing operand: t26: i16 = add nuw t24, Constant:i16<4>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16

Legalizing node: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>
Analyzing result type: ch
Legal result type
Analyzing operand: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
Legal operand
Analyzing operand: t29: ch = BasicBlock< 0x16b38288d50>
Legal operand
Legally typed node: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>

Legalizing node: t65535: ch = handlenode t30
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>
Legal operand
Legally typed node: t65535: ch = handlenode t30

Type-legalized selection DAG: %bb.5 'main:'
SelectionDAG has 26 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
  t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
      t27: ch = TokenFactor t39:1, t20:1, t21:1
      t37: i16 = add t39, Constant:i16<-48>
          t23: i16 = shl nuw nsw t21, Constant:i16<3>
        t24: i16 = add nuw t20, t23
      t26: i16 = add nuw t24, Constant:i16<4>
    t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
  t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>



Combining: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16

Combining: t40: i16 = Constant<1>

Combining: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16

Combining: t37: i16 = add t39, Constant:i16<-48>

Combining: t36: i16 = Constant<-48>

Combining: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>

Combining: t29: ch = BasicBlock< 0x16b38288d50>

Combining: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16

Combining: t27: ch = TokenFactor t39:1, t20:1, t21:1

Combining: t26: i16 = add nuw t24, Constant:i16<4>

Combining: t25: i16 = Constant<4>

Combining: t24: i16 = add nuw t20, t23

Combining: t23: i16 = shl nuw nsw t21, Constant:i16<3>

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16

Combining: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t14: i16 = FrameIndex<3>

Combining: t12: ch = TokenFactor t4:1, t6:1

Combining: t10: i16 = add nuw t4, t9

Combining: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Combining: t8: i16 = Constant<3>

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t5: i16 = FrameIndex<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = GlobalAddress<ptr @stack> 0

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.5 'main:'
SelectionDAG has 26 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
  t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
      t27: ch = TokenFactor t39:1, t20:1, t21:1
      t37: i16 = add t39, Constant:i16<-48>
          t23: i16 = shl nuw nsw t21, Constant:i16<3>
        t24: i16 = add nuw t20, t23
      t26: i16 = add nuw t24, Constant:i16<4>
    t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
  t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>



Legalizing: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>
Legal node: nothing to do

Legalizing: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: i16 = add nuw t24, Constant:i16<4>
Legal node: nothing to do

Legalizing: t24: i16 = add nuw t20, t23
Legal node: nothing to do

Legalizing: t27: ch = TokenFactor t39:1, t20:1, t21:1
Legal node: nothing to do

Legalizing: t37: i16 = add t39, Constant:i16<-48>
Legal node: nothing to do

Legalizing: t23: i16 = shl nuw nsw t21, Constant:i16<3>
Legal node: nothing to do

Legalizing: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Legalizing truncating store operations

Legalizing: t10: i16 = add nuw t4, t9
Legal node: nothing to do

Legalizing: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Legal node: nothing to do

Legalizing: t12: ch = TokenFactor t4:1, t6:1
Legal node: nothing to do

Legalizing: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, GlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Legalizing: t40: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t36: i16 = Constant<-48>
Legal node: nothing to do

Legalizing: t29: ch = BasicBlock< 0x16b38288d50>
Legal node: nothing to do

Legalizing: t25: i16 = Constant<4>
Legal node: nothing to do

Legalizing: t14: i16 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t8: i16 = Constant<3>
Legal node: nothing to do

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = GlobalAddress<ptr @stack> 0
Trying custom legalization
Successfully custom legalized node
 ... replacing: t1: i16 = GlobalAddress<ptr @stack> 0
     with:      t42: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t42: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Legalized selection DAG: %bb.5 'main:'
SelectionDAG has 26 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
  t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
      t27: ch = TokenFactor t39:1, t20:1, t21:1
      t37: i16 = add t39, Constant:i16<-48>
          t23: i16 = shl nuw nsw t21, Constant:i16<3>
        t24: i16 = add nuw t20, t23
      t26: i16 = add nuw t24, Constant:i16<4>
    t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
  t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>



Legalizing: t42: i16 = TargetGlobalAddress<ptr @stack> 0
Legal node: nothing to do

Combining: t42: i16 = TargetGlobalAddress<ptr @stack> 0

Legalizing: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>
Legal node: nothing to do

Combining: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>

Legalizing: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16

Legalizing: t26: i16 = add nuw t24, Constant:i16<4>
Legal node: nothing to do

Combining: t26: i16 = add nuw t24, Constant:i16<4>

Legalizing: t24: i16 = add nuw t20, t23
Legal node: nothing to do

Combining: t24: i16 = add nuw t20, t23

Legalizing: t27: ch = TokenFactor t39:1, t20:1, t21:1
Legal node: nothing to do

Combining: t27: ch = TokenFactor t39:1, t20:1, t21:1

Legalizing: t37: i16 = add t39, Constant:i16<-48>
Legal node: nothing to do

Combining: t37: i16 = add t39, Constant:i16<-48>

Legalizing: t23: i16 = shl nuw nsw t21, Constant:i16<3>
Legal node: nothing to do

Combining: t23: i16 = shl nuw nsw t21, Constant:i16<3>

Legalizing: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
Legalizing non-extending load operation

Combining: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16

Legalizing: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16

Legalizing: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Legalizing truncating store operations

Combining: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16

Legalizing: t10: i16 = add nuw t4, t9
Legal node: nothing to do

Combining: t10: i16 = add nuw t4, t9

Legalizing: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Legal node: nothing to do

Combining: t9: i16 = shl nuw nsw t6, Constant:i16<3>

Legalizing: t12: ch = TokenFactor t4:1, t6:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t4:1, t6:1

Legalizing: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

Legalizing: t40: i16 = Constant<1>
Legal node: nothing to do

Combining: t40: i16 = Constant<1>

Legalizing: t36: i16 = Constant<-48>
Legal node: nothing to do

Combining: t36: i16 = Constant<-48>

Legalizing: t29: ch = BasicBlock< 0x16b38288d50>
Legal node: nothing to do

Combining: t29: ch = BasicBlock< 0x16b38288d50>

Legalizing: t25: i16 = Constant<4>
Legal node: nothing to do

Combining: t25: i16 = Constant<4>

Legalizing: t14: i16 = FrameIndex<3>
Legal node: nothing to do

Combining: t14: i16 = FrameIndex<3>

Legalizing: t8: i16 = Constant<3>
Legal node: nothing to do

Combining: t8: i16 = Constant<3>

Legalizing: t5: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t5: i16 = FrameIndex<1>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.5 'main:'
SelectionDAG has 26 nodes:
  t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
    t12: ch = TokenFactor t4:1, t6:1
      t9: i16 = shl nuw nsw t6, Constant:i16<3>
    t10: i16 = add nuw t4, t9
  t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
  t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
  t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
  t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
      t27: ch = TokenFactor t39:1, t20:1, t21:1
      t37: i16 = add t39, Constant:i16<-48>
          t23: i16 = shl nuw nsw t21, Constant:i16<3>
        t24: i16 = add nuw t20, t23
      t26: i16 = add nuw t24, Constant:i16<4>
    t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
  t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>


===== Instruction selection begins: %bb.5 ''

ISEL: Starting selection on root node: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>
Selecting: t30: ch = br t28, BasicBlock:ch< 0x16b38288d50>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t30: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16
Selecting: t28: ch = store<(store (s16) into %ir.37, align 4)> t27, t37, t26, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t28: ch = STORE16R<Mem:(store (s16) into %ir.37, align 4)> t26, t37, t27
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i16 = add nuw t24, Constant:i16<4>
Selecting: t26: i16 = add nuw t24, Constant:i16<4>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t43: i16 = TargetConstant<4>
  Morphed node: t26: i16 = ADDI nuw t24, TargetConstant:i16<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i16 = add nuw t20, t23
Selecting: t24: i16 = add nuw t20, t23

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t24: i16 = ADDR nuw t20, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t27: ch = TokenFactor t39:1, t20:1, t21:1
Selecting: t27: ch = TokenFactor t39:1, t20:1, t21:1


ISEL: Starting selection on root node: t37: i16 = add t39, Constant:i16<-48>
Selecting: t37: i16 = add t39, Constant:i16<-48>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t44: i16 = TargetConstant<-48>
  Morphed node: t37: i16 = ADDI t39, TargetConstant:i16<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i16 = shl nuw nsw t21, Constant:i16<3>
Selecting: t23: i16 = shl nuw nsw t21, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
Creating constant: t45: i16 = TargetConstant<3>
  Morphed node: t23: i16 = LSLI nuw nsw t21, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16
Selecting: t39: i16,ch = load<(dereferenceable load (s16) from %ir.4)> t41, FrameIndex:i16<3>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t39: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> FrameIndex:i16<3>, t41
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16
Selecting: t21: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t41, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t41
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t20: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t41, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16
Selecting: t41: ch = store<(store (s8) into %ir.28, align 4), trunc to i8> t12, Constant:i16<1>, t10, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, Constant:i16<1>, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i16 = add nuw t4, t9
Selecting: t10: i16 = add nuw t4, t9

ISEL: Starting pattern match
  Initial Opcode index to 586
  Match failed at index 591
  Continuing at 604
  Morphed node: t10: i16 = ADDR nuw t4, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t4:1, t6:1
Selecting: t12: ch = TokenFactor t4:1, t6:1


ISEL: Starting selection on root node: t9: i16 = shl nuw nsw t6, Constant:i16<3>
Selecting: t9: i16 = shl nuw nsw t6, Constant:i16<3>

ISEL: Starting pattern match
  Initial Opcode index to 646
  Morphed node: t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from @stack, align 4)> t0, TargetGlobalAddress:i16<ptr @stack> 0, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Selecting: t6: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t42: i16 = TargetGlobalAddress<ptr @stack> 0
Selecting: t42: i16 = TargetGlobalAddress<ptr @stack> 0


ISEL: Starting selection on root node: t40: i16 = Constant<1>
Selecting: t40: i16 = Constant<1>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t46: i16 = TargetConstant<1>
  Morphed node: t40: i16 = MOVI TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch = BasicBlock< 0x16b38288d50>
Selecting: t29: ch = BasicBlock< 0x16b38288d50>


ISEL: Starting selection on root node: t14: i16 = FrameIndex<3>
Selecting: t14: i16 = FrameIndex<3>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t48: i16 = TargetConstant<0>
  Morphed node: t14: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i16 = FrameIndex<1>
Selecting: t5: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.5 'main:'
SelectionDAG has 29 nodes:
  t0: ch,glue = EntryToken
  t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
  t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0
  t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0
      t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>
    t10: i16 = ADDR nuw t4, t9
    t40: i16 = MOVI TargetConstant:i16<1>
    t12: ch = TokenFactor t4:1, t6:1
  t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, t40, t12
  t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41
  t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t41
    t14: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>
  t39: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t14, t41
          t23: i16 = LSLI nuw nsw t21, TargetConstant:i16<3>
        t24: i16 = ADDR nuw t20, t23
      t26: i16 = ADDI nuw t24, TargetConstant:i16<4>
      t37: i16 = ADDI t39, TargetConstant:i16<-48>
      t27: ch = TokenFactor t39:1, t20:1, t21:1
    t28: ch = STORE16R<Mem:(store (s16) into %ir.37, align 4)> t26, t37, t27
  t30: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t28


********** List Scheduling %bb.5 '' **********
SU(0): t30: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t28

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t28: ch = STORE16R<Mem:(store (s16) into %ir.37, align 4)> t26, t37, t27

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(16): Data Latency=1
    SU(15): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t27: ch = TokenFactor t39:1, t20:1, t21:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t41

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(11): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(18): Data Latency=1
SU(4): t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, t40, t12

  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
    SU(5): Ord  Latency=0 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
    SU(12): Ord  Latency=1 Barrier
    SU(13): Ord  Latency=1 Barrier
SU(5): t12: ch = TokenFactor t4:1, t6:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 6
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=0 Barrier
SU(6): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(5): Ord  Latency=1 Barrier
    SU(10): Data Latency=1
SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(5): Ord  Latency=1 Barrier
    SU(9): Data Latency=1
SU(8): t40: i16 = MOVI TargetConstant:i16<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
SU(9): t10: i16 = ADDR nuw t4, t9

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(7): Data Latency=1
    SU(10): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(10): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(9): Data Latency=1
SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(3): Data Latency=1
    SU(6): Data Latency=1
SU(12): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 4
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(17): Data Latency=1
SU(13): t39: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t14, t41

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(14): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(15): Data Latency=1
SU(14): t14: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(13): Data Latency=1
SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(16): t26: i16 = ADDI nuw t24, TargetConstant:i16<4>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(17): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(17): t24: i16 = ADDR nuw t20, t23

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(12): Data Latency=1
    SU(18): Data Latency=1
  Successors:
    SU(16): Data Latency=1
SU(18): t23: i16 = LSLI nuw nsw t21, TargetConstant:i16<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(17): Data Latency=1

Examining Available:
Height 0: SU(0): t30: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t28


*** Scheduling [0]: SU(0): t30: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t28


Examining Available:
Height 1: SU(1): t28: ch = STORE16R<Mem:(store (s16) into %ir.37, align 4)> t26, t37, t27


*** Scheduling [1]: SU(1): t28: ch = STORE16R<Mem:(store (s16) into %ir.37, align 4)> t26, t37, t27


Examining Available:
Height 1: SU(2): t27: ch = TokenFactor t39:1, t20:1, t21:1

Height 2: SU(16): t26: i16 = ADDI nuw t24, TargetConstant:i16<4>

Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [2]: SU(2): t27: ch = TokenFactor t39:1, t20:1, t21:1


Examining Available:
Height 2: SU(16): t26: i16 = ADDI nuw t24, TargetConstant:i16<4>

Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [3]: SU(16): t26: i16 = ADDI nuw t24, TargetConstant:i16<4>


Examining Available:
Height 4: SU(17): t24: i16 = ADDR nuw t20, t23

Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [4]: SU(17): t24: i16 = ADDR nuw t20, t23


Examining Available:
Height 5: SU(18): t23: i16 = LSLI nuw nsw t21, TargetConstant:i16<3>

Height 5: SU(12): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41

Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [5]: SU(18): t23: i16 = LSLI nuw nsw t21, TargetConstant:i16<3>


Examining Available:
Height 6: SU(3): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t41

Height 5: SU(12): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41

Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [6]: SU(3): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t41


Examining Available:
Height 5: SU(12): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41

Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [7]: SU(12): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41


Examining Available:
Height 2: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


*** Scheduling [8]: SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>


Examining Available:
Height 9: SU(13): t39: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t14, t41


*** Scheduling [9]: SU(13): t39: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t14, t41


Examining Available:
Height 10: SU(14): t14: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

Height 10: SU(4): t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, t40, t12


*** Scheduling [10]: SU(14): t14: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>


Examining Available:
Height 10: SU(4): t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, t40, t12


*** Scheduling [11]: SU(4): t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, t40, t12


Examining Available:
Height 11: SU(5): t12: ch = TokenFactor t4:1, t6:1

Height 12: SU(8): t40: i16 = MOVI TargetConstant:i16<1>

Height 12: SU(9): t10: i16 = ADDR nuw t4, t9


*** Scheduling [12]: SU(5): t12: ch = TokenFactor t4:1, t6:1


Examining Available:
Height 12: SU(8): t40: i16 = MOVI TargetConstant:i16<1>

Height 12: SU(9): t10: i16 = ADDR nuw t4, t9


*** Scheduling [13]: SU(8): t40: i16 = MOVI TargetConstant:i16<1>


Examining Available:
Height 12: SU(9): t10: i16 = ADDR nuw t4, t9


*** Scheduling [14]: SU(9): t10: i16 = ADDR nuw t4, t9


Examining Available:
Height 15: SU(10): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>

Height 15: SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [15]: SU(10): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>


Examining Available:
Height 16: SU(6): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

Height 15: SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [16]: SU(6): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0


Examining Available:
Height 17: SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

Height 15: SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [17]: SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


Examining Available:
Height 15: SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0


*** Scheduling [18]: SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

*** Final schedule ***
SU(7): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t0

SU(11): t5: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(6): t6: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t0

SU(10): t9: i16 = LSLI nuw nsw t6, TargetConstant:i16<3>

SU(9): t10: i16 = ADDR nuw t4, t9

SU(8): t40: i16 = MOVI TargetConstant:i16<1>

SU(5): t12: ch = TokenFactor t4:1, t6:1

SU(4): t41: ch = STORE8R<Mem:(store (s8) into %ir.28, align 4)> t10, t40, t12

SU(14): t14: i16 = ADDI TargetFrameIndex:i16<3>, TargetConstant:i16<0>

SU(13): t39: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.4)> t14, t41

SU(15): t37: i16 = ADDI t39, TargetConstant:i16<-48>

SU(12): t20: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from @stack, align 4)> TargetGlobalAddress:i16<ptr @stack> 0, t41

SU(3): t21: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t5, t41

SU(18): t23: i16 = LSLI nuw nsw t21, TargetConstant:i16<3>

SU(17): t24: i16 = ADDR nuw t20, t23

SU(16): t26: i16 = ADDI nuw t24, TargetConstant:i16<4>

SU(2): t27: ch = TokenFactor t39:1, t20:1, t21:1

SU(1): t28: ch = STORE16R<Mem:(store (s16) into %ir.37, align 4)> t26, t37, t27

SU(0): t30: ch = JMPI BasicBlock:ch< 0x16b38288d50>, t28


Total amount of phi nodes to update: 0
Creating constant: t2: i16 = Constant<0>
Creating new node: t3: i16 = undef
Creating new node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Creating constant: t5: i16 = Constant<1>
Creating new node: t6: i16 = add t4, Constant:i16<1>
Creating new node: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
Creating new node: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>

Initial selection DAG: %bb.34 'main:'
SelectionDAG has 10 nodes:
  t2: i16 = Constant<0>
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
      t6: i16 = add t4, Constant:i16<1>
    t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
  t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>



Combining: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>

Combining: t8: ch = BasicBlock< 0x16b38288e98>

Combining: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16

Combining: t6: i16 = add t4, Constant:i16<1>

Combining: t5: i16 = Constant<1>

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Combining: t3: i16 = undef

Combining: t1: i16 = FrameIndex<1>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.34 'main:'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
      t6: i16 = add t4, Constant:i16<1>
    t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
  t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>



Legalizing node: t8: ch = BasicBlock< 0x16b38288e98>
Analyzing result type: ch
Legal result type
Legally typed node: t8: ch = BasicBlock< 0x16b38288e98>

Legalizing node: t5: i16 = Constant<1>
Analyzing result type: i16
Legal result type
Legally typed node: t5: i16 = Constant<1>

Legalizing node: t3: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t3: i16 = undef

Legalizing node: t1: i16 = FrameIndex<1>
Analyzing result type: i16
Legal result type
Legally typed node: t1: i16 = FrameIndex<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Analyzing result type: i16
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing node: t6: i16 = add t4, Constant:i16<1>
Analyzing result type: i16
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t5: i16 = Constant<1>
Legal operand
Legally typed node: t6: i16 = add t4, Constant:i16<1>

Legalizing node: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t6: i16 = add t4, Constant:i16<1>
Legal operand
Analyzing operand: t1: i16 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i16 = undef
Legal operand
Legally typed node: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16

Legalizing node: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
Legal operand
Analyzing operand: t8: ch = BasicBlock< 0x16b38288e98>
Legal operand
Legally typed node: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.34 'main:'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
      t6: i16 = add t4, Constant:i16<1>
    t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
  t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>



Legalizing: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>
Legal node: nothing to do

Legalizing: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t6: i16 = add t4, Constant:i16<1>
Legal node: nothing to do

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Legalizing: t8: ch = BasicBlock< 0x16b38288e98>
Legal node: nothing to do

Legalizing: t5: i16 = Constant<1>
Legal node: nothing to do

Legalizing: t3: i16 = undef
Legal node: nothing to do

Legalizing: t1: i16 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.34 'main:'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
      t6: i16 = add t4, Constant:i16<1>
    t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
  t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>



Legalizing: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>
Legal node: nothing to do

Combining: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>

Legalizing: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16

Legalizing: t6: i16 = add t4, Constant:i16<1>
Legal node: nothing to do

Combining: t6: i16 = add t4, Constant:i16<1>

Legalizing: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Legalizing non-extending load operation

Combining: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

Legalizing: t8: ch = BasicBlock< 0x16b38288e98>
Legal node: nothing to do

Combining: t8: ch = BasicBlock< 0x16b38288e98>

Legalizing: t5: i16 = Constant<1>
Legal node: nothing to do

Combining: t5: i16 = Constant<1>

Legalizing: t3: i16 = undef
Legal node: nothing to do

Combining: t3: i16 = undef

Legalizing: t1: i16 = FrameIndex<1>
Legal node: nothing to do

Combining: t1: i16 = FrameIndex<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.34 'main:'
SelectionDAG has 9 nodes:
    t0: ch,glue = EntryToken
  t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
      t6: i16 = add t4, Constant:i16<1>
    t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
  t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>


===== Instruction selection begins: %bb.34 ''

ISEL: Starting selection on root node: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>
Selecting: t9: ch = br t7, BasicBlock:ch< 0x16b38288e98>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t9: ch = JMPI BasicBlock:ch< 0x16b38288e98>, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16
Selecting: t7: ch = store<(store (s16) into %ir.2)> t4:1, t6, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Skipped scope entry (due to false predicate) at index 387, continuing at 397
  Morphed node: t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> FrameIndex:i16<1>, t6, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i16 = add t4, Constant:i16<1>
Selecting: t6: i16 = add t4, Constant:i16<1>

ISEL: Starting pattern match
  Initial Opcode index to 586
Creating constant: t10: i16 = TargetConstant<1>
  Morphed node: t6: i16 = ADDI t4, TargetConstant:i16<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16
Selecting: t4: i16,ch = load<(dereferenceable load (s16) from %ir.2)> t0, FrameIndex:i16<1>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 219
  Match failed at index 225
  Continuing at 283
  Skipped scope entry (due to false predicate) at index 291, continuing at 301
  Morphed node: t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> FrameIndex:i16<1>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = BasicBlock< 0x16b38288e98>
Selecting: t8: ch = BasicBlock< 0x16b38288e98>


ISEL: Starting selection on root node: t1: i16 = FrameIndex<1>
Selecting: t1: i16 = FrameIndex<1>

ISEL: Starting pattern match
  Initial Opcode index to 193
Creating constant: t12: i16 = TargetConstant<0>
  Morphed node: t1: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.34 'main:'
SelectionDAG has 10 nodes:
  t1: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>
    t0: ch,glue = EntryToken
  t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t1, t0
      t6: i16 = ADDI t4, TargetConstant:i16<1>
    t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t1, t6, t4:1
  t9: ch = JMPI BasicBlock:ch< 0x16b38288e98>, t7


********** List Scheduling %bb.34 '' **********
SU(0): t9: ch = JMPI BasicBlock:ch< 0x16b38288e98>, t7

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t1, t6, t4:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t1, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
SU(3): t6: i16 = ADDI t4, TargetConstant:i16<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(1): Data Latency=1
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = JMPI BasicBlock:ch< 0x16b38288e98>, t7


*** Scheduling [0]: SU(0): t9: ch = JMPI BasicBlock:ch< 0x16b38288e98>, t7


Examining Available:
Height 1: SU(1): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t1, t6, t4:1


*** Scheduling [1]: SU(1): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t1, t6, t4:1


Examining Available:
Height 2: SU(3): t6: i16 = ADDI t4, TargetConstant:i16<1>


*** Scheduling [2]: SU(3): t6: i16 = ADDI t4, TargetConstant:i16<1>


Examining Available:
Height 3: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t1, t0


*** Scheduling [3]: SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t1, t0


Examining Available:
Height 4: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>


*** Scheduling [4]: SU(4): t1: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

*** Final schedule ***
SU(4): t1: i16 = ADDI TargetFrameIndex:i16<1>, TargetConstant:i16<0>

SU(2): t4: i16,ch = LOAD16R<Mem:(dereferenceable load (s16) from %ir.2)> t1, t0

SU(3): t6: i16 = ADDI t4, TargetConstant:i16<1>

SU(1): t7: ch = STORE16R<Mem:(store (s16) into %ir.2)> t1, t6, t4:1

SU(0): t9: ch = JMPI BasicBlock:ch< 0x16b38288e98>, t7


Total amount of phi nodes to update: 0
Creating constant: t1: i8 = Constant<0>
Creating constant: t3: i16 = Constant<0>
Creating new node: t4: i16 = undef
Creating new node: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16
Creating new node: t7: ch = br t5, BasicBlock:ch< 0x16b38289128>

Initial selection DAG: %bb.35 'main:'
SelectionDAG has 8 nodes:
  t3: i16 = Constant<0>
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38289128>



Combining: t7: ch = br t5, BasicBlock:ch< 0x16b38289128>

Combining: t6: ch = BasicBlock< 0x16b38289128>

Combining: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<2>

Combining: t1: i8 = Constant<0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.35 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t5, BasicBlock:ch< 0x16b38289128>



Legalizing node: t6: ch = BasicBlock< 0x16b38289128>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock< 0x16b38289128>

Legalizing node: t4: i16 = undef
Analyzing result type: i16
Legal result type
Legally typed node: t4: i16 = undef

Legalizing node: t2: i16 = FrameIndex<2>
Analyzing result type: i16
Legal result type
Legally typed node: t2: i16 = FrameIndex<2>

Legalizing node: t1: i8 = Constant<0>
Analyzing result type: i8
Promote integer result: t1: i8 = Constant<0>
Creating constant: t8: i16 = Constant<0>

Legalizing node: t8: i16 = Constant<0>
Analyzing result type: i16
Legal result type
Legally typed node: t8: i16 = Constant<0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: i8 = Constant<0>
Promote integer operand: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16
Creating new node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
Replacing: t5: ch = store<(store (s8) into %ir.3)> t0, Constant:i8<0>, FrameIndex:i16<2>, undef:i16
     with: t9: ch = store<(store (s8) into %ir.<badref>), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16

Legalizing node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t8: i16 = Constant<0>
Legal operand
Analyzing operand: t2: i16 = FrameIndex<2>
Legal operand
Analyzing operand: t4: i16 = undef
Legal operand
Legally typed node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16

Legalizing node: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
Legal operand
Analyzing operand: t6: ch = BasicBlock< 0x16b38289128>
Legal operand
Legally typed node: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.35 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>



Combining: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16

Combining: t8: i16 = Constant<0>

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

Combining: t6: ch = BasicBlock< 0x16b38289128>

Combining: t4: i16 = undef

Combining: t2: i16 = FrameIndex<2>

Combining: t0: ch,glue = EntryToken

Optimized type-legalized selection DAG: %bb.35 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Legal node: nothing to do

Legalizing: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
Legalizing truncating store operations

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock< 0x16b38289128>
Legal node: nothing to do

Legalizing: t4: i16 = undef
Legal node: nothing to do

Legalizing: t2: i16 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.35 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>



Legalizing: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Legal node: nothing to do

Combining: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

Legalizing: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
Legalizing truncating store operations

Combining: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16

Legalizing: t8: i16 = Constant<0>
Legal node: nothing to do

Combining: t8: i16 = Constant<0>

Legalizing: t6: ch = BasicBlock< 0x16b38289128>
Legal node: nothing to do

Combining: t6: ch = BasicBlock< 0x16b38289128>

Legalizing: t4: i16 = undef
Legal node: nothing to do

Combining: t4: i16 = undef

Legalizing: t2: i16 = FrameIndex<2>
Legal node: nothing to do

Combining: t2: i16 = FrameIndex<2>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.35 'main:'
SelectionDAG has 7 nodes:
      t0: ch,glue = EntryToken
    t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
  t7: ch = br t9, BasicBlock:ch< 0x16b38289128>


===== Instruction selection begins: %bb.35 ''

ISEL: Starting selection on root node: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>
Selecting: t7: ch = br t9, BasicBlock:ch< 0x16b38289128>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16
Selecting: t9: ch = store<(store (s8) into %ir.3), trunc to i8> t0, Constant:i16<0>, FrameIndex:i16<2>, undef:i16

ISEL: Starting pattern match
  Initial Opcode index to 340
  Match failed at index 349
  Continuing at 381
  Morphed node: t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> FrameIndex:i16<2>, Constant:i16<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i16 = Constant<0>
Selecting: t8: i16 = Constant<0>

ISEL: Starting pattern match
  Initial Opcode index to 890
Creating constant: t10: i16 = TargetConstant<0>
  Morphed node: t8: i16 = MOVI TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = BasicBlock< 0x16b38289128>
Selecting: t6: ch = BasicBlock< 0x16b38289128>


ISEL: Starting selection on root node: t2: i16 = FrameIndex<2>
Selecting: t2: i16 = FrameIndex<2>

ISEL: Starting pattern match
  Initial Opcode index to 193
  Morphed node: t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.35 'main:'
SelectionDAG has 8 nodes:
      t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>
      t8: i16 = MOVI TargetConstant:i16<0>
      t0: ch,glue = EntryToken
    t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0
  t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


********** List Scheduling %bb.35 '' **********
SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t8: i16 = MOVI TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


*** Scheduling [0]: SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


Examining Available:
Height 1: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0


*** Scheduling [1]: SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0


Examining Available:
Height 2: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [2]: SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>


Examining Available:
Height 2: SU(2): t8: i16 = MOVI TargetConstant:i16<0>


*** Scheduling [3]: SU(2): t8: i16 = MOVI TargetConstant:i16<0>

*** Final schedule ***
SU(2): t8: i16 = MOVI TargetConstant:i16<0>

SU(3): t2: i16 = ADDI TargetFrameIndex:i16<2>, TargetConstant:i16<0>

SU(1): t9: ch = STORE8R<Mem:(store (s8) into %ir.3)> t2, t8, t0

SU(0): t7: ch = JMPI BasicBlock:ch< 0x16b38289128>, t9


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>

Initial selection DAG: %bb.37 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>



Combining: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>

Combining: t1: ch = BasicBlock< 0x16b382819c0>

Combining: t0: ch,glue = EntryToken

Optimized lowered selection DAG: %bb.37 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>



Legalizing node: t1: ch = BasicBlock< 0x16b382819c0>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock< 0x16b382819c0>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock< 0x16b382819c0>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.37 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock< 0x16b382819c0>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalized selection DAG: %bb.37 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>



Legalizing: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>

Legalizing: t1: ch = BasicBlock< 0x16b382819c0>
Legal node: nothing to do

Combining: t1: ch = BasicBlock< 0x16b382819c0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken

Optimized legalized selection DAG: %bb.37 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>


===== Instruction selection begins: %bb.37 ''

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>
Selecting: t2: ch = br t0, BasicBlock:ch< 0x16b382819c0>

ISEL: Starting pattern match
  Initial Opcode index to 914
  Morphed node: t2: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock< 0x16b382819c0>
Selecting: t1: ch = BasicBlock< 0x16b382819c0>


ISEL: Starting selection on root node: t0: ch,glue = EntryToken
Selecting: t0: ch,glue = EntryToken


===== Instruction selection ends:

Selected selection DAG: %bb.37 'main:'
SelectionDAG has 3 nodes:
    t0: ch,glue = EntryToken
  t2: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t0


********** List Scheduling %bb.37 '' **********
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t0


*** Scheduling [0]: SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t0

*** Final schedule ***
SU(0): t2: ch = JMPI BasicBlock:ch< 0x16b382819c0>, t0


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=2, align=2, at location [SP]
  fi#2: size=1, align=1, at location [SP]
  fi#3: size=2, align=2, at location [SP]
  fi#4: size=4, align=4, at location [SP]
  fi#5: size=2, align=2, at location [SP]

bb.0 (%ir-block.0):
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %0:gpr = MOVI 0, implicit $flags
  %1:gpr = ADDI %stack.0, 0
  STORE16R %1:gpr, %0:gpr :: (store (s16) into %ir.1, align 4)
  %2:gpr = disjoint ORI %1:gpr, 2
  STORE16R killed %2:gpr, %0:gpr :: (store (s16) into %ir.1 + 2, basealign 4)
  %3:gpr = ADDI %stack.1, 0
  STORE16R killed %3:gpr, %0:gpr :: (store (s16) into %ir.2)
  %4:gpr = MOVI 1, implicit $flags
  %5:gpr = ADDI %stack.2, 0
  STORE8R killed %5:gpr, killed %4:gpr :: (store (s8) into %ir.3)
  JMPI %bb.1, implicit $flags

bb.1 (%ir-block.7):
; predecessors: %bb.0, %bb.37
  successors: %bb.2, %bb.36

  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  %6:gpr = COPY $r1
  %7:gpr = ADDI %stack.3, 0
  STORE16R %7:gpr, %6:gpr :: (store (s16) into %ir.4)
  %8:gpr = LOAD16R %7:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %8:gpr, 32, implicit-def $flags
  JEI %bb.36, implicit $flags
  JMPI %bb.2, implicit $flags

bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.3, %bb.35

  %11:gpr = ADDI %stack.2, 0
  %12:gpr = LOAD8R killed %11:gpr :: (dereferenceable load (s8) from %ir.3)
  %13:gpr = ANDI killed %12:gpr, 255
  CMPI killed %13:gpr, 0, implicit-def $flags
  JEI %bb.35, implicit $flags
  JMPI %bb.3, implicit $flags

bb.3 (%ir-block.15):
; predecessors: %bb.2
  successors: %bb.4, %bb.6

  %14:gpr = ADDI %stack.3, 0
  %15:gpr = LOAD16R killed %14:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %15:gpr, 48, implicit-def $flags
  JLI %bb.6, implicit $flags
  JMPI %bb.4, implicit $flags

bb.4 (%ir-block.19):
; predecessors: %bb.3
  successors: %bb.5, %bb.6

  %16:gpr = ADDI %stack.3, 0
  %17:gpr = LOAD16R killed %16:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %17:gpr, 57, implicit-def $flags
  JGI %bb.6, implicit $flags
  JMPI %bb.5, implicit $flags

bb.5 (%ir-block.23):
; predecessors: %bb.4
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  %126:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %127:gpr = ADDI %stack.1, 0
  %128:gpr = LOAD16R %127:gpr :: (dereferenceable load (s16) from %ir.2)
  %129:gpr = nuw nsw LSLI killed %128:gpr, 3
  %130:gpr = nuw ADDR killed %126:gpr, killed %129:gpr
  %131:gpr = MOVI 1, implicit $flags
  STORE8R killed %130:gpr, killed %131:gpr :: (store (s8) into %ir.28, align 4)
  %132:gpr = ADDI %stack.3, 0
  %133:gpr = LOAD16R killed %132:gpr :: (dereferenceable load (s16) from %ir.4)
  %134:gpr = ADDI killed %133:gpr, -48
  %135:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %136:gpr = LOAD16R %127:gpr :: (dereferenceable load (s16) from %ir.2)
  %137:gpr = nuw nsw LSLI killed %136:gpr, 3
  %138:gpr = nuw ADDR killed %135:gpr, killed %137:gpr
  %139:gpr = nuw ADDI killed %138:gpr, 4
  STORE16R killed %139:gpr, killed %134:gpr :: (store (s16) into %ir.37, align 4)
  JMPI %bb.34, implicit $flags

bb.6 (%ir-block.38):
; predecessors: %bb.3, %bb.4
  successors: %bb.7, %bb.33

  %18:gpr = ADDI %stack.3, 0
  %19:gpr = LOAD16R killed %18:gpr :: (dereferenceable load (s16) from %ir.4)
  $r1 = COPY %19:gpr
  SymphonyCallI @is_op, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1, implicit-def $r1
  %20:gpr = COPY $r1
  CMPI %20:gpr, 0, implicit-def $flags
  JEI %bb.33, implicit $flags
  JMPI %bb.7, implicit $flags

bb.7 (%ir-block.42):
; predecessors: %bb.6
  successors: %bb.8, %bb.9

  %21:gpr = ADDI %stack.3, 0
  %22:gpr = LOAD16R killed %21:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %22:gpr, 43, implicit-def $flags
  JNEI %bb.9, implicit $flags
  JMPI %bb.8, implicit $flags

bb.8 (%ir-block.46):
; predecessors: %bb.7
  successors: %bb.27(0x80000000); %bb.27(100.00%)

  %60:gpr = MOVI 0, implicit $flags
  %61:gpr = ADDI %stack.4, 0
  STORE16R %61:gpr, %60:gpr :: (store (s16) into %ir.5, align 4)
  %62:gpr = disjoint ORI %61:gpr, 2
  STORE16R killed %62:gpr, %60:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.27, implicit $flags

bb.9 (%ir-block.47):
; predecessors: %bb.7
  successors: %bb.10, %bb.11

  %23:gpr = ADDI %stack.3, 0
  %24:gpr = LOAD16R killed %23:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %24:gpr, 45, implicit-def $flags
  JNEI %bb.11, implicit $flags
  JMPI %bb.10, implicit $flags

bb.10 (%ir-block.51):
; predecessors: %bb.9
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  %56:gpr = MOVI 0, implicit $flags
  %57:gpr = ADDI %stack.4, 0
  STORE16R %57:gpr, killed %56:gpr :: (store (s16) into %ir.5, align 4)
  %58:gpr = disjoint ORI %57:gpr, 2
  %59:gpr = MOVI 1, implicit $flags
  STORE16R killed %58:gpr, killed %59:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.26, implicit $flags

bb.11 (%ir-block.52):
; predecessors: %bb.9
  successors: %bb.12, %bb.13

  %25:gpr = ADDI %stack.3, 0
  %26:gpr = LOAD16R killed %25:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %26:gpr, 124, implicit-def $flags
  JNEI %bb.13, implicit $flags
  JMPI %bb.12, implicit $flags

bb.12 (%ir-block.56):
; predecessors: %bb.11
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  %52:gpr = MOVI 0, implicit $flags
  %53:gpr = ADDI %stack.4, 0
  STORE16R %53:gpr, killed %52:gpr :: (store (s16) into %ir.5, align 4)
  %54:gpr = disjoint ORI %53:gpr, 2
  %55:gpr = MOVI 2, implicit $flags
  STORE16R killed %54:gpr, killed %55:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.25, implicit $flags

bb.13 (%ir-block.57):
; predecessors: %bb.11
  successors: %bb.14, %bb.15

  %27:gpr = ADDI %stack.3, 0
  %28:gpr = LOAD16R killed %27:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %28:gpr, 38, implicit-def $flags
  JNEI %bb.15, implicit $flags
  JMPI %bb.14, implicit $flags

bb.14 (%ir-block.61):
; predecessors: %bb.13
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  %49:gpr = MOVI 0, implicit $flags
  %50:gpr = ADDI %stack.4, 0
  STORE16R %50:gpr, %49:gpr :: (store (s16) into %ir.5, align 4)
  %51:gpr = disjoint ORI %50:gpr, 2
  STORE16R killed %51:gpr, %49:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.24, implicit $flags

bb.15 (%ir-block.62):
; predecessors: %bb.13
  successors: %bb.16, %bb.17

  %29:gpr = ADDI %stack.3, 0
  %30:gpr = LOAD16R killed %29:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %30:gpr, 94, implicit-def $flags
  JNEI %bb.17, implicit $flags
  JMPI %bb.16, implicit $flags

bb.16 (%ir-block.66):
; predecessors: %bb.15
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  %45:gpr = MOVI 0, implicit $flags
  %46:gpr = ADDI %stack.4, 0
  STORE16R %46:gpr, killed %45:gpr :: (store (s16) into %ir.5, align 4)
  %47:gpr = disjoint ORI %46:gpr, 2
  %48:gpr = MOVI 4, implicit $flags
  STORE16R killed %47:gpr, killed %48:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.23, implicit $flags

bb.17 (%ir-block.67):
; predecessors: %bb.15
  successors: %bb.18, %bb.19

  %31:gpr = ADDI %stack.3, 0
  %32:gpr = LOAD16R killed %31:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %32:gpr, 60, implicit-def $flags
  JNEI %bb.19, implicit $flags
  JMPI %bb.18, implicit $flags

bb.18 (%ir-block.71):
; predecessors: %bb.17
  successors: %bb.22(0x80000000); %bb.22(100.00%)

  %40:gpr = MOVI 0, implicit $flags
  %41:gpr = ADDI %stack.4, 0
  STORE16R %41:gpr, killed %40:gpr :: (store (s16) into %ir.5, align 4)
  %42:gpr = disjoint ORI %41:gpr, 2
  %43:gpr = MOVI 5, implicit $flags
  STORE16R killed %42:gpr, killed %43:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  %44:gpr = COPY $r1
  JMPI %bb.22, implicit $flags

bb.19 (%ir-block.73):
; predecessors: %bb.17
  successors: %bb.20, %bb.21

  %33:gpr = ADDI %stack.3, 0
  %34:gpr = LOAD16R killed %33:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %34:gpr, 62, implicit-def $flags
  JNEI %bb.21, implicit $flags
  JMPI %bb.20, implicit $flags

bb.20 (%ir-block.77):
; predecessors: %bb.19
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  %35:gpr = MOVI 0, implicit $flags
  %36:gpr = ADDI %stack.4, 0
  STORE16R %36:gpr, killed %35:gpr :: (store (s16) into %ir.5, align 4)
  %37:gpr = disjoint ORI %36:gpr, 2
  %38:gpr = MOVI 6, implicit $flags
  STORE16R killed %37:gpr, killed %38:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  %39:gpr = COPY $r1
  JMPI %bb.21, implicit $flags

bb.21 (%ir-block.79):
; predecessors: %bb.19, %bb.20
  successors: %bb.22(0x80000000); %bb.22(100.00%)

  JMPI %bb.22, implicit $flags

bb.22 (%ir-block.80):
; predecessors: %bb.21, %bb.18
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  JMPI %bb.23, implicit $flags

bb.23 (%ir-block.81):
; predecessors: %bb.22, %bb.16
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  JMPI %bb.24, implicit $flags

bb.24 (%ir-block.82):
; predecessors: %bb.23, %bb.14
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  JMPI %bb.25, implicit $flags

bb.25 (%ir-block.83):
; predecessors: %bb.24, %bb.12
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  JMPI %bb.26, implicit $flags

bb.26 (%ir-block.84):
; predecessors: %bb.25, %bb.10
  successors: %bb.27(0x80000000); %bb.27(100.00%)

  JMPI %bb.27, implicit $flags

bb.27 (%ir-block.85):
; predecessors: %bb.26, %bb.8
  successors: %bb.28, %bb.32

  %63:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %64:gpr = ADDI %stack.1, 0
  %65:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
  %66:gpr = nuw nsw LSLI killed %65:gpr, 3
  %67:gpr = nuw ADDR killed %63:gpr, killed %66:gpr
  %68:gpr = MOVI 0, implicit $flags
  STORE8R killed %67:gpr, killed %68:gpr :: (store (s8) into %ir.90, align 4)
  %69:gpr = ADDI %stack.4, 0
  %70:gpr = LOAD16R %69:gpr :: (dereferenceable load (s16) from %ir.5, align 4)
  %71:gpr = disjoint ORI %69:gpr, 2
  %72:gpr = LOAD16R killed %71:gpr :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
  %73:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %74:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
  %75:gpr = nuw nsw LSLI killed %74:gpr, 3
  %76:gpr = nuw ADDR killed %73:gpr, killed %75:gpr
  %77:gpr = nuw ADDI %76:gpr, 4
  %78:gpr = nuw ADDI %76:gpr, 6
  STORE16R killed %78:gpr, killed %72:gpr :: (store (s16) into %ir.96 + 2, basealign 4)
  STORE16R killed %77:gpr, killed %70:gpr :: (store (s16) into %ir.96, align 4)
  %79:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
  CMPI killed %79:gpr, 2, implicit-def $flags
  JLI %bb.32, implicit $flags
  JMPI %bb.28, implicit $flags

bb.28 (%ir-block.100):
; predecessors: %bb.27
  successors: %bb.29, %bb.31

  %80:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %81:gpr = ADDI %stack.1, 0
  %82:gpr = LOAD16R killed %81:gpr :: (dereferenceable load (s16) from %ir.2)
  %83:gpr = LSLI killed %82:gpr, 3
  %84:gpr = ADDR killed %83:gpr, killed %80:gpr
  %85:gpr = ADDI killed %84:gpr, -16
  %86:gpr = LOAD8R killed %85:gpr :: (load (s8) from %ir.106, align 4)
  %87:gpr = LSLI killed %86:gpr, 8
  %88:gpr = ASRI %87:gpr, 15
  %89:gpr = ASRI %87:gpr, 8
  %90:gpr = ORR killed %89:gpr, killed %88:gpr
  CMPI killed %90:gpr, 0, implicit-def $flags
  JEI %bb.31, implicit $flags
  JMPI %bb.29, implicit $flags

bb.29 (%ir-block.110):
; predecessors: %bb.28
  successors: %bb.30, %bb.31

  %91:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %92:gpr = ADDI %stack.1, 0
  %93:gpr = LOAD16R killed %92:gpr :: (dereferenceable load (s16) from %ir.2)
  %94:gpr = LSLI killed %93:gpr, 3
  %95:gpr = ADDR killed %94:gpr, killed %91:gpr
  %96:gpr = ADDI killed %95:gpr, -16
  %97:gpr = LOAD8R killed %96:gpr :: (load (s8) from %ir.116, align 4)
  %98:gpr = LSLI killed %97:gpr, 8
  %99:gpr = ASRI %98:gpr, 15
  %100:gpr = ASRI %98:gpr, 8
  %101:gpr = ORR killed %100:gpr, killed %99:gpr
  CMPI killed %101:gpr, 0, implicit-def $flags
  JEI %bb.31, implicit $flags
  JMPI %bb.30, implicit $flags

bb.30 (%ir-block.120):
; predecessors: %bb.29
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  %102:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %103:gpr = ADDI %stack.1, 0
  %104:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
  %105:gpr = LSLI killed %104:gpr, 3
  %106:gpr = ADDR killed %102:gpr, killed %105:gpr
  %107:gpr = nuw ADDI %106:gpr, 4
  %108:gpr = nuw ADDI %106:gpr, 6
  %109:gpr = LOAD16R killed %108:gpr :: (load (s16) from %ir.125 + 2, basealign 4)
  %110:gpr = LOAD16R killed %107:gpr :: (load (s16) from %ir.125, align 4)
  %111:gpr = ADDI %106:gpr, -12
  %112:gpr = LOAD16R killed %111:gpr :: (load (s16) from %ir.132, align 4)
  %113:gpr = ADDI %106:gpr, -4
  %114:gpr = LOAD16R killed %113:gpr :: (load (s16) from %ir.139, align 4)
  $r1 = COPY %110:gpr
  $r2 = COPY %109:gpr
  $r3 = COPY %112:gpr
  $r4 = COPY %114:gpr
  SymphonyCallI @do_calc, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit-def $r1
  %115:gpr = COPY $r1
  %116:gpr = ADDI %stack.5, 0
  STORE16R %116:gpr, %115:gpr :: (store (s16) into %ir.6)
  %117:gpr = LOAD16R %116:gpr :: (dereferenceable load (s16) from %ir.6)
  $r1 = COPY %117:gpr
  SymphonyCallI @output, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1
  %118:gpr = LOAD16R %116:gpr :: (dereferenceable load (s16) from %ir.6)
  %119:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %120:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
  %121:gpr = LSLI killed %120:gpr, 3
  %122:gpr = ADDR killed %121:gpr, killed %119:gpr
  %123:gpr = ADDI killed %122:gpr, -12
  STORE16R killed %123:gpr, killed %118:gpr :: (store (s16) into %ir.149, align 4)
  %124:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
  %125:gpr = ADDI killed %124:gpr, -2
  STORE16R %103:gpr, killed %125:gpr :: (store (s16) into %ir.2)
  JMPI %bb.31, implicit $flags

bb.31 (%ir-block.154):
; predecessors: %bb.28, %bb.29, %bb.30
  successors: %bb.32(0x80000000); %bb.32(100.00%)

  JMPI %bb.32, implicit $flags

bb.32 (%ir-block.155):
; predecessors: %bb.27, %bb.31
  successors: %bb.33(0x80000000); %bb.33(100.00%)

  JMPI %bb.33, implicit $flags

bb.33 (%ir-block.156):
; predecessors: %bb.6, %bb.32
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  JMPI %bb.34, implicit $flags

bb.34 (%ir-block.157):
; predecessors: %bb.33, %bb.5
  successors: %bb.35(0x80000000); %bb.35(100.00%)

  %140:gpr = ADDI %stack.1, 0
  %141:gpr = LOAD16R %140:gpr :: (dereferenceable load (s16) from %ir.2)
  %142:gpr = ADDI killed %141:gpr, 1
  STORE16R %140:gpr, killed %142:gpr :: (store (s16) into %ir.2)
  JMPI %bb.35, implicit $flags

bb.35 (%ir-block.160):
; predecessors: %bb.2, %bb.34
  successors: %bb.37(0x80000000); %bb.37(100.00%)

  %143:gpr = MOVI 0, implicit $flags
  %144:gpr = ADDI %stack.2, 0
  STORE8R killed %144:gpr, killed %143:gpr :: (store (s8) into %ir.3)
  JMPI %bb.37, implicit $flags

bb.36 (%ir-block.161):
; predecessors: %bb.1
  successors: %bb.37(0x80000000); %bb.37(100.00%)

  %9:gpr = MOVI 1, implicit $flags
  %10:gpr = ADDI %stack.2, 0
  STORE8R killed %10:gpr, killed %9:gpr :: (store (s8) into %ir.3)
  JMPI %bb.37, implicit $flags

bb.37 (%ir-block.162):
; predecessors: %bb.36, %bb.35
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  JMPI %bb.1, implicit $flags

# End machine code for function main.

Skipping pass 'Two-Address instruction pass' on function main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
********** FAST REGISTER ALLOCATION **********
********** Function: main

Allocating bb.0 (%ir-block.0):
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %0:gpr = MOVI 0, implicit $flags
  %1:gpr = ADDI %stack.0, 0
  STORE16R %1:gpr, %0:gpr :: (store (s16) into %ir.1, align 4)
  %2:gpr = disjoint ORI %1:gpr, 2
  STORE16R killed %2:gpr, %0:gpr :: (store (s16) into %ir.1 + 2, basealign 4)
  %3:gpr = ADDI %stack.1, 0
  STORE16R killed %3:gpr, %0:gpr :: (store (s16) into %ir.2)
  %4:gpr = MOVI 1, implicit $flags
  %5:gpr = ADDI %stack.2, 0
  STORE8R killed %5:gpr, killed %4:gpr :: (store (s8) into %ir.3)
  JMPI %bb.1, implicit $flags

>> JMPI %bb.1, implicit $flags
Regs:
<< JMPI %bb.1, implicit $flags

>> STORE8R killed %5:gpr, killed %4:gpr :: (store (s8) into %ir.3)
Regs:
Search register for %5 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %5 to $r1
Search register for %4 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %4 to $r2
<< STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.3)

>> %5:gpr = ADDI %stack.2, 0
Regs: R1=%5 R2=%4
In def of %5 use existing assignment to $r1
Freeing $r1: %5
<< $r1 = ADDI %stack.2, 0

>> %4:gpr = MOVI 1, implicit $flags
Regs: R2=%4
In def of %4 use existing assignment to $r2
Freeing $r2: %4
<< $r2 = MOVI 1, implicit $flags

>> STORE16R killed %3:gpr, %0:gpr :: (store (s16) into %ir.2)
Regs:
Search register for %3 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %3 to $r1
Search register for %0 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %0 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)

>> %3:gpr = ADDI %stack.1, 0
Regs: R1=%3 R2=%0
In def of %3 use existing assignment to $r1
Freeing $r1: %3
<< $r1 = ADDI %stack.1, 0

>> STORE16R killed %2:gpr, %0:gpr :: (store (s16) into %ir.1 + 2, basealign 4)
Regs: R2=%0
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %2 to $r1
<< STORE16R killed $r1, $r2 :: (store (s16) into %ir.1 + 2, basealign 4)

>> %2:gpr = disjoint ORI %1:gpr, 2
Regs: R1=%2 R2=%0
In def of %2 use existing assignment to $r1
Freeing $r1: %2
Search register for %1 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %1 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %1:gpr, %0:gpr :: (store (s16) into %ir.1, align 4)
Regs: R1=%1 R2=%0
<< STORE16R $r1, $r2 :: (store (s16) into %ir.1, align 4)

>> %1:gpr = ADDI %stack.0, 0
Regs: R1=%1 R2=%0
In def of %1 use existing assignment to $r1
Freeing $r1: %1
<< $r1 = ADDI %stack.0, 0

>> %0:gpr = MOVI 0, implicit $flags
Regs: R2=%0
In def of %0 use existing assignment to $r2
Freeing $r2: %0
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.0 (%ir-block.0):
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.0, 0
  STORE16R $r1, $r2 :: (store (s16) into %ir.1, align 4)
  $r1 = disjoint ORI killed $r1, 2
  STORE16R killed $r1, $r2 :: (store (s16) into %ir.1 + 2, basealign 4)
  $r1 = ADDI %stack.1, 0
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)
  $r2 = MOVI 1, implicit $flags
  $r1 = ADDI %stack.2, 0
  STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.3)
  JMPI %bb.1, implicit $flags

Allocating bb.1 (%ir-block.7):
; predecessors: %bb.0, %bb.37
  successors: %bb.2, %bb.36

  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  %6:gpr = COPY $r1
  %7:gpr = ADDI %stack.3, 0
  STORE16R %7:gpr, %6:gpr :: (store (s16) into %ir.4)
  %8:gpr = LOAD16R %7:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %8:gpr, 32, implicit-def $flags
  JEI %bb.36, implicit $flags
  JMPI %bb.2, implicit $flags

>> JMPI %bb.2, implicit $flags
Regs:
<< JMPI %bb.2, implicit $flags

>> JEI %bb.36, implicit $flags
Regs:
<< JEI %bb.36, implicit $flags

>> CMPI killed %8:gpr, 32, implicit-def $flags
Regs:
Search register for %8 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %8 to $r1
<< CMPI killed $r1, 32, implicit-def $flags

>> %8:gpr = LOAD16R %7:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%8
In def of %8 use existing assignment to $r1
Freeing $r1: %8
Search register for %7 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %7 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> STORE16R %7:gpr, %6:gpr :: (store (s16) into %ir.4)
Regs: R1=%7
Search register for %6 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %6 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.4)

>> %7:gpr = ADDI %stack.3, 0
Regs: R1=%7 R2=%6
In def of %7 use existing assignment to $r1
Freeing $r1: %7
<< $r1 = ADDI %stack.3, 0

>> %6:gpr = COPY $r1
Regs: R2=%6
In def of %6 use existing assignment to $r2
Freeing $r2: %6
<< $r2 = COPY killed $r1

>> SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
Regs: R1[P]
Freeing $r1:
<< SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
Begin Regs:
Loading live registers at begin of block.
bb.1 (%ir-block.7):
; predecessors: %bb.0, %bb.37
  successors: %bb.2, %bb.36

  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  $r2 = COPY killed $r1
  $r1 = ADDI %stack.3, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.4)
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 32, implicit-def $flags
  JEI %bb.36, implicit $flags
  JMPI %bb.2, implicit $flags

Allocating bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.3, %bb.35

  %11:gpr = ADDI %stack.2, 0
  %12:gpr = LOAD8R killed %11:gpr :: (dereferenceable load (s8) from %ir.3)
  %13:gpr = ANDI killed %12:gpr, 255
  CMPI killed %13:gpr, 0, implicit-def $flags
  JEI %bb.35, implicit $flags
  JMPI %bb.3, implicit $flags

>> JMPI %bb.3, implicit $flags
Regs:
<< JMPI %bb.3, implicit $flags

>> JEI %bb.35, implicit $flags
Regs:
<< JEI %bb.35, implicit $flags

>> CMPI killed %13:gpr, 0, implicit-def $flags
Regs:
Search register for %13 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %13 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %13:gpr = ANDI killed %12:gpr, 255
Regs: R1=%13
In def of %13 use existing assignment to $r1
Freeing $r1: %13
Search register for %12 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %12 to $r1
<< $r1 = ANDI killed $r1, 255

>> %12:gpr = LOAD8R killed %11:gpr :: (dereferenceable load (s8) from %ir.3)
Regs: R1=%12
In def of %12 use existing assignment to $r1
Freeing $r1: %12
Search register for %11 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %11 to $r1
<< $r1 = LOAD8R killed $r1 :: (dereferenceable load (s8) from %ir.3)

>> %11:gpr = ADDI %stack.2, 0
Regs: R1=%11
In def of %11 use existing assignment to $r1
Freeing $r1: %11
<< $r1 = ADDI %stack.2, 0
Begin Regs:
Loading live registers at begin of block.
bb.2 (%ir-block.12):
; predecessors: %bb.1
  successors: %bb.3, %bb.35

  $r1 = ADDI %stack.2, 0
  $r1 = LOAD8R killed $r1 :: (dereferenceable load (s8) from %ir.3)
  $r1 = ANDI killed $r1, 255
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.35, implicit $flags
  JMPI %bb.3, implicit $flags

Allocating bb.3 (%ir-block.15):
; predecessors: %bb.2
  successors: %bb.4, %bb.6

  %14:gpr = ADDI %stack.3, 0
  %15:gpr = LOAD16R killed %14:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %15:gpr, 48, implicit-def $flags
  JLI %bb.6, implicit $flags
  JMPI %bb.4, implicit $flags

>> JMPI %bb.4, implicit $flags
Regs:
<< JMPI %bb.4, implicit $flags

>> JLI %bb.6, implicit $flags
Regs:
<< JLI %bb.6, implicit $flags

>> CMPI killed %15:gpr, 48, implicit-def $flags
Regs:
Search register for %15 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %15 to $r1
<< CMPI killed $r1, 48, implicit-def $flags

>> %15:gpr = LOAD16R killed %14:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%15
In def of %15 use existing assignment to $r1
Freeing $r1: %15
Search register for %14 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %14 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %14:gpr = ADDI %stack.3, 0
Regs: R1=%14
In def of %14 use existing assignment to $r1
Freeing $r1: %14
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.3 (%ir-block.15):
; predecessors: %bb.2
  successors: %bb.4, %bb.6

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 48, implicit-def $flags
  JLI %bb.6, implicit $flags
  JMPI %bb.4, implicit $flags

Allocating bb.4 (%ir-block.19):
; predecessors: %bb.3
  successors: %bb.5, %bb.6

  %16:gpr = ADDI %stack.3, 0
  %17:gpr = LOAD16R killed %16:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %17:gpr, 57, implicit-def $flags
  JGI %bb.6, implicit $flags
  JMPI %bb.5, implicit $flags

>> JMPI %bb.5, implicit $flags
Regs:
<< JMPI %bb.5, implicit $flags

>> JGI %bb.6, implicit $flags
Regs:
<< JGI %bb.6, implicit $flags

>> CMPI killed %17:gpr, 57, implicit-def $flags
Regs:
Search register for %17 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %17 to $r1
<< CMPI killed $r1, 57, implicit-def $flags

>> %17:gpr = LOAD16R killed %16:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%17
In def of %17 use existing assignment to $r1
Freeing $r1: %17
Search register for %16 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %16 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %16:gpr = ADDI %stack.3, 0
Regs: R1=%16
In def of %16 use existing assignment to $r1
Freeing $r1: %16
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.4 (%ir-block.19):
; predecessors: %bb.3
  successors: %bb.5, %bb.6

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 57, implicit-def $flags
  JGI %bb.6, implicit $flags
  JMPI %bb.5, implicit $flags

Allocating bb.5 (%ir-block.23):
; predecessors: %bb.4
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  %126:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %127:gpr = ADDI %stack.1, 0
  %128:gpr = LOAD16R %127:gpr :: (dereferenceable load (s16) from %ir.2)
  %129:gpr = nuw nsw LSLI killed %128:gpr, 3
  %130:gpr = nuw ADDR killed %126:gpr, killed %129:gpr
  %131:gpr = MOVI 1, implicit $flags
  STORE8R killed %130:gpr, killed %131:gpr :: (store (s8) into %ir.28, align 4)
  %132:gpr = ADDI %stack.3, 0
  %133:gpr = LOAD16R killed %132:gpr :: (dereferenceable load (s16) from %ir.4)
  %134:gpr = ADDI killed %133:gpr, -48
  %135:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %136:gpr = LOAD16R %127:gpr :: (dereferenceable load (s16) from %ir.2)
  %137:gpr = nuw nsw LSLI killed %136:gpr, 3
  %138:gpr = nuw ADDR killed %135:gpr, killed %137:gpr
  %139:gpr = nuw ADDI killed %138:gpr, 4
  STORE16R killed %139:gpr, killed %134:gpr :: (store (s16) into %ir.37, align 4)
  JMPI %bb.34, implicit $flags

>> JMPI %bb.34, implicit $flags
Regs:
<< JMPI %bb.34, implicit $flags

>> STORE16R killed %139:gpr, killed %134:gpr :: (store (s16) into %ir.37, align 4)
Regs:
Search register for %139 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %139 to $r1
Search register for %134 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %134 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.37, align 4)

>> %139:gpr = nuw ADDI killed %138:gpr, 4
Regs: R1=%139 R2=%134
In def of %139 use existing assignment to $r1
Freeing $r1: %139
Search register for %138 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %138 to $r1
<< $r1 = nuw ADDI killed $r1, 4

>> %138:gpr = nuw ADDR killed %135:gpr, killed %137:gpr
Regs: R1=%138 R2=%134
In def of %138 use existing assignment to $r1
Freeing $r1: %138
Search register for %135 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %135 to $r1
Search register for %137 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 100 BestCost: 4294967295
	Register: $r3 Cost: 0 BestCost: 100
Assigning %137 to $r3
<< $r1 = nuw ADDR killed $r1, killed $r3

>> %137:gpr = nuw nsw LSLI killed %136:gpr, 3
Regs: R1=%135 R2=%134 R3=%137
In def of %137 use existing assignment to $r3
Freeing $r3: %137
Search register for %136 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 0 BestCost: 100
Assigning %136 to $r3
<< $r3 = nuw nsw LSLI killed $r3, 3

>> %136:gpr = LOAD16R %127:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%135 R2=%134 R3=%136
In def of %136 use existing assignment to $r3
Freeing $r3: %136
Search register for %127 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 0 BestCost: 100
Assigning %127 to $r3
<< $r3 = LOAD16R killed $r3 :: (dereferenceable load (s16) from %ir.2)

>> %135:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R1=%135 R2=%134 R3=%127
In def of %135 use existing assignment to $r1
Freeing $r1: %135
<< $r1 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)

>> %134:gpr = ADDI killed %133:gpr, -48
Regs: R2=%134 R3=%127
In def of %134 use existing assignment to $r2
Freeing $r2: %134
Search register for %133 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %133 to $r1
<< $r2 = ADDI killed $r1, -48

>> %133:gpr = LOAD16R killed %132:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%133 R3=%127
In def of %133 use existing assignment to $r1
Freeing $r1: %133
Search register for %132 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %132 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %132:gpr = ADDI %stack.3, 0
Regs: R1=%132 R3=%127
In def of %132 use existing assignment to $r1
Freeing $r1: %132
<< $r1 = ADDI %stack.3, 0

>> STORE8R killed %130:gpr, killed %131:gpr :: (store (s8) into %ir.28, align 4)
Regs: R3=%127
Search register for %130 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %130 to $r1
Search register for %131 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %131 to $r2
<< STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.28, align 4)

>> %131:gpr = MOVI 1, implicit $flags
Regs: R1=%130 R2=%131 R3=%127
In def of %131 use existing assignment to $r2
Freeing $r2: %131
<< $r2 = MOVI 1, implicit $flags

>> %130:gpr = nuw ADDR killed %126:gpr, killed %129:gpr
Regs: R1=%130 R3=%127
In def of %130 use existing assignment to $r1
Freeing $r1: %130
Search register for %126 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %126 to $r1
Search register for %129 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %129 to $r2
<< $r1 = nuw ADDR killed $r1, killed $r2

>> %129:gpr = nuw nsw LSLI killed %128:gpr, 3
Regs: R1=%126 R2=%129 R3=%127
In def of %129 use existing assignment to $r2
Freeing $r2: %129
Search register for %128 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %128 to $r2
<< $r2 = nuw nsw LSLI killed $r2, 3

>> %128:gpr = LOAD16R %127:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%126 R2=%128 R3=%127
In def of %128 use existing assignment to $r2
Freeing $r2: %128
<< $r2 = LOAD16R $r3 :: (dereferenceable load (s16) from %ir.2)

>> %127:gpr = ADDI %stack.1, 0
Regs: R1=%126 R3=%127
In def of %127 use existing assignment to $r3
Freeing $r3: %127
<< $r3 = ADDI %stack.1, 0

>> %126:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R1=%126
In def of %126 use existing assignment to $r1
Freeing $r1: %126
<< $r1 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Begin Regs:
Loading live registers at begin of block.
bb.5 (%ir-block.23):
; predecessors: %bb.4
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  $r1 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r3 = ADDI %stack.1, 0
  $r2 = LOAD16R $r3 :: (dereferenceable load (s16) from %ir.2)
  $r2 = nuw nsw LSLI killed $r2, 3
  $r1 = nuw ADDR killed $r1, killed $r2
  $r2 = MOVI 1, implicit $flags
  STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.28, align 4)
  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  $r2 = ADDI killed $r1, -48
  $r1 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r3 = LOAD16R killed $r3 :: (dereferenceable load (s16) from %ir.2)
  $r3 = nuw nsw LSLI killed $r3, 3
  $r1 = nuw ADDR killed $r1, killed $r3
  $r1 = nuw ADDI killed $r1, 4
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.37, align 4)
  JMPI %bb.34, implicit $flags

Allocating bb.6 (%ir-block.38):
; predecessors: %bb.3, %bb.4
  successors: %bb.7, %bb.33

  %18:gpr = ADDI %stack.3, 0
  %19:gpr = LOAD16R killed %18:gpr :: (dereferenceable load (s16) from %ir.4)
  $r1 = COPY %19:gpr
  SymphonyCallI @is_op, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1, implicit-def $r1
  %20:gpr = COPY $r1
  CMPI %20:gpr, 0, implicit-def $flags
  JEI %bb.33, implicit $flags
  JMPI %bb.7, implicit $flags

>> JMPI %bb.7, implicit $flags
Regs:
<< JMPI %bb.7, implicit $flags

>> JEI %bb.33, implicit $flags
Regs:
<< JEI %bb.33, implicit $flags

>> CMPI %20:gpr, 0, implicit-def $flags
Regs:
Search register for %20 in class GPR with hint $noreg
	Preferred Register 0: $r1
Assigning %20 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %20:gpr = COPY $r1
Regs: R1=%20
In def of %20 use existing assignment to $r1
Freeing $r1: %20
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> SymphonyCallI @is_op, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1, implicit-def $r1
Regs: R1[P]
Freeing $r1:
<< SymphonyCallI @is_op, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit killed $r1, implicit-def $r1

>> $r1 = COPY %19:gpr
Regs: R1[P]
Freeing $r1:
Search register for %19 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %19 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %19:gpr = LOAD16R killed %18:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%19
In def of %19 use existing assignment to $r1
Freeing $r1: %19
Search register for %18 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %18 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %18:gpr = ADDI %stack.3, 0
Regs: R1=%18
In def of %18 use existing assignment to $r1
Freeing $r1: %18
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.6 (%ir-block.38):
; predecessors: %bb.3, %bb.4
  successors: %bb.7, %bb.33

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  SymphonyCallI @is_op, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit killed $r1, implicit-def $r1
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.33, implicit $flags
  JMPI %bb.7, implicit $flags

Allocating bb.7 (%ir-block.42):
; predecessors: %bb.6
  successors: %bb.8, %bb.9

  %21:gpr = ADDI %stack.3, 0
  %22:gpr = LOAD16R killed %21:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %22:gpr, 43, implicit-def $flags
  JNEI %bb.9, implicit $flags
  JMPI %bb.8, implicit $flags

>> JMPI %bb.8, implicit $flags
Regs:
<< JMPI %bb.8, implicit $flags

>> JNEI %bb.9, implicit $flags
Regs:
<< JNEI %bb.9, implicit $flags

>> CMPI killed %22:gpr, 43, implicit-def $flags
Regs:
Search register for %22 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %22 to $r1
<< CMPI killed $r1, 43, implicit-def $flags

>> %22:gpr = LOAD16R killed %21:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%22
In def of %22 use existing assignment to $r1
Freeing $r1: %22
Search register for %21 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %21 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %21:gpr = ADDI %stack.3, 0
Regs: R1=%21
In def of %21 use existing assignment to $r1
Freeing $r1: %21
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.7 (%ir-block.42):
; predecessors: %bb.6
  successors: %bb.8, %bb.9

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 43, implicit-def $flags
  JNEI %bb.9, implicit $flags
  JMPI %bb.8, implicit $flags

Allocating bb.8 (%ir-block.46):
; predecessors: %bb.7
  successors: %bb.27(0x80000000); %bb.27(100.00%)

  %60:gpr = MOVI 0, implicit $flags
  %61:gpr = ADDI %stack.4, 0
  STORE16R %61:gpr, %60:gpr :: (store (s16) into %ir.5, align 4)
  %62:gpr = disjoint ORI %61:gpr, 2
  STORE16R killed %62:gpr, %60:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.27, implicit $flags

>> JMPI %bb.27, implicit $flags
Regs:
<< JMPI %bb.27, implicit $flags

>> STORE16R killed %62:gpr, %60:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %62 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %62 to $r1
Search register for %60 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %60 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %62:gpr = disjoint ORI %61:gpr, 2
Regs: R1=%62 R2=%60
In def of %62 use existing assignment to $r1
Freeing $r1: %62
Search register for %61 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %61 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %61:gpr, %60:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%61 R2=%60
<< STORE16R $r1, $r2 :: (store (s16) into %ir.5, align 4)

>> %61:gpr = ADDI %stack.4, 0
Regs: R1=%61 R2=%60
In def of %61 use existing assignment to $r1
Freeing $r1: %61
<< $r1 = ADDI %stack.4, 0

>> %60:gpr = MOVI 0, implicit $flags
Regs: R2=%60
In def of %60 use existing assignment to $r2
Freeing $r2: %60
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.8 (%ir-block.46):
; predecessors: %bb.7
  successors: %bb.27(0x80000000); %bb.27(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.27, implicit $flags

Allocating bb.9 (%ir-block.47):
; predecessors: %bb.7
  successors: %bb.10, %bb.11

  %23:gpr = ADDI %stack.3, 0
  %24:gpr = LOAD16R killed %23:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %24:gpr, 45, implicit-def $flags
  JNEI %bb.11, implicit $flags
  JMPI %bb.10, implicit $flags

>> JMPI %bb.10, implicit $flags
Regs:
<< JMPI %bb.10, implicit $flags

>> JNEI %bb.11, implicit $flags
Regs:
<< JNEI %bb.11, implicit $flags

>> CMPI killed %24:gpr, 45, implicit-def $flags
Regs:
Search register for %24 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %24 to $r1
<< CMPI killed $r1, 45, implicit-def $flags

>> %24:gpr = LOAD16R killed %23:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%24
In def of %24 use existing assignment to $r1
Freeing $r1: %24
Search register for %23 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %23 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %23:gpr = ADDI %stack.3, 0
Regs: R1=%23
In def of %23 use existing assignment to $r1
Freeing $r1: %23
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.9 (%ir-block.47):
; predecessors: %bb.7
  successors: %bb.10, %bb.11

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 45, implicit-def $flags
  JNEI %bb.11, implicit $flags
  JMPI %bb.10, implicit $flags

Allocating bb.10 (%ir-block.51):
; predecessors: %bb.9
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  %56:gpr = MOVI 0, implicit $flags
  %57:gpr = ADDI %stack.4, 0
  STORE16R %57:gpr, killed %56:gpr :: (store (s16) into %ir.5, align 4)
  %58:gpr = disjoint ORI %57:gpr, 2
  %59:gpr = MOVI 1, implicit $flags
  STORE16R killed %58:gpr, killed %59:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.26, implicit $flags

>> JMPI %bb.26, implicit $flags
Regs:
<< JMPI %bb.26, implicit $flags

>> STORE16R killed %58:gpr, killed %59:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %58 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %58 to $r1
Search register for %59 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %59 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %59:gpr = MOVI 1, implicit $flags
Regs: R1=%58 R2=%59
In def of %59 use existing assignment to $r2
Freeing $r2: %59
<< $r2 = MOVI 1, implicit $flags

>> %58:gpr = disjoint ORI %57:gpr, 2
Regs: R1=%58
In def of %58 use existing assignment to $r1
Freeing $r1: %58
Search register for %57 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %57 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %57:gpr, killed %56:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%57
Search register for %56 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %56 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)

>> %57:gpr = ADDI %stack.4, 0
Regs: R1=%57 R2=%56
In def of %57 use existing assignment to $r1
Freeing $r1: %57
<< $r1 = ADDI %stack.4, 0

>> %56:gpr = MOVI 0, implicit $flags
Regs: R2=%56
In def of %56 use existing assignment to $r2
Freeing $r2: %56
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.10 (%ir-block.51):
; predecessors: %bb.9
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  $r2 = MOVI 1, implicit $flags
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.26, implicit $flags

Allocating bb.11 (%ir-block.52):
; predecessors: %bb.9
  successors: %bb.12, %bb.13

  %25:gpr = ADDI %stack.3, 0
  %26:gpr = LOAD16R killed %25:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %26:gpr, 124, implicit-def $flags
  JNEI %bb.13, implicit $flags
  JMPI %bb.12, implicit $flags

>> JMPI %bb.12, implicit $flags
Regs:
<< JMPI %bb.12, implicit $flags

>> JNEI %bb.13, implicit $flags
Regs:
<< JNEI %bb.13, implicit $flags

>> CMPI killed %26:gpr, 124, implicit-def $flags
Regs:
Search register for %26 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %26 to $r1
<< CMPI killed $r1, 124, implicit-def $flags

>> %26:gpr = LOAD16R killed %25:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%26
In def of %26 use existing assignment to $r1
Freeing $r1: %26
Search register for %25 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %25 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %25:gpr = ADDI %stack.3, 0
Regs: R1=%25
In def of %25 use existing assignment to $r1
Freeing $r1: %25
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.11 (%ir-block.52):
; predecessors: %bb.9
  successors: %bb.12, %bb.13

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 124, implicit-def $flags
  JNEI %bb.13, implicit $flags
  JMPI %bb.12, implicit $flags

Allocating bb.12 (%ir-block.56):
; predecessors: %bb.11
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  %52:gpr = MOVI 0, implicit $flags
  %53:gpr = ADDI %stack.4, 0
  STORE16R %53:gpr, killed %52:gpr :: (store (s16) into %ir.5, align 4)
  %54:gpr = disjoint ORI %53:gpr, 2
  %55:gpr = MOVI 2, implicit $flags
  STORE16R killed %54:gpr, killed %55:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.25, implicit $flags

>> JMPI %bb.25, implicit $flags
Regs:
<< JMPI %bb.25, implicit $flags

>> STORE16R killed %54:gpr, killed %55:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %54 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %54 to $r1
Search register for %55 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %55 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %55:gpr = MOVI 2, implicit $flags
Regs: R1=%54 R2=%55
In def of %55 use existing assignment to $r2
Freeing $r2: %55
<< $r2 = MOVI 2, implicit $flags

>> %54:gpr = disjoint ORI %53:gpr, 2
Regs: R1=%54
In def of %54 use existing assignment to $r1
Freeing $r1: %54
Search register for %53 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %53 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %53:gpr, killed %52:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%53
Search register for %52 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %52 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)

>> %53:gpr = ADDI %stack.4, 0
Regs: R1=%53 R2=%52
In def of %53 use existing assignment to $r1
Freeing $r1: %53
<< $r1 = ADDI %stack.4, 0

>> %52:gpr = MOVI 0, implicit $flags
Regs: R2=%52
In def of %52 use existing assignment to $r2
Freeing $r2: %52
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.12 (%ir-block.56):
; predecessors: %bb.11
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  $r2 = MOVI 2, implicit $flags
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.25, implicit $flags

Allocating bb.13 (%ir-block.57):
; predecessors: %bb.11
  successors: %bb.14, %bb.15

  %27:gpr = ADDI %stack.3, 0
  %28:gpr = LOAD16R killed %27:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %28:gpr, 38, implicit-def $flags
  JNEI %bb.15, implicit $flags
  JMPI %bb.14, implicit $flags

>> JMPI %bb.14, implicit $flags
Regs:
<< JMPI %bb.14, implicit $flags

>> JNEI %bb.15, implicit $flags
Regs:
<< JNEI %bb.15, implicit $flags

>> CMPI killed %28:gpr, 38, implicit-def $flags
Regs:
Search register for %28 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %28 to $r1
<< CMPI killed $r1, 38, implicit-def $flags

>> %28:gpr = LOAD16R killed %27:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%28
In def of %28 use existing assignment to $r1
Freeing $r1: %28
Search register for %27 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %27 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %27:gpr = ADDI %stack.3, 0
Regs: R1=%27
In def of %27 use existing assignment to $r1
Freeing $r1: %27
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.13 (%ir-block.57):
; predecessors: %bb.11
  successors: %bb.14, %bb.15

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 38, implicit-def $flags
  JNEI %bb.15, implicit $flags
  JMPI %bb.14, implicit $flags

Allocating bb.14 (%ir-block.61):
; predecessors: %bb.13
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  %49:gpr = MOVI 0, implicit $flags
  %50:gpr = ADDI %stack.4, 0
  STORE16R %50:gpr, %49:gpr :: (store (s16) into %ir.5, align 4)
  %51:gpr = disjoint ORI %50:gpr, 2
  STORE16R killed %51:gpr, %49:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.24, implicit $flags

>> JMPI %bb.24, implicit $flags
Regs:
<< JMPI %bb.24, implicit $flags

>> STORE16R killed %51:gpr, %49:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %51 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %51 to $r1
Search register for %49 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %49 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %51:gpr = disjoint ORI %50:gpr, 2
Regs: R1=%51 R2=%49
In def of %51 use existing assignment to $r1
Freeing $r1: %51
Search register for %50 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %50 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %50:gpr, %49:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%50 R2=%49
<< STORE16R $r1, $r2 :: (store (s16) into %ir.5, align 4)

>> %50:gpr = ADDI %stack.4, 0
Regs: R1=%50 R2=%49
In def of %50 use existing assignment to $r1
Freeing $r1: %50
<< $r1 = ADDI %stack.4, 0

>> %49:gpr = MOVI 0, implicit $flags
Regs: R2=%49
In def of %49 use existing assignment to $r2
Freeing $r2: %49
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.14 (%ir-block.61):
; predecessors: %bb.13
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.24, implicit $flags

Allocating bb.15 (%ir-block.62):
; predecessors: %bb.13
  successors: %bb.16, %bb.17

  %29:gpr = ADDI %stack.3, 0
  %30:gpr = LOAD16R killed %29:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %30:gpr, 94, implicit-def $flags
  JNEI %bb.17, implicit $flags
  JMPI %bb.16, implicit $flags

>> JMPI %bb.16, implicit $flags
Regs:
<< JMPI %bb.16, implicit $flags

>> JNEI %bb.17, implicit $flags
Regs:
<< JNEI %bb.17, implicit $flags

>> CMPI killed %30:gpr, 94, implicit-def $flags
Regs:
Search register for %30 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %30 to $r1
<< CMPI killed $r1, 94, implicit-def $flags

>> %30:gpr = LOAD16R killed %29:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%30
In def of %30 use existing assignment to $r1
Freeing $r1: %30
Search register for %29 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %29 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %29:gpr = ADDI %stack.3, 0
Regs: R1=%29
In def of %29 use existing assignment to $r1
Freeing $r1: %29
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.15 (%ir-block.62):
; predecessors: %bb.13
  successors: %bb.16, %bb.17

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 94, implicit-def $flags
  JNEI %bb.17, implicit $flags
  JMPI %bb.16, implicit $flags

Allocating bb.16 (%ir-block.66):
; predecessors: %bb.15
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  %45:gpr = MOVI 0, implicit $flags
  %46:gpr = ADDI %stack.4, 0
  STORE16R %46:gpr, killed %45:gpr :: (store (s16) into %ir.5, align 4)
  %47:gpr = disjoint ORI %46:gpr, 2
  %48:gpr = MOVI 4, implicit $flags
  STORE16R killed %47:gpr, killed %48:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.23, implicit $flags

>> JMPI %bb.23, implicit $flags
Regs:
<< JMPI %bb.23, implicit $flags

>> STORE16R killed %47:gpr, killed %48:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %47 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %47 to $r1
Search register for %48 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %48 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %48:gpr = MOVI 4, implicit $flags
Regs: R1=%47 R2=%48
In def of %48 use existing assignment to $r2
Freeing $r2: %48
<< $r2 = MOVI 4, implicit $flags

>> %47:gpr = disjoint ORI %46:gpr, 2
Regs: R1=%47
In def of %47 use existing assignment to $r1
Freeing $r1: %47
Search register for %46 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %46 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %46:gpr, killed %45:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%46
Search register for %45 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %45 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)

>> %46:gpr = ADDI %stack.4, 0
Regs: R1=%46 R2=%45
In def of %46 use existing assignment to $r1
Freeing $r1: %46
<< $r1 = ADDI %stack.4, 0

>> %45:gpr = MOVI 0, implicit $flags
Regs: R2=%45
In def of %45 use existing assignment to $r2
Freeing $r2: %45
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.16 (%ir-block.66):
; predecessors: %bb.15
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  $r2 = MOVI 4, implicit $flags
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  JMPI %bb.23, implicit $flags

Allocating bb.17 (%ir-block.67):
; predecessors: %bb.15
  successors: %bb.18, %bb.19

  %31:gpr = ADDI %stack.3, 0
  %32:gpr = LOAD16R killed %31:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %32:gpr, 60, implicit-def $flags
  JNEI %bb.19, implicit $flags
  JMPI %bb.18, implicit $flags

>> JMPI %bb.18, implicit $flags
Regs:
<< JMPI %bb.18, implicit $flags

>> JNEI %bb.19, implicit $flags
Regs:
<< JNEI %bb.19, implicit $flags

>> CMPI killed %32:gpr, 60, implicit-def $flags
Regs:
Search register for %32 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %32 to $r1
<< CMPI killed $r1, 60, implicit-def $flags

>> %32:gpr = LOAD16R killed %31:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%32
In def of %32 use existing assignment to $r1
Freeing $r1: %32
Search register for %31 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %31 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %31:gpr = ADDI %stack.3, 0
Regs: R1=%31
In def of %31 use existing assignment to $r1
Freeing $r1: %31
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.17 (%ir-block.67):
; predecessors: %bb.15
  successors: %bb.18, %bb.19

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 60, implicit-def $flags
  JNEI %bb.19, implicit $flags
  JMPI %bb.18, implicit $flags

Allocating bb.18 (%ir-block.71):
; predecessors: %bb.17
  successors: %bb.22(0x80000000); %bb.22(100.00%)

  %40:gpr = MOVI 0, implicit $flags
  %41:gpr = ADDI %stack.4, 0
  STORE16R %41:gpr, killed %40:gpr :: (store (s16) into %ir.5, align 4)
  %42:gpr = disjoint ORI %41:gpr, 2
  %43:gpr = MOVI 5, implicit $flags
  STORE16R killed %42:gpr, killed %43:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  %44:gpr = COPY $r1
  JMPI %bb.22, implicit $flags

>> JMPI %bb.22, implicit $flags
Regs:
<< JMPI %bb.22, implicit $flags

>> %44:gpr = COPY $r1
Regs:
Search register for %44 in class GPR with hint $noreg
	Preferred Register 0: $r1
Assigning %44 to $r1
Freeing $r1: %44
<< dead $r1 = COPY killed $r1
Mark identity copy for removal

>> SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
Regs: R1[P]
Freeing $r1:
<< SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1

>> STORE16R killed %42:gpr, killed %43:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %42 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %42 to $r1
Search register for %43 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %43 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %43:gpr = MOVI 5, implicit $flags
Regs: R1=%42 R2=%43
In def of %43 use existing assignment to $r2
Freeing $r2: %43
<< $r2 = MOVI 5, implicit $flags

>> %42:gpr = disjoint ORI %41:gpr, 2
Regs: R1=%42
In def of %42 use existing assignment to $r1
Freeing $r1: %42
Search register for %41 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %41 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %41:gpr, killed %40:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%41
Search register for %40 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %40 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)

>> %41:gpr = ADDI %stack.4, 0
Regs: R1=%41 R2=%40
In def of %41 use existing assignment to $r1
Freeing $r1: %41
<< $r1 = ADDI %stack.4, 0

>> %40:gpr = MOVI 0, implicit $flags
Regs: R2=%40
In def of %40 use existing assignment to $r2
Freeing $r2: %40
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.18 (%ir-block.71):
; predecessors: %bb.17
  successors: %bb.22(0x80000000); %bb.22(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  $r2 = MOVI 5, implicit $flags
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  JMPI %bb.22, implicit $flags

Allocating bb.19 (%ir-block.73):
; predecessors: %bb.17
  successors: %bb.20, %bb.21

  %33:gpr = ADDI %stack.3, 0
  %34:gpr = LOAD16R killed %33:gpr :: (dereferenceable load (s16) from %ir.4)
  CMPI killed %34:gpr, 62, implicit-def $flags
  JNEI %bb.21, implicit $flags
  JMPI %bb.20, implicit $flags

>> JMPI %bb.20, implicit $flags
Regs:
<< JMPI %bb.20, implicit $flags

>> JNEI %bb.21, implicit $flags
Regs:
<< JNEI %bb.21, implicit $flags

>> CMPI killed %34:gpr, 62, implicit-def $flags
Regs:
Search register for %34 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %34 to $r1
<< CMPI killed $r1, 62, implicit-def $flags

>> %34:gpr = LOAD16R killed %33:gpr :: (dereferenceable load (s16) from %ir.4)
Regs: R1=%34
In def of %34 use existing assignment to $r1
Freeing $r1: %34
Search register for %33 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %33 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)

>> %33:gpr = ADDI %stack.3, 0
Regs: R1=%33
In def of %33 use existing assignment to $r1
Freeing $r1: %33
<< $r1 = ADDI %stack.3, 0
Begin Regs:
Loading live registers at begin of block.
bb.19 (%ir-block.73):
; predecessors: %bb.17
  successors: %bb.20, %bb.21

  $r1 = ADDI %stack.3, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.4)
  CMPI killed $r1, 62, implicit-def $flags
  JNEI %bb.21, implicit $flags
  JMPI %bb.20, implicit $flags

Allocating bb.20 (%ir-block.77):
; predecessors: %bb.19
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  %35:gpr = MOVI 0, implicit $flags
  %36:gpr = ADDI %stack.4, 0
  STORE16R %36:gpr, killed %35:gpr :: (store (s16) into %ir.5, align 4)
  %37:gpr = disjoint ORI %36:gpr, 2
  %38:gpr = MOVI 6, implicit $flags
  STORE16R killed %37:gpr, killed %38:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  %39:gpr = COPY $r1
  JMPI %bb.21, implicit $flags

>> JMPI %bb.21, implicit $flags
Regs:
<< JMPI %bb.21, implicit $flags

>> %39:gpr = COPY $r1
Regs:
Search register for %39 in class GPR with hint $noreg
	Preferred Register 0: $r1
Assigning %39 to $r1
Freeing $r1: %39
<< dead $r1 = COPY killed $r1
Mark identity copy for removal

>> SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
Regs: R1[P]
Freeing $r1:
<< SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1

>> STORE16R killed %37:gpr, killed %38:gpr :: (store (s16) into %ir.5 + 2, basealign 4)
Regs:
Search register for %37 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %37 to $r1
Search register for %38 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %38 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)

>> %38:gpr = MOVI 6, implicit $flags
Regs: R1=%37 R2=%38
In def of %38 use existing assignment to $r2
Freeing $r2: %38
<< $r2 = MOVI 6, implicit $flags

>> %37:gpr = disjoint ORI %36:gpr, 2
Regs: R1=%37
In def of %37 use existing assignment to $r1
Freeing $r1: %37
Search register for %36 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %36 to $r1
<< $r1 = disjoint ORI killed $r1, 2

>> STORE16R %36:gpr, killed %35:gpr :: (store (s16) into %ir.5, align 4)
Regs: R1=%36
Search register for %35 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %35 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)

>> %36:gpr = ADDI %stack.4, 0
Regs: R1=%36 R2=%35
In def of %36 use existing assignment to $r1
Freeing $r1: %36
<< $r1 = ADDI %stack.4, 0

>> %35:gpr = MOVI 0, implicit $flags
Regs: R2=%35
In def of %35 use existing assignment to $r2
Freeing $r2: %35
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.20 (%ir-block.77):
; predecessors: %bb.19
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.4, 0
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.5, align 4)
  $r1 = disjoint ORI killed $r1, 2
  $r2 = MOVI 6, implicit $flags
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.5 + 2, basealign 4)
  SymphonyCallI @input, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit-def $r1
  JMPI %bb.21, implicit $flags

Allocating bb.21 (%ir-block.79):
; predecessors: %bb.19, %bb.20
  successors: %bb.22(0x80000000); %bb.22(100.00%)

  JMPI %bb.22, implicit $flags

>> JMPI %bb.22, implicit $flags
Regs:
<< JMPI %bb.22, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.21 (%ir-block.79):
; predecessors: %bb.19, %bb.20
  successors: %bb.22(0x80000000); %bb.22(100.00%)

  JMPI %bb.22, implicit $flags

Allocating bb.22 (%ir-block.80):
; predecessors: %bb.21, %bb.18
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  JMPI %bb.23, implicit $flags

>> JMPI %bb.23, implicit $flags
Regs:
<< JMPI %bb.23, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.22 (%ir-block.80):
; predecessors: %bb.21, %bb.18
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  JMPI %bb.23, implicit $flags

Allocating bb.23 (%ir-block.81):
; predecessors: %bb.22, %bb.16
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  JMPI %bb.24, implicit $flags

>> JMPI %bb.24, implicit $flags
Regs:
<< JMPI %bb.24, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.23 (%ir-block.81):
; predecessors: %bb.22, %bb.16
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  JMPI %bb.24, implicit $flags

Allocating bb.24 (%ir-block.82):
; predecessors: %bb.23, %bb.14
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  JMPI %bb.25, implicit $flags

>> JMPI %bb.25, implicit $flags
Regs:
<< JMPI %bb.25, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.24 (%ir-block.82):
; predecessors: %bb.23, %bb.14
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  JMPI %bb.25, implicit $flags

Allocating bb.25 (%ir-block.83):
; predecessors: %bb.24, %bb.12
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  JMPI %bb.26, implicit $flags

>> JMPI %bb.26, implicit $flags
Regs:
<< JMPI %bb.26, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.25 (%ir-block.83):
; predecessors: %bb.24, %bb.12
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  JMPI %bb.26, implicit $flags

Allocating bb.26 (%ir-block.84):
; predecessors: %bb.25, %bb.10
  successors: %bb.27(0x80000000); %bb.27(100.00%)

  JMPI %bb.27, implicit $flags

>> JMPI %bb.27, implicit $flags
Regs:
<< JMPI %bb.27, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.26 (%ir-block.84):
; predecessors: %bb.25, %bb.10
  successors: %bb.27(0x80000000); %bb.27(100.00%)

  JMPI %bb.27, implicit $flags

Allocating bb.27 (%ir-block.85):
; predecessors: %bb.26, %bb.8
  successors: %bb.28, %bb.32

  %63:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %64:gpr = ADDI %stack.1, 0
  %65:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
  %66:gpr = nuw nsw LSLI killed %65:gpr, 3
  %67:gpr = nuw ADDR killed %63:gpr, killed %66:gpr
  %68:gpr = MOVI 0, implicit $flags
  STORE8R killed %67:gpr, killed %68:gpr :: (store (s8) into %ir.90, align 4)
  %69:gpr = ADDI %stack.4, 0
  %70:gpr = LOAD16R %69:gpr :: (dereferenceable load (s16) from %ir.5, align 4)
  %71:gpr = disjoint ORI %69:gpr, 2
  %72:gpr = LOAD16R killed %71:gpr :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
  %73:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %74:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
  %75:gpr = nuw nsw LSLI killed %74:gpr, 3
  %76:gpr = nuw ADDR killed %73:gpr, killed %75:gpr
  %77:gpr = nuw ADDI %76:gpr, 4
  %78:gpr = nuw ADDI %76:gpr, 6
  STORE16R killed %78:gpr, killed %72:gpr :: (store (s16) into %ir.96 + 2, basealign 4)
  STORE16R killed %77:gpr, killed %70:gpr :: (store (s16) into %ir.96, align 4)
  %79:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
  CMPI killed %79:gpr, 2, implicit-def $flags
  JLI %bb.32, implicit $flags
  JMPI %bb.28, implicit $flags

>> JMPI %bb.28, implicit $flags
Regs:
<< JMPI %bb.28, implicit $flags

>> JLI %bb.32, implicit $flags
Regs:
<< JLI %bb.32, implicit $flags

>> CMPI killed %79:gpr, 2, implicit-def $flags
Regs:
Search register for %79 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %79 to $r1
<< CMPI killed $r1, 2, implicit-def $flags

>> %79:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%79
In def of %79 use existing assignment to $r1
Freeing $r1: %79
Search register for %64 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %64 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.2)

>> STORE16R killed %77:gpr, killed %70:gpr :: (store (s16) into %ir.96, align 4)
Regs: R1=%64
Search register for %77 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %77 to $r2
Search register for %70 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 already used in instr.
	Register: $r3 Cost: 0 BestCost: 100
Assigning %70 to $r3
<< STORE16R killed $r2, killed $r3 :: (store (s16) into %ir.96, align 4)

>> STORE16R killed %78:gpr, killed %72:gpr :: (store (s16) into %ir.96 + 2, basealign 4)
Regs: R1=%64 R2=%77 R3=%70
Search register for %78 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %78 to $r4
Search register for %72 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 already used in instr.
	Register: $r5 Cost: 0 BestCost: 100
Assigning %72 to $r5
<< STORE16R killed $r4, killed $r5 :: (store (s16) into %ir.96 + 2, basealign 4)

>> %78:gpr = nuw ADDI %76:gpr, 6
Regs: R1=%64 R2=%77 R3=%70 R4=%78 R5=%72
In def of %78 use existing assignment to $r4
Freeing $r4: %78
Search register for %76 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %76 to $r4
<< $r4 = nuw ADDI killed $r4, 6

>> %77:gpr = nuw ADDI %76:gpr, 4
Regs: R1=%64 R2=%77 R3=%70 R4=%76 R5=%72
In def of %77 use existing assignment to $r2
Freeing $r2: %77
<< $r2 = nuw ADDI $r4, 4

>> %76:gpr = nuw ADDR killed %73:gpr, killed %75:gpr
Regs: R1=%64 R3=%70 R4=%76 R5=%72
In def of %76 use existing assignment to $r4
Freeing $r4: %76
Search register for %73 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %73 to $r2
Search register for %75 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 already used in instr.
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %75 to $r4
<< $r4 = nuw ADDR killed $r2, killed $r4

>> %75:gpr = nuw nsw LSLI killed %74:gpr, 3
Regs: R1=%64 R2=%73 R3=%70 R4=%75 R5=%72
In def of %75 use existing assignment to $r4
Freeing $r4: %75
Search register for %74 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %74 to $r4
<< $r4 = nuw nsw LSLI killed $r4, 3

>> %74:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%64 R2=%73 R3=%70 R4=%74 R5=%72
In def of %74 use existing assignment to $r4
Freeing $r4: %74
<< $r4 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)

>> %73:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R1=%64 R2=%73 R3=%70 R5=%72
In def of %73 use existing assignment to $r2
Freeing $r2: %73
<< $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)

>> %72:gpr = LOAD16R killed %71:gpr :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
Regs: R1=%64 R3=%70 R5=%72
In def of %72 use existing assignment to $r5
Freeing $r5: %72
Search register for %71 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %71 to $r2
<< $r5 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)

>> %71:gpr = disjoint ORI %69:gpr, 2
Regs: R1=%64 R2=%71 R3=%70
In def of %71 use existing assignment to $r2
Freeing $r2: %71
Search register for %69 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %69 to $r2
<< $r2 = disjoint ORI killed $r2, 2

>> %70:gpr = LOAD16R %69:gpr :: (dereferenceable load (s16) from %ir.5, align 4)
Regs: R1=%64 R2=%69 R3=%70
In def of %70 use existing assignment to $r3
Freeing $r3: %70
<< $r3 = LOAD16R $r2 :: (dereferenceable load (s16) from %ir.5, align 4)

>> %69:gpr = ADDI %stack.4, 0
Regs: R1=%64 R2=%69
In def of %69 use existing assignment to $r2
Freeing $r2: %69
<< $r2 = ADDI %stack.4, 0

>> STORE8R killed %67:gpr, killed %68:gpr :: (store (s8) into %ir.90, align 4)
Regs: R1=%64
Search register for %67 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %67 to $r2
Search register for %68 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 already used in instr.
	Register: $r3 Cost: 0 BestCost: 100
Assigning %68 to $r3
<< STORE8R killed $r2, killed $r3 :: (store (s8) into %ir.90, align 4)

>> %68:gpr = MOVI 0, implicit $flags
Regs: R1=%64 R2=%67 R3=%68
In def of %68 use existing assignment to $r3
Freeing $r3: %68
<< $r3 = MOVI 0, implicit $flags

>> %67:gpr = nuw ADDR killed %63:gpr, killed %66:gpr
Regs: R1=%64 R2=%67
In def of %67 use existing assignment to $r2
Freeing $r2: %67
Search register for %63 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %63 to $r2
Search register for %66 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 already used in instr.
	Register: $r3 Cost: 0 BestCost: 100
Assigning %66 to $r3
<< $r2 = nuw ADDR killed $r2, killed $r3

>> %66:gpr = nuw nsw LSLI killed %65:gpr, 3
Regs: R1=%64 R2=%63 R3=%66
In def of %66 use existing assignment to $r3
Freeing $r3: %66
Search register for %65 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 0 BestCost: 100
Assigning %65 to $r3
<< $r3 = nuw nsw LSLI killed $r3, 3

>> %65:gpr = LOAD16R %64:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%64 R2=%63 R3=%65
In def of %65 use existing assignment to $r3
Freeing $r3: %65
<< $r3 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)

>> %64:gpr = ADDI %stack.1, 0
Regs: R1=%64 R2=%63
In def of %64 use existing assignment to $r1
Freeing $r1: %64
<< $r1 = ADDI %stack.1, 0

>> %63:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R2=%63
In def of %63 use existing assignment to $r2
Freeing $r2: %63
<< $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Begin Regs:
Loading live registers at begin of block.
bb.27 (%ir-block.85):
; predecessors: %bb.26, %bb.8
  successors: %bb.28, %bb.32

  $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r1 = ADDI %stack.1, 0
  $r3 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)
  $r3 = nuw nsw LSLI killed $r3, 3
  $r2 = nuw ADDR killed $r2, killed $r3
  $r3 = MOVI 0, implicit $flags
  STORE8R killed $r2, killed $r3 :: (store (s8) into %ir.90, align 4)
  $r2 = ADDI %stack.4, 0
  $r3 = LOAD16R $r2 :: (dereferenceable load (s16) from %ir.5, align 4)
  $r2 = disjoint ORI killed $r2, 2
  $r5 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.5 + 2, basealign 4)
  $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r4 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)
  $r4 = nuw nsw LSLI killed $r4, 3
  $r4 = nuw ADDR killed $r2, killed $r4
  $r2 = nuw ADDI $r4, 4
  $r4 = nuw ADDI killed $r4, 6
  STORE16R killed $r4, killed $r5 :: (store (s16) into %ir.96 + 2, basealign 4)
  STORE16R killed $r2, killed $r3 :: (store (s16) into %ir.96, align 4)
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.2)
  CMPI killed $r1, 2, implicit-def $flags
  JLI %bb.32, implicit $flags
  JMPI %bb.28, implicit $flags

Allocating bb.28 (%ir-block.100):
; predecessors: %bb.27
  successors: %bb.29, %bb.31

  %80:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %81:gpr = ADDI %stack.1, 0
  %82:gpr = LOAD16R killed %81:gpr :: (dereferenceable load (s16) from %ir.2)
  %83:gpr = LSLI killed %82:gpr, 3
  %84:gpr = ADDR killed %83:gpr, killed %80:gpr
  %85:gpr = ADDI killed %84:gpr, -16
  %86:gpr = LOAD8R killed %85:gpr :: (load (s8) from %ir.106, align 4)
  %87:gpr = LSLI killed %86:gpr, 8
  %88:gpr = ASRI %87:gpr, 15
  %89:gpr = ASRI %87:gpr, 8
  %90:gpr = ORR killed %89:gpr, killed %88:gpr
  CMPI killed %90:gpr, 0, implicit-def $flags
  JEI %bb.31, implicit $flags
  JMPI %bb.29, implicit $flags

>> JMPI %bb.29, implicit $flags
Regs:
<< JMPI %bb.29, implicit $flags

>> JEI %bb.31, implicit $flags
Regs:
<< JEI %bb.31, implicit $flags

>> CMPI killed %90:gpr, 0, implicit-def $flags
Regs:
Search register for %90 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %90 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %90:gpr = ORR killed %89:gpr, killed %88:gpr
Regs: R1=%90
In def of %90 use existing assignment to $r1
Freeing $r1: %90
Search register for %89 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %89 to $r1
Search register for %88 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %88 to $r2
<< $r1 = ORR killed $r1, killed $r2

>> %89:gpr = ASRI %87:gpr, 8
Regs: R1=%89 R2=%88
In def of %89 use existing assignment to $r1
Freeing $r1: %89
Search register for %87 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %87 to $r1
<< $r1 = ASRI killed $r1, 8

>> %88:gpr = ASRI %87:gpr, 15
Regs: R1=%87 R2=%88
In def of %88 use existing assignment to $r2
Freeing $r2: %88
<< $r2 = ASRI $r1, 15

>> %87:gpr = LSLI killed %86:gpr, 8
Regs: R1=%87
In def of %87 use existing assignment to $r1
Freeing $r1: %87
Search register for %86 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %86 to $r1
<< $r1 = LSLI killed $r1, 8

>> %86:gpr = LOAD8R killed %85:gpr :: (load (s8) from %ir.106, align 4)
Regs: R1=%86
In def of %86 use existing assignment to $r1
Freeing $r1: %86
Search register for %85 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %85 to $r1
<< $r1 = LOAD8R killed $r1 :: (load (s8) from %ir.106, align 4)

>> %85:gpr = ADDI killed %84:gpr, -16
Regs: R1=%85
In def of %85 use existing assignment to $r1
Freeing $r1: %85
Search register for %84 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %84 to $r1
<< $r1 = ADDI killed $r1, -16

>> %84:gpr = ADDR killed %83:gpr, killed %80:gpr
Regs: R1=%84
In def of %84 use existing assignment to $r1
Freeing $r1: %84
Search register for %83 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %83 to $r1
Search register for %80 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %80 to $r2
<< $r1 = ADDR killed $r1, killed $r2

>> %83:gpr = LSLI killed %82:gpr, 3
Regs: R1=%83 R2=%80
In def of %83 use existing assignment to $r1
Freeing $r1: %83
Search register for %82 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %82 to $r1
<< $r1 = LSLI killed $r1, 3

>> %82:gpr = LOAD16R killed %81:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%82 R2=%80
In def of %82 use existing assignment to $r1
Freeing $r1: %82
Search register for %81 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %81 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.2)

>> %81:gpr = ADDI %stack.1, 0
Regs: R1=%81 R2=%80
In def of %81 use existing assignment to $r1
Freeing $r1: %81
<< $r1 = ADDI %stack.1, 0

>> %80:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R2=%80
In def of %80 use existing assignment to $r2
Freeing $r2: %80
<< $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Begin Regs:
Loading live registers at begin of block.
bb.28 (%ir-block.100):
; predecessors: %bb.27
  successors: %bb.29, %bb.31

  $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r1 = ADDI %stack.1, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.2)
  $r1 = LSLI killed $r1, 3
  $r1 = ADDR killed $r1, killed $r2
  $r1 = ADDI killed $r1, -16
  $r1 = LOAD8R killed $r1 :: (load (s8) from %ir.106, align 4)
  $r1 = LSLI killed $r1, 8
  $r2 = ASRI $r1, 15
  $r1 = ASRI killed $r1, 8
  $r1 = ORR killed $r1, killed $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.31, implicit $flags
  JMPI %bb.29, implicit $flags

Allocating bb.29 (%ir-block.110):
; predecessors: %bb.28
  successors: %bb.30, %bb.31

  %91:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %92:gpr = ADDI %stack.1, 0
  %93:gpr = LOAD16R killed %92:gpr :: (dereferenceable load (s16) from %ir.2)
  %94:gpr = LSLI killed %93:gpr, 3
  %95:gpr = ADDR killed %94:gpr, killed %91:gpr
  %96:gpr = ADDI killed %95:gpr, -16
  %97:gpr = LOAD8R killed %96:gpr :: (load (s8) from %ir.116, align 4)
  %98:gpr = LSLI killed %97:gpr, 8
  %99:gpr = ASRI %98:gpr, 15
  %100:gpr = ASRI %98:gpr, 8
  %101:gpr = ORR killed %100:gpr, killed %99:gpr
  CMPI killed %101:gpr, 0, implicit-def $flags
  JEI %bb.31, implicit $flags
  JMPI %bb.30, implicit $flags

>> JMPI %bb.30, implicit $flags
Regs:
<< JMPI %bb.30, implicit $flags

>> JEI %bb.31, implicit $flags
Regs:
<< JEI %bb.31, implicit $flags

>> CMPI killed %101:gpr, 0, implicit-def $flags
Regs:
Search register for %101 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %101 to $r1
<< CMPI killed $r1, 0, implicit-def $flags

>> %101:gpr = ORR killed %100:gpr, killed %99:gpr
Regs: R1=%101
In def of %101 use existing assignment to $r1
Freeing $r1: %101
Search register for %100 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %100 to $r1
Search register for %99 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %99 to $r2
<< $r1 = ORR killed $r1, killed $r2

>> %100:gpr = ASRI %98:gpr, 8
Regs: R1=%100 R2=%99
In def of %100 use existing assignment to $r1
Freeing $r1: %100
Search register for %98 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %98 to $r1
<< $r1 = ASRI killed $r1, 8

>> %99:gpr = ASRI %98:gpr, 15
Regs: R1=%98 R2=%99
In def of %99 use existing assignment to $r2
Freeing $r2: %99
<< $r2 = ASRI $r1, 15

>> %98:gpr = LSLI killed %97:gpr, 8
Regs: R1=%98
In def of %98 use existing assignment to $r1
Freeing $r1: %98
Search register for %97 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %97 to $r1
<< $r1 = LSLI killed $r1, 8

>> %97:gpr = LOAD8R killed %96:gpr :: (load (s8) from %ir.116, align 4)
Regs: R1=%97
In def of %97 use existing assignment to $r1
Freeing $r1: %97
Search register for %96 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %96 to $r1
<< $r1 = LOAD8R killed $r1 :: (load (s8) from %ir.116, align 4)

>> %96:gpr = ADDI killed %95:gpr, -16
Regs: R1=%96
In def of %96 use existing assignment to $r1
Freeing $r1: %96
Search register for %95 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %95 to $r1
<< $r1 = ADDI killed $r1, -16

>> %95:gpr = ADDR killed %94:gpr, killed %91:gpr
Regs: R1=%95
In def of %95 use existing assignment to $r1
Freeing $r1: %95
Search register for %94 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %94 to $r1
Search register for %91 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %91 to $r2
<< $r1 = ADDR killed $r1, killed $r2

>> %94:gpr = LSLI killed %93:gpr, 3
Regs: R1=%94 R2=%91
In def of %94 use existing assignment to $r1
Freeing $r1: %94
Search register for %93 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %93 to $r1
<< $r1 = LSLI killed $r1, 3

>> %93:gpr = LOAD16R killed %92:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%93 R2=%91
In def of %93 use existing assignment to $r1
Freeing $r1: %93
Search register for %92 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %92 to $r1
<< $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.2)

>> %92:gpr = ADDI %stack.1, 0
Regs: R1=%92 R2=%91
In def of %92 use existing assignment to $r1
Freeing $r1: %92
<< $r1 = ADDI %stack.1, 0

>> %91:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R2=%91
In def of %91 use existing assignment to $r2
Freeing $r2: %91
<< $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Begin Regs:
Loading live registers at begin of block.
bb.29 (%ir-block.110):
; predecessors: %bb.28
  successors: %bb.30, %bb.31

  $r2 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r1 = ADDI %stack.1, 0
  $r1 = LOAD16R killed $r1 :: (dereferenceable load (s16) from %ir.2)
  $r1 = LSLI killed $r1, 3
  $r1 = ADDR killed $r1, killed $r2
  $r1 = ADDI killed $r1, -16
  $r1 = LOAD8R killed $r1 :: (load (s8) from %ir.116, align 4)
  $r1 = LSLI killed $r1, 8
  $r2 = ASRI $r1, 15
  $r1 = ASRI killed $r1, 8
  $r1 = ORR killed $r1, killed $r2
  CMPI killed $r1, 0, implicit-def $flags
  JEI %bb.31, implicit $flags
  JMPI %bb.30, implicit $flags

Allocating bb.30 (%ir-block.120):
; predecessors: %bb.29
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  %102:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %103:gpr = ADDI %stack.1, 0
  %104:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
  %105:gpr = LSLI killed %104:gpr, 3
  %106:gpr = ADDR killed %102:gpr, killed %105:gpr
  %107:gpr = nuw ADDI %106:gpr, 4
  %108:gpr = nuw ADDI %106:gpr, 6
  %109:gpr = LOAD16R killed %108:gpr :: (load (s16) from %ir.125 + 2, basealign 4)
  %110:gpr = LOAD16R killed %107:gpr :: (load (s16) from %ir.125, align 4)
  %111:gpr = ADDI %106:gpr, -12
  %112:gpr = LOAD16R killed %111:gpr :: (load (s16) from %ir.132, align 4)
  %113:gpr = ADDI %106:gpr, -4
  %114:gpr = LOAD16R killed %113:gpr :: (load (s16) from %ir.139, align 4)
  $r1 = COPY %110:gpr
  $r2 = COPY %109:gpr
  $r3 = COPY %112:gpr
  $r4 = COPY %114:gpr
  SymphonyCallI @do_calc, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit-def $r1
  %115:gpr = COPY $r1
  %116:gpr = ADDI %stack.5, 0
  STORE16R %116:gpr, %115:gpr :: (store (s16) into %ir.6)
  %117:gpr = LOAD16R %116:gpr :: (dereferenceable load (s16) from %ir.6)
  $r1 = COPY %117:gpr
  SymphonyCallI @output, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1
  %118:gpr = LOAD16R %116:gpr :: (dereferenceable load (s16) from %ir.6)
  %119:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  %120:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
  %121:gpr = LSLI killed %120:gpr, 3
  %122:gpr = ADDR killed %121:gpr, killed %119:gpr
  %123:gpr = ADDI killed %122:gpr, -12
  STORE16R killed %123:gpr, killed %118:gpr :: (store (s16) into %ir.149, align 4)
  %124:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
  %125:gpr = ADDI killed %124:gpr, -2
  STORE16R %103:gpr, killed %125:gpr :: (store (s16) into %ir.2)
  JMPI %bb.31, implicit $flags

>> JMPI %bb.31, implicit $flags
Regs:
<< JMPI %bb.31, implicit $flags

>> STORE16R %103:gpr, killed %125:gpr :: (store (s16) into %ir.2)
Regs:
Search register for %103 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %103 to $r1
Search register for %125 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %125 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)

>> %125:gpr = ADDI killed %124:gpr, -2
Regs: R1=%103 R2=%125
In def of %125 use existing assignment to $r2
Freeing $r2: %125
Search register for %124 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %124 to $r2
<< $r2 = ADDI killed $r2, -2

>> %124:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%103 R2=%124
In def of %124 use existing assignment to $r2
Freeing $r2: %124
<< $r2 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)

>> STORE16R killed %123:gpr, killed %118:gpr :: (store (s16) into %ir.149, align 4)
Regs: R1=%103
Search register for %123 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %123 to $r2
Search register for %118 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 already used in instr.
	Register: $r3 Cost: 0 BestCost: 100
Assigning %118 to $r3
<< STORE16R killed $r2, killed $r3 :: (store (s16) into %ir.149, align 4)

>> %123:gpr = ADDI killed %122:gpr, -12
Regs: R1=%103 R2=%123 R3=%118
In def of %123 use existing assignment to $r2
Freeing $r2: %123
Search register for %122 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %122 to $r2
<< $r2 = ADDI killed $r2, -12

>> %122:gpr = ADDR killed %121:gpr, killed %119:gpr
Regs: R1=%103 R2=%122 R3=%118
In def of %122 use existing assignment to $r2
Freeing $r2: %122
Search register for %121 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %121 to $r2
Search register for %119 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 already used in instr.
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %119 to $r4
<< $r2 = ADDR killed $r2, killed $r4

>> %121:gpr = LSLI killed %120:gpr, 3
Regs: R1=%103 R2=%121 R3=%118 R4=%119
In def of %121 use existing assignment to $r2
Freeing $r2: %121
Search register for %120 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %120 to $r2
<< $r2 = LSLI killed $r2, 3

>> %120:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%103 R2=%120 R3=%118 R4=%119
In def of %120 use existing assignment to $r2
Freeing $r2: %120
<< $r2 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)

>> %119:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R1=%103 R3=%118 R4=%119
In def of %119 use existing assignment to $r4
Freeing $r4: %119
<< $r4 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)

>> %118:gpr = LOAD16R %116:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%103 R3=%118
In def of %118 use existing assignment to $r3
Freeing $r3: %118
Search register for %116 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %116 to $r2
<< $r3 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.6)

>> SymphonyCallI @output, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1
Regs: R1=%103 R2=%116
Reloading %103 into $r1
Reloading %116 into $r2
<< SymphonyCallI @output, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit killed $r1

>> $r1 = COPY %117:gpr
Regs: R1[P]
Freeing $r1:
Search register for %117 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %117 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %117:gpr = LOAD16R %116:gpr :: (dereferenceable load (s16) from %ir.6)
Regs: R1=%117
In def of %117 use existing assignment to $r1
Freeing $r1: %117
Search register for %116 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %116 to $r1
<< $r1 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.6)

>> STORE16R %116:gpr, %115:gpr :: (store (s16) into %ir.6)
Regs: R1=%116[R]
Search register for %115 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %115 to $r2
<< STORE16R $r1, killed $r2 :: (store (s16) into %ir.6)

>> %116:gpr = ADDI %stack.5, 0
Regs: R1=%116[R] R2=%115
In def of %116 use existing assignment to $r1
Spill Reason: LO: 0 RL: 1
Spilling %116 in $r1 to stack slot #7
Freeing $r1: %116
<< $r1 = ADDI %stack.5, 0

>> %115:gpr = COPY $r1
Regs: R2=%115
In def of %115 use existing assignment to $r2
Freeing $r2: %115
<< $r2 = COPY killed $r1

>> SymphonyCallI @do_calc, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit-def $r1
Regs: R1[P]
Freeing $r1:
<< SymphonyCallI @do_calc, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit killed $r1, implicit killed $r2, implicit killed $r3, implicit killed $r4, implicit-def $r1

>> $r4 = COPY %114:gpr
Regs: R1[P] R2[P] R3[P] R4[P]
Freeing $r4:
Search register for %114 in class GPR with hint $r4
	Preferred Register 1: $r4
Assigning %114 to $r4
<< $r4 = COPY killed $r4
Mark identity copy for removal

>> $r3 = COPY %112:gpr
Regs: R1[P] R2[P] R3[P] R4=%114
Freeing $r3:
Search register for %112 in class GPR with hint $r3
	Preferred Register 1: $r3
Assigning %112 to $r3
<< $r3 = COPY killed $r3
Mark identity copy for removal

>> $r2 = COPY %109:gpr
Regs: R1[P] R2[P] R3=%112 R4=%114
Freeing $r2:
Search register for %109 in class GPR with hint $r2
	Preferred Register 1: $r2
Assigning %109 to $r2
<< $r2 = COPY killed $r2
Mark identity copy for removal

>> $r1 = COPY %110:gpr
Regs: R1[P] R2=%109 R3=%112 R4=%114
Freeing $r1:
Search register for %110 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %110 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> %114:gpr = LOAD16R killed %113:gpr :: (load (s16) from %ir.139, align 4)
Regs: R1=%110 R2=%109 R3=%112 R4=%114
In def of %114 use existing assignment to $r4
Freeing $r4: %114
Search register for %113 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %113 to $r4
<< $r4 = LOAD16R killed $r4 :: (load (s16) from %ir.139, align 4)

>> %113:gpr = ADDI %106:gpr, -4
Regs: R1=%110 R2=%109 R3=%112 R4=%113
In def of %113 use existing assignment to $r4
Freeing $r4: %113
Search register for %106 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 0 BestCost: 100
Assigning %106 to $r4
<< $r4 = ADDI killed $r4, -4

>> %112:gpr = LOAD16R killed %111:gpr :: (load (s16) from %ir.132, align 4)
Regs: R1=%110 R2=%109 R3=%112 R4=%106
In def of %112 use existing assignment to $r3
Freeing $r3: %112
Search register for %111 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 0 BestCost: 100
Assigning %111 to $r3
<< $r3 = LOAD16R killed $r3 :: (load (s16) from %ir.132, align 4)

>> %111:gpr = ADDI %106:gpr, -12
Regs: R1=%110 R2=%109 R3=%111 R4=%106
In def of %111 use existing assignment to $r3
Freeing $r3: %111
<< $r3 = ADDI $r4, -12

>> %110:gpr = LOAD16R killed %107:gpr :: (load (s16) from %ir.125, align 4)
Regs: R1=%110 R2=%109 R4=%106
In def of %110 use existing assignment to $r1
Freeing $r1: %110
Search register for %107 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %107 to $r1
<< $r1 = LOAD16R killed $r1 :: (load (s16) from %ir.125, align 4)

>> %109:gpr = LOAD16R killed %108:gpr :: (load (s16) from %ir.125 + 2, basealign 4)
Regs: R1=%107 R2=%109 R4=%106
In def of %109 use existing assignment to $r2
Freeing $r2: %109
Search register for %108 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %108 to $r2
<< $r2 = LOAD16R killed $r2 :: (load (s16) from %ir.125 + 2, basealign 4)

>> %108:gpr = nuw ADDI %106:gpr, 6
Regs: R1=%107 R2=%108 R4=%106
In def of %108 use existing assignment to $r2
Freeing $r2: %108
<< $r2 = nuw ADDI $r4, 6

>> %107:gpr = nuw ADDI %106:gpr, 4
Regs: R1=%107 R4=%106
In def of %107 use existing assignment to $r1
Freeing $r1: %107
<< $r1 = nuw ADDI $r4, 4

>> %106:gpr = ADDR killed %102:gpr, killed %105:gpr
Regs: R4=%106
In def of %106 use existing assignment to $r4
Freeing $r4: %106
Search register for %102 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %102 to $r1
Search register for %105 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %105 to $r2
<< $r4 = ADDR killed $r1, killed $r2

>> %105:gpr = LSLI killed %104:gpr, 3
Regs: R1=%102 R2=%105
In def of %105 use existing assignment to $r2
Freeing $r2: %105
Search register for %104 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %104 to $r2
<< $r2 = LSLI killed $r2, 3

>> %104:gpr = LOAD16R %103:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%102 R2=%104
In def of %104 use existing assignment to $r2
Freeing $r2: %104
Search register for %103 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %103 to $r2
<< $r2 = LOAD16R $r2 :: (dereferenceable load (s16) from %ir.2)

>> %103:gpr = ADDI %stack.1, 0
Regs: R1=%102 R2=%103[R]
In def of %103 use existing assignment to $r2
Spill Reason: LO: 0 RL: 1
Spilling %103 in $r2 to stack slot #6
Freeing $r2: %103
<< $r2 = ADDI %stack.1, 0

>> %102:gpr = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Regs: R1=%102
In def of %102 use existing assignment to $r1
Freeing $r1: %102
<< $r1 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
Begin Regs:
Loading live registers at begin of block.
bb.30 (%ir-block.120):
; predecessors: %bb.29
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  $r1 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r2 = ADDI %stack.1, 0
  $r13 = frameptrget %stack.6, implicit-def $r13
  STORE16R killed $r13, $r2
  $r2 = LOAD16R $r2 :: (dereferenceable load (s16) from %ir.2)
  $r2 = LSLI killed $r2, 3
  $r4 = ADDR killed $r1, killed $r2
  $r1 = nuw ADDI $r4, 4
  $r2 = nuw ADDI $r4, 6
  $r2 = LOAD16R killed $r2 :: (load (s16) from %ir.125 + 2, basealign 4)
  $r1 = LOAD16R killed $r1 :: (load (s16) from %ir.125, align 4)
  $r3 = ADDI $r4, -12
  $r3 = LOAD16R killed $r3 :: (load (s16) from %ir.132, align 4)
  $r4 = ADDI killed $r4, -4
  $r4 = LOAD16R killed $r4 :: (load (s16) from %ir.139, align 4)
  SymphonyCallI @do_calc, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit killed $r1, implicit killed $r2, implicit killed $r3, implicit killed $r4, implicit-def $r1
  $r2 = COPY killed $r1
  $r1 = ADDI %stack.5, 0
  $r13 = frameptrget %stack.7, implicit-def $r13
  STORE16R killed $r13, $r1
  STORE16R $r1, killed $r2 :: (store (s16) into %ir.6)
  $r1 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.6)
  SymphonyCallI @output, <regmask $zr $r7 $r8 $r9 $r10 $r11 $r12>, implicit $flags, implicit killed $r1
  $r13 = frameptrget %stack.7, implicit-def $r13
  LOAD16R $r2, killed $r13
  $r13 = frameptrget %stack.6, implicit-def $r13
  LOAD16R $r1, killed $r13
  $r3 = LOAD16R killed $r2 :: (dereferenceable load (s16) from %ir.6)
  $r4 = LOAD16R @stack :: (dereferenceable load (s16) from @stack, align 4)
  $r2 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)
  $r2 = LSLI killed $r2, 3
  $r2 = ADDR killed $r2, killed $r4
  $r2 = ADDI killed $r2, -12
  STORE16R killed $r2, killed $r3 :: (store (s16) into %ir.149, align 4)
  $r2 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)
  $r2 = ADDI killed $r2, -2
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)
  JMPI %bb.31, implicit $flags

Allocating bb.31 (%ir-block.154):
; predecessors: %bb.28, %bb.29, %bb.30
  successors: %bb.32(0x80000000); %bb.32(100.00%)

  JMPI %bb.32, implicit $flags

>> JMPI %bb.32, implicit $flags
Regs:
<< JMPI %bb.32, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.31 (%ir-block.154):
; predecessors: %bb.28, %bb.29, %bb.30
  successors: %bb.32(0x80000000); %bb.32(100.00%)

  JMPI %bb.32, implicit $flags

Allocating bb.32 (%ir-block.155):
; predecessors: %bb.27, %bb.31
  successors: %bb.33(0x80000000); %bb.33(100.00%)

  JMPI %bb.33, implicit $flags

>> JMPI %bb.33, implicit $flags
Regs:
<< JMPI %bb.33, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.32 (%ir-block.155):
; predecessors: %bb.27, %bb.31
  successors: %bb.33(0x80000000); %bb.33(100.00%)

  JMPI %bb.33, implicit $flags

Allocating bb.33 (%ir-block.156):
; predecessors: %bb.6, %bb.32
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  JMPI %bb.34, implicit $flags

>> JMPI %bb.34, implicit $flags
Regs:
<< JMPI %bb.34, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.33 (%ir-block.156):
; predecessors: %bb.6, %bb.32
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  JMPI %bb.34, implicit $flags

Allocating bb.34 (%ir-block.157):
; predecessors: %bb.33, %bb.5
  successors: %bb.35(0x80000000); %bb.35(100.00%)

  %140:gpr = ADDI %stack.1, 0
  %141:gpr = LOAD16R %140:gpr :: (dereferenceable load (s16) from %ir.2)
  %142:gpr = ADDI killed %141:gpr, 1
  STORE16R %140:gpr, killed %142:gpr :: (store (s16) into %ir.2)
  JMPI %bb.35, implicit $flags

>> JMPI %bb.35, implicit $flags
Regs:
<< JMPI %bb.35, implicit $flags

>> STORE16R %140:gpr, killed %142:gpr :: (store (s16) into %ir.2)
Regs:
Search register for %140 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %140 to $r1
Search register for %142 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %142 to $r2
<< STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)

>> %142:gpr = ADDI killed %141:gpr, 1
Regs: R1=%140 R2=%142
In def of %142 use existing assignment to $r2
Freeing $r2: %142
Search register for %141 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %141 to $r2
<< $r2 = ADDI killed $r2, 1

>> %141:gpr = LOAD16R %140:gpr :: (dereferenceable load (s16) from %ir.2)
Regs: R1=%140 R2=%141
In def of %141 use existing assignment to $r2
Freeing $r2: %141
<< $r2 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)

>> %140:gpr = ADDI %stack.1, 0
Regs: R1=%140
In def of %140 use existing assignment to $r1
Freeing $r1: %140
<< $r1 = ADDI %stack.1, 0
Begin Regs:
Loading live registers at begin of block.
bb.34 (%ir-block.157):
; predecessors: %bb.33, %bb.5
  successors: %bb.35(0x80000000); %bb.35(100.00%)

  $r1 = ADDI %stack.1, 0
  $r2 = LOAD16R $r1 :: (dereferenceable load (s16) from %ir.2)
  $r2 = ADDI killed $r2, 1
  STORE16R killed $r1, killed $r2 :: (store (s16) into %ir.2)
  JMPI %bb.35, implicit $flags

Allocating bb.35 (%ir-block.160):
; predecessors: %bb.2, %bb.34
  successors: %bb.37(0x80000000); %bb.37(100.00%)

  %143:gpr = MOVI 0, implicit $flags
  %144:gpr = ADDI %stack.2, 0
  STORE8R killed %144:gpr, killed %143:gpr :: (store (s8) into %ir.3)
  JMPI %bb.37, implicit $flags

>> JMPI %bb.37, implicit $flags
Regs:
<< JMPI %bb.37, implicit $flags

>> STORE8R killed %144:gpr, killed %143:gpr :: (store (s8) into %ir.3)
Regs:
Search register for %144 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %144 to $r1
Search register for %143 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %143 to $r2
<< STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.3)

>> %144:gpr = ADDI %stack.2, 0
Regs: R1=%144 R2=%143
In def of %144 use existing assignment to $r1
Freeing $r1: %144
<< $r1 = ADDI %stack.2, 0

>> %143:gpr = MOVI 0, implicit $flags
Regs: R2=%143
In def of %143 use existing assignment to $r2
Freeing $r2: %143
<< $r2 = MOVI 0, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.35 (%ir-block.160):
; predecessors: %bb.2, %bb.34
  successors: %bb.37(0x80000000); %bb.37(100.00%)

  $r2 = MOVI 0, implicit $flags
  $r1 = ADDI %stack.2, 0
  STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.3)
  JMPI %bb.37, implicit $flags

Allocating bb.36 (%ir-block.161):
; predecessors: %bb.1
  successors: %bb.37(0x80000000); %bb.37(100.00%)

  %9:gpr = MOVI 1, implicit $flags
  %10:gpr = ADDI %stack.2, 0
  STORE8R killed %10:gpr, killed %9:gpr :: (store (s8) into %ir.3)
  JMPI %bb.37, implicit $flags

>> JMPI %bb.37, implicit $flags
Regs:
<< JMPI %bb.37, implicit $flags

>> STORE8R killed %10:gpr, killed %9:gpr :: (store (s8) into %ir.3)
Regs:
Search register for %10 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %10 to $r1
Search register for %9 in class GPR with hint $noreg
	Register: $r1 already used in instr.
	Register: $r2 Cost: 0 BestCost: 4294967295
Assigning %9 to $r2
<< STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.3)

>> %10:gpr = ADDI %stack.2, 0
Regs: R1=%10 R2=%9
In def of %10 use existing assignment to $r1
Freeing $r1: %10
<< $r1 = ADDI %stack.2, 0

>> %9:gpr = MOVI 1, implicit $flags
Regs: R2=%9
In def of %9 use existing assignment to $r2
Freeing $r2: %9
<< $r2 = MOVI 1, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.36 (%ir-block.161):
; predecessors: %bb.1
  successors: %bb.37(0x80000000); %bb.37(100.00%)

  $r2 = MOVI 1, implicit $flags
  $r1 = ADDI %stack.2, 0
  STORE8R killed $r1, killed $r2 :: (store (s8) into %ir.3)
  JMPI %bb.37, implicit $flags

Allocating bb.37 (%ir-block.162):
; predecessors: %bb.36, %bb.35
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  JMPI %bb.1, implicit $flags

>> JMPI %bb.1, implicit $flags
Regs:
<< JMPI %bb.1, implicit $flags
Begin Regs:
Loading live registers at begin of block.
bb.37 (%ir-block.162):
; predecessors: %bb.36, %bb.35
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  JMPI %bb.1, implicit $flags
Skipping pass 'Fixup Statepoint Caller Saved' on function main
alloc FI(0) at SP[-4]
alloc FI(1) at SP[-6]
alloc FI(2) at SP[-7]
alloc FI(3) at SP[-10]
alloc FI(4) at SP[-16]
alloc FI(5) at SP[-18]
alloc FI(6) at SP[-20]
alloc FI(7) at SP[-22]
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.1, 0
$r1 = ADDI %stack.0, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.3, 0
$r3 = ADDI %stack.1, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r1 = ADDI %stack.3, 0
$r1 = ADDI %stack.4, 0
$r2 = ADDI %stack.4, 0
$r1 = ADDI %stack.1, 0
$r1 = ADDI %stack.1, 0
$r1 = ADDI %stack.1, 0
$r13 = frameptrget %stack.6, implicit-def $r13
$r13 = frameptrget %stack.7, implicit-def $r13
$r13 = frameptrget %stack.7, implicit-def $r13
$r1 = ADDI %stack.5, 0
$r13 = frameptrget %stack.6, implicit-def $r13
$r2 = ADDI %stack.1, 0
$r1 = ADDI %stack.1, 0
$r1 = ADDI %stack.2, 0
$r1 = ADDI %stack.2, 0
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
Skipping pass 'Remove Loads Into Fake Uses' on function main

Debug Range Extension: main
